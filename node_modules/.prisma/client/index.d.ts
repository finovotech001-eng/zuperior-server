
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model KYC
 * 
 */
export type KYC = $Result.DefaultSelection<Prisma.$KYCPayload>
/**
 * Model MT5Account
 * 
 */
export type MT5Account = $Result.DefaultSelection<Prisma.$MT5AccountPayload>
/**
 * Model MT5Transaction
 * 
 */
export type MT5Transaction = $Result.DefaultSelection<Prisma.$MT5TransactionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Deposit
 * 
 */
export type Deposit = $Result.DefaultSelection<Prisma.$DepositPayload>
/**
 * Model Withdrawal
 * 
 */
export type Withdrawal = $Result.DefaultSelection<Prisma.$WithdrawalPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model DefaultMT5Account
 * 
 */
export type DefaultMT5Account = $Result.DefaultSelection<Prisma.$DefaultMT5AccountPayload>
/**
 * Model Instrument
 * 
 */
export type Instrument = $Result.DefaultSelection<Prisma.$InstrumentPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model UserFavorite
 * 
 */
export type UserFavorite = $Result.DefaultSelection<Prisma.$UserFavoritePayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model admin_login_log
 * 
 */
export type admin_login_log = $Result.DefaultSelection<Prisma.$admin_login_logPayload>
/**
 * Model balance_operation_history
 * 
 */
export type balance_operation_history = $Result.DefaultSelection<Prisma.$balance_operation_historyPayload>
/**
 * Model chat_conversations
 * 
 */
export type chat_conversations = $Result.DefaultSelection<Prisma.$chat_conversationsPayload>
/**
 * Model chat_messages
 * 
 */
export type chat_messages = $Result.DefaultSelection<Prisma.$chat_messagesPayload>
/**
 * Model chat_participants
 * 
 */
export type chat_participants = $Result.DefaultSelection<Prisma.$chat_participantsPayload>
/**
 * Model group_commission_structures
 * 
 */
export type group_commission_structures = $Result.DefaultSelection<Prisma.$group_commission_structuresPayload>
/**
 * Model ib_admin
 * 
 */
export type ib_admin = $Result.DefaultSelection<Prisma.$ib_adminPayload>
/**
 * Model ib_requests
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type ib_requests = $Result.DefaultSelection<Prisma.$ib_requestsPayload>
/**
 * Model manual_gateway
 * 
 */
export type manual_gateway = $Result.DefaultSelection<Prisma.$manual_gatewayPayload>
/**
 * Model mt5_groups
 * 
 */
export type mt5_groups = $Result.DefaultSelection<Prisma.$mt5_groupsPayload>
/**
 * Model payment_gateway
 * 
 */
export type payment_gateway = $Result.DefaultSelection<Prisma.$payment_gatewayPayload>
/**
 * Model symbols
 * 
 */
export type symbols = $Result.DefaultSelection<Prisma.$symbolsPayload>
/**
 * Model ib_group_assignments
 * 
 */
export type ib_group_assignments = $Result.DefaultSelection<Prisma.$ib_group_assignmentsPayload>
/**
 * Model ib_trade_history
 * 
 */
export type ib_trade_history = $Result.DefaultSelection<Prisma.$ib_trade_historyPayload>
/**
 * Model support_tickets
 * 
 */
export type support_tickets = $Result.DefaultSelection<Prisma.$support_ticketsPayload>
/**
 * Model support_ticket_replies
 * 
 */
export type support_ticket_replies = $Result.DefaultSelection<Prisma.$support_ticket_repliesPayload>
/**
 * Model support_articles
 * 
 */
export type support_articles = $Result.DefaultSelection<Prisma.$support_articlesPayload>
/**
 * Model support_faq
 * 
 */
export type support_faq = $Result.DefaultSelection<Prisma.$support_faqPayload>
/**
 * Model support_categories
 * 
 */
export type support_categories = $Result.DefaultSelection<Prisma.$support_categoriesPayload>
/**
 * Model support_replies
 * 
 */
export type support_replies = $Result.DefaultSelection<Prisma.$support_repliesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kYC`: Exposes CRUD operations for the **KYC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KYCS
    * const kYCS = await prisma.kYC.findMany()
    * ```
    */
  get kYC(): Prisma.KYCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mT5Account`: Exposes CRUD operations for the **MT5Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MT5Accounts
    * const mT5Accounts = await prisma.mT5Account.findMany()
    * ```
    */
  get mT5Account(): Prisma.MT5AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mT5Transaction`: Exposes CRUD operations for the **MT5Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MT5Transactions
    * const mT5Transactions = await prisma.mT5Transaction.findMany()
    * ```
    */
  get mT5Transaction(): Prisma.MT5TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deposit`: Exposes CRUD operations for the **Deposit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deposits
    * const deposits = await prisma.deposit.findMany()
    * ```
    */
  get deposit(): Prisma.DepositDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawal`: Exposes CRUD operations for the **Withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawal.findMany()
    * ```
    */
  get withdrawal(): Prisma.WithdrawalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.defaultMT5Account`: Exposes CRUD operations for the **DefaultMT5Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefaultMT5Accounts
    * const defaultMT5Accounts = await prisma.defaultMT5Account.findMany()
    * ```
    */
  get defaultMT5Account(): Prisma.DefaultMT5AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instrument`: Exposes CRUD operations for the **Instrument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instruments
    * const instruments = await prisma.instrument.findMany()
    * ```
    */
  get instrument(): Prisma.InstrumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavorite`: Exposes CRUD operations for the **UserFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavorites
    * const userFavorites = await prisma.userFavorite.findMany()
    * ```
    */
  get userFavorite(): Prisma.UserFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin_login_log`: Exposes CRUD operations for the **admin_login_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_login_logs
    * const admin_login_logs = await prisma.admin_login_log.findMany()
    * ```
    */
  get admin_login_log(): Prisma.admin_login_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balance_operation_history`: Exposes CRUD operations for the **balance_operation_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balance_operation_histories
    * const balance_operation_histories = await prisma.balance_operation_history.findMany()
    * ```
    */
  get balance_operation_history(): Prisma.balance_operation_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_conversations`: Exposes CRUD operations for the **chat_conversations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_conversations
    * const chat_conversations = await prisma.chat_conversations.findMany()
    * ```
    */
  get chat_conversations(): Prisma.chat_conversationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_messages`: Exposes CRUD operations for the **chat_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_messages
    * const chat_messages = await prisma.chat_messages.findMany()
    * ```
    */
  get chat_messages(): Prisma.chat_messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_participants`: Exposes CRUD operations for the **chat_participants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_participants
    * const chat_participants = await prisma.chat_participants.findMany()
    * ```
    */
  get chat_participants(): Prisma.chat_participantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group_commission_structures`: Exposes CRUD operations for the **group_commission_structures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Group_commission_structures
    * const group_commission_structures = await prisma.group_commission_structures.findMany()
    * ```
    */
  get group_commission_structures(): Prisma.group_commission_structuresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_admin`: Exposes CRUD operations for the **ib_admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_admins
    * const ib_admins = await prisma.ib_admin.findMany()
    * ```
    */
  get ib_admin(): Prisma.ib_adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_requests`: Exposes CRUD operations for the **ib_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_requests
    * const ib_requests = await prisma.ib_requests.findMany()
    * ```
    */
  get ib_requests(): Prisma.ib_requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manual_gateway`: Exposes CRUD operations for the **manual_gateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manual_gateways
    * const manual_gateways = await prisma.manual_gateway.findMany()
    * ```
    */
  get manual_gateway(): Prisma.manual_gatewayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mt5_groups`: Exposes CRUD operations for the **mt5_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mt5_groups
    * const mt5_groups = await prisma.mt5_groups.findMany()
    * ```
    */
  get mt5_groups(): Prisma.mt5_groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_gateway`: Exposes CRUD operations for the **payment_gateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_gateways
    * const payment_gateways = await prisma.payment_gateway.findMany()
    * ```
    */
  get payment_gateway(): Prisma.payment_gatewayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.symbols`: Exposes CRUD operations for the **symbols** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Symbols
    * const symbols = await prisma.symbols.findMany()
    * ```
    */
  get symbols(): Prisma.symbolsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_group_assignments`: Exposes CRUD operations for the **ib_group_assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_group_assignments
    * const ib_group_assignments = await prisma.ib_group_assignments.findMany()
    * ```
    */
  get ib_group_assignments(): Prisma.ib_group_assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_trade_history`: Exposes CRUD operations for the **ib_trade_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_trade_histories
    * const ib_trade_histories = await prisma.ib_trade_history.findMany()
    * ```
    */
  get ib_trade_history(): Prisma.ib_trade_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_tickets`: Exposes CRUD operations for the **support_tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_tickets
    * const support_tickets = await prisma.support_tickets.findMany()
    * ```
    */
  get support_tickets(): Prisma.support_ticketsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_ticket_replies`: Exposes CRUD operations for the **support_ticket_replies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_ticket_replies
    * const support_ticket_replies = await prisma.support_ticket_replies.findMany()
    * ```
    */
  get support_ticket_replies(): Prisma.support_ticket_repliesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_articles`: Exposes CRUD operations for the **support_articles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_articles
    * const support_articles = await prisma.support_articles.findMany()
    * ```
    */
  get support_articles(): Prisma.support_articlesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_faq`: Exposes CRUD operations for the **support_faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_faqs
    * const support_faqs = await prisma.support_faq.findMany()
    * ```
    */
  get support_faq(): Prisma.support_faqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_categories`: Exposes CRUD operations for the **support_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_categories
    * const support_categories = await prisma.support_categories.findMany()
    * ```
    */
  get support_categories(): Prisma.support_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_replies`: Exposes CRUD operations for the **support_replies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_replies
    * const support_replies = await prisma.support_replies.findMany()
    * ```
    */
  get support_replies(): Prisma.support_repliesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    KYC: 'KYC',
    MT5Account: 'MT5Account',
    MT5Transaction: 'MT5Transaction',
    Account: 'Account',
    Transaction: 'Transaction',
    Deposit: 'Deposit',
    Withdrawal: 'Withdrawal',
    ActivityLog: 'ActivityLog',
    SystemSetting: 'SystemSetting',
    Role: 'Role',
    PaymentMethod: 'PaymentMethod',
    UserRole: 'UserRole',
    DefaultMT5Account: 'DefaultMT5Account',
    Instrument: 'Instrument',
    RefreshToken: 'RefreshToken',
    UserFavorite: 'UserFavorite',
    admin: 'admin',
    admin_login_log: 'admin_login_log',
    balance_operation_history: 'balance_operation_history',
    chat_conversations: 'chat_conversations',
    chat_messages: 'chat_messages',
    chat_participants: 'chat_participants',
    group_commission_structures: 'group_commission_structures',
    ib_admin: 'ib_admin',
    ib_requests: 'ib_requests',
    manual_gateway: 'manual_gateway',
    mt5_groups: 'mt5_groups',
    payment_gateway: 'payment_gateway',
    symbols: 'symbols',
    ib_group_assignments: 'ib_group_assignments',
    ib_trade_history: 'ib_trade_history',
    support_tickets: 'support_tickets',
    support_ticket_replies: 'support_ticket_replies',
    support_articles: 'support_articles',
    support_faq: 'support_faq',
    support_categories: 'support_categories',
    support_replies: 'support_replies'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "kYC" | "mT5Account" | "mT5Transaction" | "account" | "transaction" | "deposit" | "withdrawal" | "activityLog" | "systemSetting" | "role" | "paymentMethod" | "userRole" | "defaultMT5Account" | "instrument" | "refreshToken" | "userFavorite" | "admin" | "admin_login_log" | "balance_operation_history" | "chat_conversations" | "chat_messages" | "chat_participants" | "group_commission_structures" | "ib_admin" | "ib_requests" | "manual_gateway" | "mt5_groups" | "payment_gateway" | "symbols" | "ib_group_assignments" | "ib_trade_history" | "support_tickets" | "support_ticket_replies" | "support_articles" | "support_faq" | "support_categories" | "support_replies"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      KYC: {
        payload: Prisma.$KYCPayload<ExtArgs>
        fields: Prisma.KYCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KYCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KYCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          findFirst: {
            args: Prisma.KYCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KYCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          findMany: {
            args: Prisma.KYCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          create: {
            args: Prisma.KYCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          createMany: {
            args: Prisma.KYCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KYCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          delete: {
            args: Prisma.KYCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          update: {
            args: Prisma.KYCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          deleteMany: {
            args: Prisma.KYCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KYCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KYCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          upsert: {
            args: Prisma.KYCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          aggregate: {
            args: Prisma.KYCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKYC>
          }
          groupBy: {
            args: Prisma.KYCGroupByArgs<ExtArgs>
            result: $Utils.Optional<KYCGroupByOutputType>[]
          }
          count: {
            args: Prisma.KYCCountArgs<ExtArgs>
            result: $Utils.Optional<KYCCountAggregateOutputType> | number
          }
        }
      }
      MT5Account: {
        payload: Prisma.$MT5AccountPayload<ExtArgs>
        fields: Prisma.MT5AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MT5AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MT5AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          findFirst: {
            args: Prisma.MT5AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MT5AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          findMany: {
            args: Prisma.MT5AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          create: {
            args: Prisma.MT5AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          createMany: {
            args: Prisma.MT5AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MT5AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          delete: {
            args: Prisma.MT5AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          update: {
            args: Prisma.MT5AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          deleteMany: {
            args: Prisma.MT5AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MT5AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MT5AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          upsert: {
            args: Prisma.MT5AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          aggregate: {
            args: Prisma.MT5AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMT5Account>
          }
          groupBy: {
            args: Prisma.MT5AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.MT5AccountCountArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountCountAggregateOutputType> | number
          }
        }
      }
      MT5Transaction: {
        payload: Prisma.$MT5TransactionPayload<ExtArgs>
        fields: Prisma.MT5TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MT5TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MT5TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          findFirst: {
            args: Prisma.MT5TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MT5TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          findMany: {
            args: Prisma.MT5TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>[]
          }
          create: {
            args: Prisma.MT5TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          createMany: {
            args: Prisma.MT5TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MT5TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>[]
          }
          delete: {
            args: Prisma.MT5TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          update: {
            args: Prisma.MT5TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          deleteMany: {
            args: Prisma.MT5TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MT5TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MT5TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>[]
          }
          upsert: {
            args: Prisma.MT5TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          aggregate: {
            args: Prisma.MT5TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMT5Transaction>
          }
          groupBy: {
            args: Prisma.MT5TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MT5TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MT5TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<MT5TransactionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Deposit: {
        payload: Prisma.$DepositPayload<ExtArgs>
        fields: Prisma.DepositFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findFirst: {
            args: Prisma.DepositFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findMany: {
            args: Prisma.DepositFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          create: {
            args: Prisma.DepositCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          createMany: {
            args: Prisma.DepositCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepositCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          delete: {
            args: Prisma.DepositDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          update: {
            args: Prisma.DepositUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          deleteMany: {
            args: Prisma.DepositDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepositUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepositUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          upsert: {
            args: Prisma.DepositUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          aggregate: {
            args: Prisma.DepositAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposit>
          }
          groupBy: {
            args: Prisma.DepositGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositCountArgs<ExtArgs>
            result: $Utils.Optional<DepositCountAggregateOutputType> | number
          }
        }
      }
      Withdrawal: {
        payload: Prisma.$WithdrawalPayload<ExtArgs>
        fields: Prisma.WithdrawalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WithdrawalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WithdrawalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findFirst: {
            args: Prisma.WithdrawalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WithdrawalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findMany: {
            args: Prisma.WithdrawalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          create: {
            args: Prisma.WithdrawalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          createMany: {
            args: Prisma.WithdrawalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WithdrawalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          delete: {
            args: Prisma.WithdrawalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          update: {
            args: Prisma.WithdrawalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          deleteMany: {
            args: Prisma.WithdrawalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WithdrawalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WithdrawalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          upsert: {
            args: Prisma.WithdrawalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawal>
          }
          groupBy: {
            args: Prisma.WithdrawalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalGroupByOutputType>[]
          }
          count: {
            args: Prisma.WithdrawalCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      DefaultMT5Account: {
        payload: Prisma.$DefaultMT5AccountPayload<ExtArgs>
        fields: Prisma.DefaultMT5AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefaultMT5AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefaultMT5AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          findFirst: {
            args: Prisma.DefaultMT5AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefaultMT5AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          findMany: {
            args: Prisma.DefaultMT5AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>[]
          }
          create: {
            args: Prisma.DefaultMT5AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          createMany: {
            args: Prisma.DefaultMT5AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefaultMT5AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>[]
          }
          delete: {
            args: Prisma.DefaultMT5AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          update: {
            args: Prisma.DefaultMT5AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          deleteMany: {
            args: Prisma.DefaultMT5AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefaultMT5AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DefaultMT5AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>[]
          }
          upsert: {
            args: Prisma.DefaultMT5AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          aggregate: {
            args: Prisma.DefaultMT5AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefaultMT5Account>
          }
          groupBy: {
            args: Prisma.DefaultMT5AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefaultMT5AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefaultMT5AccountCountArgs<ExtArgs>
            result: $Utils.Optional<DefaultMT5AccountCountAggregateOutputType> | number
          }
        }
      }
      Instrument: {
        payload: Prisma.$InstrumentPayload<ExtArgs>
        fields: Prisma.InstrumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstrumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstrumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          findFirst: {
            args: Prisma.InstrumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstrumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          findMany: {
            args: Prisma.InstrumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>[]
          }
          create: {
            args: Prisma.InstrumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          createMany: {
            args: Prisma.InstrumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstrumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>[]
          }
          delete: {
            args: Prisma.InstrumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          update: {
            args: Prisma.InstrumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          deleteMany: {
            args: Prisma.InstrumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstrumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstrumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>[]
          }
          upsert: {
            args: Prisma.InstrumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          aggregate: {
            args: Prisma.InstrumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstrument>
          }
          groupBy: {
            args: Prisma.InstrumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstrumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstrumentCountArgs<ExtArgs>
            result: $Utils.Optional<InstrumentCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      UserFavorite: {
        payload: Prisma.$UserFavoritePayload<ExtArgs>
        fields: Prisma.UserFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findFirst: {
            args: Prisma.UserFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findMany: {
            args: Prisma.UserFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          create: {
            args: Prisma.UserFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          createMany: {
            args: Prisma.UserFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          delete: {
            args: Prisma.UserFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          update: {
            args: Prisma.UserFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          deleteMany: {
            args: Prisma.UserFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          upsert: {
            args: Prisma.UserFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          aggregate: {
            args: Prisma.UserFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavorite>
          }
          groupBy: {
            args: Prisma.UserFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.adminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      admin_login_log: {
        payload: Prisma.$admin_login_logPayload<ExtArgs>
        fields: Prisma.admin_login_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_login_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_login_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          findFirst: {
            args: Prisma.admin_login_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_login_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          findMany: {
            args: Prisma.admin_login_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>[]
          }
          create: {
            args: Prisma.admin_login_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          createMany: {
            args: Prisma.admin_login_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admin_login_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>[]
          }
          delete: {
            args: Prisma.admin_login_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          update: {
            args: Prisma.admin_login_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          deleteMany: {
            args: Prisma.admin_login_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_login_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.admin_login_logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>[]
          }
          upsert: {
            args: Prisma.admin_login_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          aggregate: {
            args: Prisma.Admin_login_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_login_log>
          }
          groupBy: {
            args: Prisma.admin_login_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_login_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_login_logCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_login_logCountAggregateOutputType> | number
          }
        }
      }
      balance_operation_history: {
        payload: Prisma.$balance_operation_historyPayload<ExtArgs>
        fields: Prisma.balance_operation_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.balance_operation_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.balance_operation_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          findFirst: {
            args: Prisma.balance_operation_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.balance_operation_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          findMany: {
            args: Prisma.balance_operation_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>[]
          }
          create: {
            args: Prisma.balance_operation_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          createMany: {
            args: Prisma.balance_operation_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.balance_operation_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>[]
          }
          delete: {
            args: Prisma.balance_operation_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          update: {
            args: Prisma.balance_operation_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          deleteMany: {
            args: Prisma.balance_operation_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.balance_operation_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.balance_operation_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>[]
          }
          upsert: {
            args: Prisma.balance_operation_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          aggregate: {
            args: Prisma.Balance_operation_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance_operation_history>
          }
          groupBy: {
            args: Prisma.balance_operation_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Balance_operation_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.balance_operation_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Balance_operation_historyCountAggregateOutputType> | number
          }
        }
      }
      chat_conversations: {
        payload: Prisma.$chat_conversationsPayload<ExtArgs>
        fields: Prisma.chat_conversationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_conversationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_conversationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          findFirst: {
            args: Prisma.chat_conversationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_conversationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          findMany: {
            args: Prisma.chat_conversationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>[]
          }
          create: {
            args: Prisma.chat_conversationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          createMany: {
            args: Prisma.chat_conversationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_conversationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>[]
          }
          delete: {
            args: Prisma.chat_conversationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          update: {
            args: Prisma.chat_conversationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          deleteMany: {
            args: Prisma.chat_conversationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_conversationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_conversationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>[]
          }
          upsert: {
            args: Prisma.chat_conversationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          aggregate: {
            args: Prisma.Chat_conversationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_conversations>
          }
          groupBy: {
            args: Prisma.chat_conversationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_conversationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_conversationsCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_conversationsCountAggregateOutputType> | number
          }
        }
      }
      chat_messages: {
        payload: Prisma.$chat_messagesPayload<ExtArgs>
        fields: Prisma.chat_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findFirst: {
            args: Prisma.chat_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findMany: {
            args: Prisma.chat_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          create: {
            args: Prisma.chat_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          createMany: {
            args: Prisma.chat_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          delete: {
            args: Prisma.chat_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          update: {
            args: Prisma.chat_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          deleteMany: {
            args: Prisma.chat_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          upsert: {
            args: Prisma.chat_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          aggregate: {
            args: Prisma.Chat_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_messages>
          }
          groupBy: {
            args: Prisma.chat_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesCountAggregateOutputType> | number
          }
        }
      }
      chat_participants: {
        payload: Prisma.$chat_participantsPayload<ExtArgs>
        fields: Prisma.chat_participantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_participantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_participantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          findFirst: {
            args: Prisma.chat_participantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_participantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          findMany: {
            args: Prisma.chat_participantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>[]
          }
          create: {
            args: Prisma.chat_participantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          createMany: {
            args: Prisma.chat_participantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_participantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>[]
          }
          delete: {
            args: Prisma.chat_participantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          update: {
            args: Prisma.chat_participantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          deleteMany: {
            args: Prisma.chat_participantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_participantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_participantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>[]
          }
          upsert: {
            args: Prisma.chat_participantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          aggregate: {
            args: Prisma.Chat_participantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_participants>
          }
          groupBy: {
            args: Prisma.chat_participantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_participantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_participantsCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_participantsCountAggregateOutputType> | number
          }
        }
      }
      group_commission_structures: {
        payload: Prisma.$group_commission_structuresPayload<ExtArgs>
        fields: Prisma.group_commission_structuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.group_commission_structuresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.group_commission_structuresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          findFirst: {
            args: Prisma.group_commission_structuresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.group_commission_structuresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          findMany: {
            args: Prisma.group_commission_structuresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>[]
          }
          create: {
            args: Prisma.group_commission_structuresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          createMany: {
            args: Prisma.group_commission_structuresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.group_commission_structuresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>[]
          }
          delete: {
            args: Prisma.group_commission_structuresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          update: {
            args: Prisma.group_commission_structuresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          deleteMany: {
            args: Prisma.group_commission_structuresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.group_commission_structuresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.group_commission_structuresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>[]
          }
          upsert: {
            args: Prisma.group_commission_structuresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          aggregate: {
            args: Prisma.Group_commission_structuresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup_commission_structures>
          }
          groupBy: {
            args: Prisma.group_commission_structuresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Group_commission_structuresGroupByOutputType>[]
          }
          count: {
            args: Prisma.group_commission_structuresCountArgs<ExtArgs>
            result: $Utils.Optional<Group_commission_structuresCountAggregateOutputType> | number
          }
        }
      }
      ib_admin: {
        payload: Prisma.$ib_adminPayload<ExtArgs>
        fields: Prisma.ib_adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          findFirst: {
            args: Prisma.ib_adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          findMany: {
            args: Prisma.ib_adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>[]
          }
          create: {
            args: Prisma.ib_adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          createMany: {
            args: Prisma.ib_adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>[]
          }
          delete: {
            args: Prisma.ib_adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          update: {
            args: Prisma.ib_adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          deleteMany: {
            args: Prisma.ib_adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_adminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>[]
          }
          upsert: {
            args: Prisma.ib_adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          aggregate: {
            args: Prisma.Ib_adminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_admin>
          }
          groupBy: {
            args: Prisma.ib_adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_adminGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_adminCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_adminCountAggregateOutputType> | number
          }
        }
      }
      ib_requests: {
        payload: Prisma.$ib_requestsPayload<ExtArgs>
        fields: Prisma.ib_requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          findFirst: {
            args: Prisma.ib_requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          findMany: {
            args: Prisma.ib_requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>[]
          }
          create: {
            args: Prisma.ib_requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          createMany: {
            args: Prisma.ib_requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_requestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>[]
          }
          delete: {
            args: Prisma.ib_requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          update: {
            args: Prisma.ib_requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          deleteMany: {
            args: Prisma.ib_requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_requestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>[]
          }
          upsert: {
            args: Prisma.ib_requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          aggregate: {
            args: Prisma.Ib_requestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_requests>
          }
          groupBy: {
            args: Prisma.ib_requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_requestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_requestsCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_requestsCountAggregateOutputType> | number
          }
        }
      }
      manual_gateway: {
        payload: Prisma.$manual_gatewayPayload<ExtArgs>
        fields: Prisma.manual_gatewayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.manual_gatewayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.manual_gatewayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          findFirst: {
            args: Prisma.manual_gatewayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.manual_gatewayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          findMany: {
            args: Prisma.manual_gatewayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>[]
          }
          create: {
            args: Prisma.manual_gatewayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          createMany: {
            args: Prisma.manual_gatewayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.manual_gatewayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>[]
          }
          delete: {
            args: Prisma.manual_gatewayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          update: {
            args: Prisma.manual_gatewayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          deleteMany: {
            args: Prisma.manual_gatewayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.manual_gatewayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.manual_gatewayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>[]
          }
          upsert: {
            args: Prisma.manual_gatewayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          aggregate: {
            args: Prisma.Manual_gatewayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManual_gateway>
          }
          groupBy: {
            args: Prisma.manual_gatewayGroupByArgs<ExtArgs>
            result: $Utils.Optional<Manual_gatewayGroupByOutputType>[]
          }
          count: {
            args: Prisma.manual_gatewayCountArgs<ExtArgs>
            result: $Utils.Optional<Manual_gatewayCountAggregateOutputType> | number
          }
        }
      }
      mt5_groups: {
        payload: Prisma.$mt5_groupsPayload<ExtArgs>
        fields: Prisma.mt5_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mt5_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mt5_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          findFirst: {
            args: Prisma.mt5_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mt5_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          findMany: {
            args: Prisma.mt5_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>[]
          }
          create: {
            args: Prisma.mt5_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          createMany: {
            args: Prisma.mt5_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mt5_groupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>[]
          }
          delete: {
            args: Prisma.mt5_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          update: {
            args: Prisma.mt5_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          deleteMany: {
            args: Prisma.mt5_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mt5_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mt5_groupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>[]
          }
          upsert: {
            args: Prisma.mt5_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          aggregate: {
            args: Prisma.Mt5_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMt5_groups>
          }
          groupBy: {
            args: Prisma.mt5_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mt5_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mt5_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Mt5_groupsCountAggregateOutputType> | number
          }
        }
      }
      payment_gateway: {
        payload: Prisma.$payment_gatewayPayload<ExtArgs>
        fields: Prisma.payment_gatewayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_gatewayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_gatewayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          findFirst: {
            args: Prisma.payment_gatewayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_gatewayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          findMany: {
            args: Prisma.payment_gatewayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>[]
          }
          create: {
            args: Prisma.payment_gatewayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          createMany: {
            args: Prisma.payment_gatewayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_gatewayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>[]
          }
          delete: {
            args: Prisma.payment_gatewayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          update: {
            args: Prisma.payment_gatewayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          deleteMany: {
            args: Prisma.payment_gatewayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_gatewayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_gatewayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>[]
          }
          upsert: {
            args: Prisma.payment_gatewayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          aggregate: {
            args: Prisma.Payment_gatewayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_gateway>
          }
          groupBy: {
            args: Prisma.payment_gatewayGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_gatewayGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_gatewayCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_gatewayCountAggregateOutputType> | number
          }
        }
      }
      symbols: {
        payload: Prisma.$symbolsPayload<ExtArgs>
        fields: Prisma.symbolsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.symbolsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.symbolsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          findFirst: {
            args: Prisma.symbolsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.symbolsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          findMany: {
            args: Prisma.symbolsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>[]
          }
          create: {
            args: Prisma.symbolsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          createMany: {
            args: Prisma.symbolsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.symbolsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>[]
          }
          delete: {
            args: Prisma.symbolsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          update: {
            args: Prisma.symbolsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          deleteMany: {
            args: Prisma.symbolsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.symbolsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.symbolsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>[]
          }
          upsert: {
            args: Prisma.symbolsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          aggregate: {
            args: Prisma.SymbolsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymbols>
          }
          groupBy: {
            args: Prisma.symbolsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymbolsGroupByOutputType>[]
          }
          count: {
            args: Prisma.symbolsCountArgs<ExtArgs>
            result: $Utils.Optional<SymbolsCountAggregateOutputType> | number
          }
        }
      }
      ib_group_assignments: {
        payload: Prisma.$ib_group_assignmentsPayload<ExtArgs>
        fields: Prisma.ib_group_assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_group_assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_group_assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          findFirst: {
            args: Prisma.ib_group_assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_group_assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          findMany: {
            args: Prisma.ib_group_assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>[]
          }
          create: {
            args: Prisma.ib_group_assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          createMany: {
            args: Prisma.ib_group_assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_group_assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>[]
          }
          delete: {
            args: Prisma.ib_group_assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          update: {
            args: Prisma.ib_group_assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.ib_group_assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_group_assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_group_assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.ib_group_assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          aggregate: {
            args: Prisma.Ib_group_assignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_group_assignments>
          }
          groupBy: {
            args: Prisma.ib_group_assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_group_assignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_group_assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_group_assignmentsCountAggregateOutputType> | number
          }
        }
      }
      ib_trade_history: {
        payload: Prisma.$ib_trade_historyPayload<ExtArgs>
        fields: Prisma.ib_trade_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_trade_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_trade_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          findFirst: {
            args: Prisma.ib_trade_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_trade_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          findMany: {
            args: Prisma.ib_trade_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>[]
          }
          create: {
            args: Prisma.ib_trade_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          createMany: {
            args: Prisma.ib_trade_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_trade_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>[]
          }
          delete: {
            args: Prisma.ib_trade_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          update: {
            args: Prisma.ib_trade_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          deleteMany: {
            args: Prisma.ib_trade_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_trade_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_trade_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>[]
          }
          upsert: {
            args: Prisma.ib_trade_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          aggregate: {
            args: Prisma.Ib_trade_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_trade_history>
          }
          groupBy: {
            args: Prisma.ib_trade_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_trade_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_trade_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_trade_historyCountAggregateOutputType> | number
          }
        }
      }
      support_tickets: {
        payload: Prisma.$support_ticketsPayload<ExtArgs>
        fields: Prisma.support_ticketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_ticketsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_ticketsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          findFirst: {
            args: Prisma.support_ticketsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_ticketsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          findMany: {
            args: Prisma.support_ticketsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>[]
          }
          create: {
            args: Prisma.support_ticketsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          createMany: {
            args: Prisma.support_ticketsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_ticketsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>[]
          }
          delete: {
            args: Prisma.support_ticketsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          update: {
            args: Prisma.support_ticketsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          deleteMany: {
            args: Prisma.support_ticketsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_ticketsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_ticketsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>[]
          }
          upsert: {
            args: Prisma.support_ticketsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          aggregate: {
            args: Prisma.Support_ticketsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_tickets>
          }
          groupBy: {
            args: Prisma.support_ticketsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_ticketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_ticketsCountArgs<ExtArgs>
            result: $Utils.Optional<Support_ticketsCountAggregateOutputType> | number
          }
        }
      }
      support_ticket_replies: {
        payload: Prisma.$support_ticket_repliesPayload<ExtArgs>
        fields: Prisma.support_ticket_repliesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_ticket_repliesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_ticket_repliesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          findFirst: {
            args: Prisma.support_ticket_repliesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_ticket_repliesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          findMany: {
            args: Prisma.support_ticket_repliesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>[]
          }
          create: {
            args: Prisma.support_ticket_repliesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          createMany: {
            args: Prisma.support_ticket_repliesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_ticket_repliesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>[]
          }
          delete: {
            args: Prisma.support_ticket_repliesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          update: {
            args: Prisma.support_ticket_repliesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          deleteMany: {
            args: Prisma.support_ticket_repliesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_ticket_repliesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_ticket_repliesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>[]
          }
          upsert: {
            args: Prisma.support_ticket_repliesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          aggregate: {
            args: Prisma.Support_ticket_repliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_ticket_replies>
          }
          groupBy: {
            args: Prisma.support_ticket_repliesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_ticket_repliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_ticket_repliesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_ticket_repliesCountAggregateOutputType> | number
          }
        }
      }
      support_articles: {
        payload: Prisma.$support_articlesPayload<ExtArgs>
        fields: Prisma.support_articlesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_articlesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_articlesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          findFirst: {
            args: Prisma.support_articlesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_articlesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          findMany: {
            args: Prisma.support_articlesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>[]
          }
          create: {
            args: Prisma.support_articlesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          createMany: {
            args: Prisma.support_articlesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_articlesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>[]
          }
          delete: {
            args: Prisma.support_articlesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          update: {
            args: Prisma.support_articlesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          deleteMany: {
            args: Prisma.support_articlesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_articlesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_articlesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>[]
          }
          upsert: {
            args: Prisma.support_articlesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          aggregate: {
            args: Prisma.Support_articlesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_articles>
          }
          groupBy: {
            args: Prisma.support_articlesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_articlesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_articlesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_articlesCountAggregateOutputType> | number
          }
        }
      }
      support_faq: {
        payload: Prisma.$support_faqPayload<ExtArgs>
        fields: Prisma.support_faqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_faqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_faqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          findFirst: {
            args: Prisma.support_faqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_faqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          findMany: {
            args: Prisma.support_faqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>[]
          }
          create: {
            args: Prisma.support_faqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          createMany: {
            args: Prisma.support_faqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_faqCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>[]
          }
          delete: {
            args: Prisma.support_faqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          update: {
            args: Prisma.support_faqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          deleteMany: {
            args: Prisma.support_faqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_faqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_faqUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>[]
          }
          upsert: {
            args: Prisma.support_faqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          aggregate: {
            args: Prisma.Support_faqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_faq>
          }
          groupBy: {
            args: Prisma.support_faqGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_faqGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_faqCountArgs<ExtArgs>
            result: $Utils.Optional<Support_faqCountAggregateOutputType> | number
          }
        }
      }
      support_categories: {
        payload: Prisma.$support_categoriesPayload<ExtArgs>
        fields: Prisma.support_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          findFirst: {
            args: Prisma.support_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          findMany: {
            args: Prisma.support_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>[]
          }
          create: {
            args: Prisma.support_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          createMany: {
            args: Prisma.support_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>[]
          }
          delete: {
            args: Prisma.support_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          update: {
            args: Prisma.support_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.support_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.support_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Support_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_categories>
          }
          groupBy: {
            args: Prisma.support_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_categoriesCountAggregateOutputType> | number
          }
        }
      }
      support_replies: {
        payload: Prisma.$support_repliesPayload<ExtArgs>
        fields: Prisma.support_repliesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_repliesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_repliesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          findFirst: {
            args: Prisma.support_repliesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_repliesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          findMany: {
            args: Prisma.support_repliesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>[]
          }
          create: {
            args: Prisma.support_repliesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          createMany: {
            args: Prisma.support_repliesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_repliesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>[]
          }
          delete: {
            args: Prisma.support_repliesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          update: {
            args: Prisma.support_repliesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          deleteMany: {
            args: Prisma.support_repliesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_repliesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_repliesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>[]
          }
          upsert: {
            args: Prisma.support_repliesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          aggregate: {
            args: Prisma.Support_repliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_replies>
          }
          groupBy: {
            args: Prisma.support_repliesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_repliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_repliesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_repliesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    kYC?: KYCOmit
    mT5Account?: MT5AccountOmit
    mT5Transaction?: MT5TransactionOmit
    account?: AccountOmit
    transaction?: TransactionOmit
    deposit?: DepositOmit
    withdrawal?: WithdrawalOmit
    activityLog?: ActivityLogOmit
    systemSetting?: SystemSettingOmit
    role?: RoleOmit
    paymentMethod?: PaymentMethodOmit
    userRole?: UserRoleOmit
    defaultMT5Account?: DefaultMT5AccountOmit
    instrument?: InstrumentOmit
    refreshToken?: RefreshTokenOmit
    userFavorite?: UserFavoriteOmit
    admin?: adminOmit
    admin_login_log?: admin_login_logOmit
    balance_operation_history?: balance_operation_historyOmit
    chat_conversations?: chat_conversationsOmit
    chat_messages?: chat_messagesOmit
    chat_participants?: chat_participantsOmit
    group_commission_structures?: group_commission_structuresOmit
    ib_admin?: ib_adminOmit
    ib_requests?: ib_requestsOmit
    manual_gateway?: manual_gatewayOmit
    mt5_groups?: mt5_groupsOmit
    payment_gateway?: payment_gatewayOmit
    symbols?: symbolsOmit
    ib_group_assignments?: ib_group_assignmentsOmit
    ib_trade_history?: ib_trade_historyOmit
    support_tickets?: support_ticketsOmit
    support_ticket_replies?: support_ticket_repliesOmit
    support_articles?: support_articlesOmit
    support_faq?: support_faqOmit
    support_categories?: support_categoriesOmit
    support_replies?: support_repliesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    activityLogs: number
    deposits: number
    mt5Accounts: number
    RefreshToken: number
    transactions: number
    UserFavorite: number
    withdrawals: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    deposits?: boolean | UserCountOutputTypeCountDepositsArgs
    mt5Accounts?: boolean | UserCountOutputTypeCountMt5AccountsArgs
    RefreshToken?: boolean | UserCountOutputTypeCountRefreshTokenArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    UserFavorite?: boolean | UserCountOutputTypeCountUserFavoriteArgs
    withdrawals?: boolean | UserCountOutputTypeCountWithdrawalsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMt5AccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWithdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
  }


  /**
   * Count Type MT5AccountCountOutputType
   */

  export type MT5AccountCountOutputType = {
    DefaultMT5Account: number
    deposits: number
    mt5Transactions: number
    withdrawals: number
  }

  export type MT5AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DefaultMT5Account?: boolean | MT5AccountCountOutputTypeCountDefaultMT5AccountArgs
    deposits?: boolean | MT5AccountCountOutputTypeCountDepositsArgs
    mt5Transactions?: boolean | MT5AccountCountOutputTypeCountMt5TransactionsArgs
    withdrawals?: boolean | MT5AccountCountOutputTypeCountWithdrawalsArgs
  }

  // Custom InputTypes
  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountCountOutputType
     */
    select?: MT5AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountDefaultMT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultMT5AccountWhereInput
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountMt5TransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5TransactionWhereInput
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountWithdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
  }


  /**
   * Count Type DepositCountOutputType
   */

  export type DepositCountOutputType = {
    transactions: number
  }

  export type DepositCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | DepositCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * DepositCountOutputType without action
   */
  export type DepositCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositCountOutputType
     */
    select?: DepositCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepositCountOutputType without action
   */
  export type DepositCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type WithdrawalCountOutputType
   */

  export type WithdrawalCountOutputType = {
    transactions: number
  }

  export type WithdrawalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WithdrawalCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WithdrawalCountOutputType without action
   */
  export type WithdrawalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalCountOutputType
     */
    select?: WithdrawalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WithdrawalCountOutputType without action
   */
  export type WithdrawalCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type InstrumentCountOutputType
   */

  export type InstrumentCountOutputType = {
    UserFavorite: number
  }

  export type InstrumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserFavorite?: boolean | InstrumentCountOutputTypeCountUserFavoriteArgs
  }

  // Custom InputTypes
  /**
   * InstrumentCountOutputType without action
   */
  export type InstrumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstrumentCountOutputType
     */
    select?: InstrumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstrumentCountOutputType without action
   */
  export type InstrumentCountOutputTypeCountUserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    admin_login_log: number
    balance_operation_history: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_login_log?: boolean | AdminCountOutputTypeCountAdmin_login_logArgs
    balance_operation_history?: boolean | AdminCountOutputTypeCountBalance_operation_historyArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAdmin_login_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_login_logWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountBalance_operation_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balance_operation_historyWhereInput
  }


  /**
   * Count Type Chat_conversationsCountOutputType
   */

  export type Chat_conversationsCountOutputType = {
    chat_messages: number
    chat_participants: number
  }

  export type Chat_conversationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | Chat_conversationsCountOutputTypeCountChat_messagesArgs
    chat_participants?: boolean | Chat_conversationsCountOutputTypeCountChat_participantsArgs
  }

  // Custom InputTypes
  /**
   * Chat_conversationsCountOutputType without action
   */
  export type Chat_conversationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat_conversationsCountOutputType
     */
    select?: Chat_conversationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Chat_conversationsCountOutputType without action
   */
  export type Chat_conversationsCountOutputTypeCountChat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
  }

  /**
   * Chat_conversationsCountOutputType without action
   */
  export type Chat_conversationsCountOutputTypeCountChat_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_participantsWhereInput
  }


  /**
   * Count Type Ib_requestsCountOutputType
   */

  export type Ib_requestsCountOutputType = {
    ib_group_assignments: number
  }

  export type Ib_requestsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_group_assignments?: boolean | Ib_requestsCountOutputTypeCountIb_group_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * Ib_requestsCountOutputType without action
   */
  export type Ib_requestsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ib_requestsCountOutputType
     */
    select?: Ib_requestsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ib_requestsCountOutputType without action
   */
  export type Ib_requestsCountOutputTypeCountIb_group_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_group_assignmentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    country: string | null
    createdAt: Date | null
    emailVerified: boolean | null
    lastLoginAt: Date | null
    role: string | null
    status: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    country: string | null
    createdAt: Date | null
    emailVerified: boolean | null
    lastLoginAt: Date | null
    role: string | null
    status: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    clientId: number
    email: number
    password: number
    name: number
    phone: number
    country: number
    createdAt: number
    emailVerified: number
    lastLoginAt: number
    role: number
    status: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    clientId?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    country?: true
    createdAt?: true
    emailVerified?: true
    lastLoginAt?: true
    role?: true
    status?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    clientId?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    country?: true
    createdAt?: true
    emailVerified?: true
    lastLoginAt?: true
    role?: true
    status?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    clientId?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    country?: true
    createdAt?: true
    emailVerified?: true
    lastLoginAt?: true
    role?: true
    status?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    clientId: string
    email: string
    password: string
    name: string | null
    phone: string | null
    country: string | null
    createdAt: Date
    emailVerified: boolean
    lastLoginAt: Date | null
    role: string
    status: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    DefaultMT5Account?: boolean | User$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | User$depositsArgs<ExtArgs>
    kyc?: boolean | User$kycArgs<ExtArgs>
    mt5Accounts?: boolean | User$mt5AccountsArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    UserFavorite?: boolean | User$UserFavoriteArgs<ExtArgs>
    withdrawals?: boolean | User$withdrawalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "email" | "password" | "name" | "phone" | "country" | "createdAt" | "emailVerified" | "lastLoginAt" | "role" | "status", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    DefaultMT5Account?: boolean | User$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | User$depositsArgs<ExtArgs>
    kyc?: boolean | User$kycArgs<ExtArgs>
    mt5Accounts?: boolean | User$mt5AccountsArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    UserFavorite?: boolean | User$UserFavoriteArgs<ExtArgs>
    withdrawals?: boolean | User$withdrawalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      DefaultMT5Account: Prisma.$DefaultMT5AccountPayload<ExtArgs> | null
      deposits: Prisma.$DepositPayload<ExtArgs>[]
      kyc: Prisma.$KYCPayload<ExtArgs> | null
      mt5Accounts: Prisma.$MT5AccountPayload<ExtArgs>[]
      RefreshToken: Prisma.$RefreshTokenPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      UserFavorite: Prisma.$UserFavoritePayload<ExtArgs>[]
      withdrawals: Prisma.$WithdrawalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      email: string
      password: string
      name: string | null
      phone: string | null
      country: string | null
      createdAt: Date
      emailVerified: boolean
      lastLoginAt: Date | null
      role: string
      status: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DefaultMT5Account<T extends User$DefaultMT5AccountArgs<ExtArgs> = {}>(args?: Subset<T, User$DefaultMT5AccountArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deposits<T extends User$depositsArgs<ExtArgs> = {}>(args?: Subset<T, User$depositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kyc<T extends User$kycArgs<ExtArgs> = {}>(args?: Subset<T, User$kycArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mt5Accounts<T extends User$mt5AccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$mt5AccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RefreshToken<T extends User$RefreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$RefreshTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserFavorite<T extends User$UserFavoriteArgs<ExtArgs> = {}>(args?: Subset<T, User$UserFavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    withdrawals<T extends User$withdrawalsArgs<ExtArgs> = {}>(args?: Subset<T, User$withdrawalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly clientId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.DefaultMT5Account
   */
  export type User$DefaultMT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    where?: DefaultMT5AccountWhereInput
  }

  /**
   * User.deposits
   */
  export type User$depositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    cursor?: DepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * User.kyc
   */
  export type User$kycArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    where?: KYCWhereInput
  }

  /**
   * User.mt5Accounts
   */
  export type User$mt5AccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    where?: MT5AccountWhereInput
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    cursor?: MT5AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * User.RefreshToken
   */
  export type User$RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.UserFavorite
   */
  export type User$UserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * User.withdrawals
   */
  export type User$withdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    cursor?: WithdrawalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model KYC
   */

  export type AggregateKYC = {
    _count: KYCCountAggregateOutputType | null
    _min: KYCMinAggregateOutputType | null
    _max: KYCMaxAggregateOutputType | null
  }

  export type KYCMinAggregateOutputType = {
    id: string | null
    isDocumentVerified: boolean | null
    isAddressVerified: boolean | null
    verificationStatus: string | null
    documentReference: string | null
    addressReference: string | null
    amlReference: string | null
    documentSubmittedAt: Date | null
    addressSubmittedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type KYCMaxAggregateOutputType = {
    id: string | null
    isDocumentVerified: boolean | null
    isAddressVerified: boolean | null
    verificationStatus: string | null
    documentReference: string | null
    addressReference: string | null
    amlReference: string | null
    documentSubmittedAt: Date | null
    addressSubmittedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type KYCCountAggregateOutputType = {
    id: number
    isDocumentVerified: number
    isAddressVerified: number
    verificationStatus: number
    documentReference: number
    addressReference: number
    amlReference: number
    documentSubmittedAt: number
    addressSubmittedAt: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type KYCMinAggregateInputType = {
    id?: true
    isDocumentVerified?: true
    isAddressVerified?: true
    verificationStatus?: true
    documentReference?: true
    addressReference?: true
    amlReference?: true
    documentSubmittedAt?: true
    addressSubmittedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type KYCMaxAggregateInputType = {
    id?: true
    isDocumentVerified?: true
    isAddressVerified?: true
    verificationStatus?: true
    documentReference?: true
    addressReference?: true
    amlReference?: true
    documentSubmittedAt?: true
    addressSubmittedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type KYCCountAggregateInputType = {
    id?: true
    isDocumentVerified?: true
    isAddressVerified?: true
    verificationStatus?: true
    documentReference?: true
    addressReference?: true
    amlReference?: true
    documentSubmittedAt?: true
    addressSubmittedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type KYCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYC to aggregate.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KYCS
    **/
    _count?: true | KYCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KYCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KYCMaxAggregateInputType
  }

  export type GetKYCAggregateType<T extends KYCAggregateArgs> = {
        [P in keyof T & keyof AggregateKYC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKYC[P]>
      : GetScalarType<T[P], AggregateKYC[P]>
  }




  export type KYCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCWhereInput
    orderBy?: KYCOrderByWithAggregationInput | KYCOrderByWithAggregationInput[]
    by: KYCScalarFieldEnum[] | KYCScalarFieldEnum
    having?: KYCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KYCCountAggregateInputType | true
    _min?: KYCMinAggregateInputType
    _max?: KYCMaxAggregateInputType
  }

  export type KYCGroupByOutputType = {
    id: string
    isDocumentVerified: boolean
    isAddressVerified: boolean
    verificationStatus: string
    documentReference: string | null
    addressReference: string | null
    amlReference: string | null
    documentSubmittedAt: Date | null
    addressSubmittedAt: Date | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: KYCCountAggregateOutputType | null
    _min: KYCMinAggregateOutputType | null
    _max: KYCMaxAggregateOutputType | null
  }

  type GetKYCGroupByPayload<T extends KYCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KYCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KYCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KYCGroupByOutputType[P]>
            : GetScalarType<T[P], KYCGroupByOutputType[P]>
        }
      >
    >


  export type KYCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectScalar = {
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type KYCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isDocumentVerified" | "isAddressVerified" | "verificationStatus" | "documentReference" | "addressReference" | "amlReference" | "documentSubmittedAt" | "addressSubmittedAt" | "rejectionReason" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["kYC"]>
  export type KYCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KYCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KYC"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isDocumentVerified: boolean
      isAddressVerified: boolean
      verificationStatus: string
      documentReference: string | null
      addressReference: string | null
      amlReference: string | null
      documentSubmittedAt: Date | null
      addressSubmittedAt: Date | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["kYC"]>
    composites: {}
  }

  type KYCGetPayload<S extends boolean | null | undefined | KYCDefaultArgs> = $Result.GetResult<Prisma.$KYCPayload, S>

  type KYCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KYCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KYCCountAggregateInputType | true
    }

  export interface KYCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KYC'], meta: { name: 'KYC' } }
    /**
     * Find zero or one KYC that matches the filter.
     * @param {KYCFindUniqueArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KYCFindUniqueArgs>(args: SelectSubset<T, KYCFindUniqueArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KYC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KYCFindUniqueOrThrowArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KYCFindUniqueOrThrowArgs>(args: SelectSubset<T, KYCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindFirstArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KYCFindFirstArgs>(args?: SelectSubset<T, KYCFindFirstArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindFirstOrThrowArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KYCFindFirstOrThrowArgs>(args?: SelectSubset<T, KYCFindFirstOrThrowArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KYCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KYCS
     * const kYCS = await prisma.kYC.findMany()
     * 
     * // Get first 10 KYCS
     * const kYCS = await prisma.kYC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kYCWithIdOnly = await prisma.kYC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KYCFindManyArgs>(args?: SelectSubset<T, KYCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KYC.
     * @param {KYCCreateArgs} args - Arguments to create a KYC.
     * @example
     * // Create one KYC
     * const KYC = await prisma.kYC.create({
     *   data: {
     *     // ... data to create a KYC
     *   }
     * })
     * 
     */
    create<T extends KYCCreateArgs>(args: SelectSubset<T, KYCCreateArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KYCS.
     * @param {KYCCreateManyArgs} args - Arguments to create many KYCS.
     * @example
     * // Create many KYCS
     * const kYC = await prisma.kYC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KYCCreateManyArgs>(args?: SelectSubset<T, KYCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KYCS and returns the data saved in the database.
     * @param {KYCCreateManyAndReturnArgs} args - Arguments to create many KYCS.
     * @example
     * // Create many KYCS
     * const kYC = await prisma.kYC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KYCS and only return the `id`
     * const kYCWithIdOnly = await prisma.kYC.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KYCCreateManyAndReturnArgs>(args?: SelectSubset<T, KYCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KYC.
     * @param {KYCDeleteArgs} args - Arguments to delete one KYC.
     * @example
     * // Delete one KYC
     * const KYC = await prisma.kYC.delete({
     *   where: {
     *     // ... filter to delete one KYC
     *   }
     * })
     * 
     */
    delete<T extends KYCDeleteArgs>(args: SelectSubset<T, KYCDeleteArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KYC.
     * @param {KYCUpdateArgs} args - Arguments to update one KYC.
     * @example
     * // Update one KYC
     * const kYC = await prisma.kYC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KYCUpdateArgs>(args: SelectSubset<T, KYCUpdateArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KYCS.
     * @param {KYCDeleteManyArgs} args - Arguments to filter KYCS to delete.
     * @example
     * // Delete a few KYCS
     * const { count } = await prisma.kYC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KYCDeleteManyArgs>(args?: SelectSubset<T, KYCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KYCS
     * const kYC = await prisma.kYC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KYCUpdateManyArgs>(args: SelectSubset<T, KYCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCS and returns the data updated in the database.
     * @param {KYCUpdateManyAndReturnArgs} args - Arguments to update many KYCS.
     * @example
     * // Update many KYCS
     * const kYC = await prisma.kYC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KYCS and only return the `id`
     * const kYCWithIdOnly = await prisma.kYC.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KYCUpdateManyAndReturnArgs>(args: SelectSubset<T, KYCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KYC.
     * @param {KYCUpsertArgs} args - Arguments to update or create a KYC.
     * @example
     * // Update or create a KYC
     * const kYC = await prisma.kYC.upsert({
     *   create: {
     *     // ... data to create a KYC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KYC we want to update
     *   }
     * })
     */
    upsert<T extends KYCUpsertArgs>(args: SelectSubset<T, KYCUpsertArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCCountArgs} args - Arguments to filter KYCS to count.
     * @example
     * // Count the number of KYCS
     * const count = await prisma.kYC.count({
     *   where: {
     *     // ... the filter for the KYCS we want to count
     *   }
     * })
    **/
    count<T extends KYCCountArgs>(
      args?: Subset<T, KYCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KYCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KYCAggregateArgs>(args: Subset<T, KYCAggregateArgs>): Prisma.PrismaPromise<GetKYCAggregateType<T>>

    /**
     * Group by KYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KYCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KYCGroupByArgs['orderBy'] }
        : { orderBy?: KYCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KYCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKYCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KYC model
   */
  readonly fields: KYCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KYC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KYCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KYC model
   */
  interface KYCFieldRefs {
    readonly id: FieldRef<"KYC", 'String'>
    readonly isDocumentVerified: FieldRef<"KYC", 'Boolean'>
    readonly isAddressVerified: FieldRef<"KYC", 'Boolean'>
    readonly verificationStatus: FieldRef<"KYC", 'String'>
    readonly documentReference: FieldRef<"KYC", 'String'>
    readonly addressReference: FieldRef<"KYC", 'String'>
    readonly amlReference: FieldRef<"KYC", 'String'>
    readonly documentSubmittedAt: FieldRef<"KYC", 'DateTime'>
    readonly addressSubmittedAt: FieldRef<"KYC", 'DateTime'>
    readonly rejectionReason: FieldRef<"KYC", 'String'>
    readonly createdAt: FieldRef<"KYC", 'DateTime'>
    readonly updatedAt: FieldRef<"KYC", 'DateTime'>
    readonly userId: FieldRef<"KYC", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KYC findUnique
   */
  export type KYCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC findUniqueOrThrow
   */
  export type KYCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC findFirst
   */
  export type KYCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCS.
     */
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC findFirstOrThrow
   */
  export type KYCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCS.
     */
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC findMany
   */
  export type KYCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYCS to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC create
   */
  export type KYCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The data needed to create a KYC.
     */
    data: XOR<KYCCreateInput, KYCUncheckedCreateInput>
  }

  /**
   * KYC createMany
   */
  export type KYCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KYCS.
     */
    data: KYCCreateManyInput | KYCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KYC createManyAndReturn
   */
  export type KYCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * The data used to create many KYCS.
     */
    data: KYCCreateManyInput | KYCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYC update
   */
  export type KYCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The data needed to update a KYC.
     */
    data: XOR<KYCUpdateInput, KYCUncheckedUpdateInput>
    /**
     * Choose, which KYC to update.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC updateMany
   */
  export type KYCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KYCS.
     */
    data: XOR<KYCUpdateManyMutationInput, KYCUncheckedUpdateManyInput>
    /**
     * Filter which KYCS to update
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to update.
     */
    limit?: number
  }

  /**
   * KYC updateManyAndReturn
   */
  export type KYCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * The data used to update KYCS.
     */
    data: XOR<KYCUpdateManyMutationInput, KYCUncheckedUpdateManyInput>
    /**
     * Filter which KYCS to update
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYC upsert
   */
  export type KYCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The filter to search for the KYC to update in case it exists.
     */
    where: KYCWhereUniqueInput
    /**
     * In case the KYC found by the `where` argument doesn't exist, create a new KYC with this data.
     */
    create: XOR<KYCCreateInput, KYCUncheckedCreateInput>
    /**
     * In case the KYC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KYCUpdateInput, KYCUncheckedUpdateInput>
  }

  /**
   * KYC delete
   */
  export type KYCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter which KYC to delete.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC deleteMany
   */
  export type KYCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCS to delete
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to delete.
     */
    limit?: number
  }

  /**
   * KYC without action
   */
  export type KYCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
  }


  /**
   * Model MT5Account
   */

  export type AggregateMT5Account = {
    _count: MT5AccountCountAggregateOutputType | null
    _avg: MT5AccountAvgAggregateOutputType | null
    _sum: MT5AccountSumAggregateOutputType | null
    _min: MT5AccountMinAggregateOutputType | null
    _max: MT5AccountMaxAggregateOutputType | null
  }

  export type MT5AccountAvgAggregateOutputType = {
    leverage: number | null
  }

  export type MT5AccountSumAggregateOutputType = {
    leverage: number | null
  }

  export type MT5AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    accountType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    leverage: number | null
  }

  export type MT5AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    accountType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    leverage: number | null
  }

  export type MT5AccountCountAggregateOutputType = {
    id: number
    accountId: number
    userId: number
    accountType: number
    createdAt: number
    updatedAt: number
    password: number
    leverage: number
    _all: number
  }


  export type MT5AccountAvgAggregateInputType = {
    leverage?: true
  }

  export type MT5AccountSumAggregateInputType = {
    leverage?: true
  }

  export type MT5AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    accountType?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    leverage?: true
  }

  export type MT5AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    accountType?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    leverage?: true
  }

  export type MT5AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    accountType?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    leverage?: true
    _all?: true
  }

  export type MT5AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Account to aggregate.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MT5Accounts
    **/
    _count?: true | MT5AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MT5AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MT5AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MT5AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MT5AccountMaxAggregateInputType
  }

  export type GetMT5AccountAggregateType<T extends MT5AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateMT5Account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMT5Account[P]>
      : GetScalarType<T[P], AggregateMT5Account[P]>
  }




  export type MT5AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountWhereInput
    orderBy?: MT5AccountOrderByWithAggregationInput | MT5AccountOrderByWithAggregationInput[]
    by: MT5AccountScalarFieldEnum[] | MT5AccountScalarFieldEnum
    having?: MT5AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MT5AccountCountAggregateInputType | true
    _avg?: MT5AccountAvgAggregateInputType
    _sum?: MT5AccountSumAggregateInputType
    _min?: MT5AccountMinAggregateInputType
    _max?: MT5AccountMaxAggregateInputType
  }

  export type MT5AccountGroupByOutputType = {
    id: string
    accountId: string
    userId: string | null
    accountType: string
    createdAt: Date
    updatedAt: Date
    password: string | null
    leverage: number | null
    _count: MT5AccountCountAggregateOutputType | null
    _avg: MT5AccountAvgAggregateOutputType | null
    _sum: MT5AccountSumAggregateOutputType | null
    _min: MT5AccountMinAggregateOutputType | null
    _max: MT5AccountMaxAggregateOutputType | null
  }

  type GetMT5AccountGroupByPayload<T extends MT5AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MT5AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MT5AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MT5AccountGroupByOutputType[P]>
            : GetScalarType<T[P], MT5AccountGroupByOutputType[P]>
        }
      >
    >


  export type MT5AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
    DefaultMT5Account?: boolean | MT5Account$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | MT5Account$depositsArgs<ExtArgs>
    user?: boolean | MT5Account$userArgs<ExtArgs>
    mt5Transactions?: boolean | MT5Account$mt5TransactionsArgs<ExtArgs>
    withdrawals?: boolean | MT5Account$withdrawalsArgs<ExtArgs>
    _count?: boolean | MT5AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
  }

  export type MT5AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "userId" | "accountType" | "createdAt" | "updatedAt" | "password" | "leverage", ExtArgs["result"]["mT5Account"]>
  export type MT5AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DefaultMT5Account?: boolean | MT5Account$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | MT5Account$depositsArgs<ExtArgs>
    user?: boolean | MT5Account$userArgs<ExtArgs>
    mt5Transactions?: boolean | MT5Account$mt5TransactionsArgs<ExtArgs>
    withdrawals?: boolean | MT5Account$withdrawalsArgs<ExtArgs>
    _count?: boolean | MT5AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MT5AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }
  export type MT5AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }

  export type $MT5AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MT5Account"
    objects: {
      DefaultMT5Account: Prisma.$DefaultMT5AccountPayload<ExtArgs>[]
      deposits: Prisma.$DepositPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      mt5Transactions: Prisma.$MT5TransactionPayload<ExtArgs>[]
      withdrawals: Prisma.$WithdrawalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      userId: string | null
      accountType: string
      createdAt: Date
      updatedAt: Date
      password: string | null
      leverage: number | null
    }, ExtArgs["result"]["mT5Account"]>
    composites: {}
  }

  type MT5AccountGetPayload<S extends boolean | null | undefined | MT5AccountDefaultArgs> = $Result.GetResult<Prisma.$MT5AccountPayload, S>

  type MT5AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MT5AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MT5AccountCountAggregateInputType | true
    }

  export interface MT5AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MT5Account'], meta: { name: 'MT5Account' } }
    /**
     * Find zero or one MT5Account that matches the filter.
     * @param {MT5AccountFindUniqueArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MT5AccountFindUniqueArgs>(args: SelectSubset<T, MT5AccountFindUniqueArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MT5Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MT5AccountFindUniqueOrThrowArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MT5AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, MT5AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindFirstArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MT5AccountFindFirstArgs>(args?: SelectSubset<T, MT5AccountFindFirstArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindFirstOrThrowArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MT5AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, MT5AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MT5Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MT5Accounts
     * const mT5Accounts = await prisma.mT5Account.findMany()
     * 
     * // Get first 10 MT5Accounts
     * const mT5Accounts = await prisma.mT5Account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MT5AccountFindManyArgs>(args?: SelectSubset<T, MT5AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MT5Account.
     * @param {MT5AccountCreateArgs} args - Arguments to create a MT5Account.
     * @example
     * // Create one MT5Account
     * const MT5Account = await prisma.mT5Account.create({
     *   data: {
     *     // ... data to create a MT5Account
     *   }
     * })
     * 
     */
    create<T extends MT5AccountCreateArgs>(args: SelectSubset<T, MT5AccountCreateArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MT5Accounts.
     * @param {MT5AccountCreateManyArgs} args - Arguments to create many MT5Accounts.
     * @example
     * // Create many MT5Accounts
     * const mT5Account = await prisma.mT5Account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MT5AccountCreateManyArgs>(args?: SelectSubset<T, MT5AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MT5Accounts and returns the data saved in the database.
     * @param {MT5AccountCreateManyAndReturnArgs} args - Arguments to create many MT5Accounts.
     * @example
     * // Create many MT5Accounts
     * const mT5Account = await prisma.mT5Account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MT5Accounts and only return the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MT5AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, MT5AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MT5Account.
     * @param {MT5AccountDeleteArgs} args - Arguments to delete one MT5Account.
     * @example
     * // Delete one MT5Account
     * const MT5Account = await prisma.mT5Account.delete({
     *   where: {
     *     // ... filter to delete one MT5Account
     *   }
     * })
     * 
     */
    delete<T extends MT5AccountDeleteArgs>(args: SelectSubset<T, MT5AccountDeleteArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MT5Account.
     * @param {MT5AccountUpdateArgs} args - Arguments to update one MT5Account.
     * @example
     * // Update one MT5Account
     * const mT5Account = await prisma.mT5Account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MT5AccountUpdateArgs>(args: SelectSubset<T, MT5AccountUpdateArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MT5Accounts.
     * @param {MT5AccountDeleteManyArgs} args - Arguments to filter MT5Accounts to delete.
     * @example
     * // Delete a few MT5Accounts
     * const { count } = await prisma.mT5Account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MT5AccountDeleteManyArgs>(args?: SelectSubset<T, MT5AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MT5Accounts
     * const mT5Account = await prisma.mT5Account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MT5AccountUpdateManyArgs>(args: SelectSubset<T, MT5AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Accounts and returns the data updated in the database.
     * @param {MT5AccountUpdateManyAndReturnArgs} args - Arguments to update many MT5Accounts.
     * @example
     * // Update many MT5Accounts
     * const mT5Account = await prisma.mT5Account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MT5Accounts and only return the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MT5AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, MT5AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MT5Account.
     * @param {MT5AccountUpsertArgs} args - Arguments to update or create a MT5Account.
     * @example
     * // Update or create a MT5Account
     * const mT5Account = await prisma.mT5Account.upsert({
     *   create: {
     *     // ... data to create a MT5Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MT5Account we want to update
     *   }
     * })
     */
    upsert<T extends MT5AccountUpsertArgs>(args: SelectSubset<T, MT5AccountUpsertArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountCountArgs} args - Arguments to filter MT5Accounts to count.
     * @example
     * // Count the number of MT5Accounts
     * const count = await prisma.mT5Account.count({
     *   where: {
     *     // ... the filter for the MT5Accounts we want to count
     *   }
     * })
    **/
    count<T extends MT5AccountCountArgs>(
      args?: Subset<T, MT5AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MT5AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MT5AccountAggregateArgs>(args: Subset<T, MT5AccountAggregateArgs>): Prisma.PrismaPromise<GetMT5AccountAggregateType<T>>

    /**
     * Group by MT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MT5AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MT5AccountGroupByArgs['orderBy'] }
        : { orderBy?: MT5AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MT5AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMT5AccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MT5Account model
   */
  readonly fields: MT5AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MT5Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MT5AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DefaultMT5Account<T extends MT5Account$DefaultMT5AccountArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$DefaultMT5AccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deposits<T extends MT5Account$depositsArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$depositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends MT5Account$userArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mt5Transactions<T extends MT5Account$mt5TransactionsArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$mt5TransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    withdrawals<T extends MT5Account$withdrawalsArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$withdrawalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MT5Account model
   */
  interface MT5AccountFieldRefs {
    readonly id: FieldRef<"MT5Account", 'String'>
    readonly accountId: FieldRef<"MT5Account", 'String'>
    readonly userId: FieldRef<"MT5Account", 'String'>
    readonly accountType: FieldRef<"MT5Account", 'String'>
    readonly createdAt: FieldRef<"MT5Account", 'DateTime'>
    readonly updatedAt: FieldRef<"MT5Account", 'DateTime'>
    readonly password: FieldRef<"MT5Account", 'String'>
    readonly leverage: FieldRef<"MT5Account", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MT5Account findUnique
   */
  export type MT5AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account findUniqueOrThrow
   */
  export type MT5AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account findFirst
   */
  export type MT5AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Accounts.
     */
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account findFirstOrThrow
   */
  export type MT5AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Accounts.
     */
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account findMany
   */
  export type MT5AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Accounts to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account create
   */
  export type MT5AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a MT5Account.
     */
    data: XOR<MT5AccountCreateInput, MT5AccountUncheckedCreateInput>
  }

  /**
   * MT5Account createMany
   */
  export type MT5AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MT5Accounts.
     */
    data: MT5AccountCreateManyInput | MT5AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MT5Account createManyAndReturn
   */
  export type MT5AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * The data used to create many MT5Accounts.
     */
    data: MT5AccountCreateManyInput | MT5AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Account update
   */
  export type MT5AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a MT5Account.
     */
    data: XOR<MT5AccountUpdateInput, MT5AccountUncheckedUpdateInput>
    /**
     * Choose, which MT5Account to update.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account updateMany
   */
  export type MT5AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MT5Accounts.
     */
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which MT5Accounts to update
     */
    where?: MT5AccountWhereInput
    /**
     * Limit how many MT5Accounts to update.
     */
    limit?: number
  }

  /**
   * MT5Account updateManyAndReturn
   */
  export type MT5AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * The data used to update MT5Accounts.
     */
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which MT5Accounts to update
     */
    where?: MT5AccountWhereInput
    /**
     * Limit how many MT5Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Account upsert
   */
  export type MT5AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the MT5Account to update in case it exists.
     */
    where: MT5AccountWhereUniqueInput
    /**
     * In case the MT5Account found by the `where` argument doesn't exist, create a new MT5Account with this data.
     */
    create: XOR<MT5AccountCreateInput, MT5AccountUncheckedCreateInput>
    /**
     * In case the MT5Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MT5AccountUpdateInput, MT5AccountUncheckedUpdateInput>
  }

  /**
   * MT5Account delete
   */
  export type MT5AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter which MT5Account to delete.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account deleteMany
   */
  export type MT5AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Accounts to delete
     */
    where?: MT5AccountWhereInput
    /**
     * Limit how many MT5Accounts to delete.
     */
    limit?: number
  }

  /**
   * MT5Account.DefaultMT5Account
   */
  export type MT5Account$DefaultMT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    where?: DefaultMT5AccountWhereInput
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    cursor?: DefaultMT5AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account.deposits
   */
  export type MT5Account$depositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    cursor?: DepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * MT5Account.user
   */
  export type MT5Account$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MT5Account.mt5Transactions
   */
  export type MT5Account$mt5TransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    where?: MT5TransactionWhereInput
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    cursor?: MT5TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Account.withdrawals
   */
  export type MT5Account$withdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    cursor?: WithdrawalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * MT5Account without action
   */
  export type MT5AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
  }


  /**
   * Model MT5Transaction
   */

  export type AggregateMT5Transaction = {
    _count: MT5TransactionCountAggregateOutputType | null
    _avg: MT5TransactionAvgAggregateOutputType | null
    _sum: MT5TransactionSumAggregateOutputType | null
    _min: MT5TransactionMinAggregateOutputType | null
    _max: MT5TransactionMaxAggregateOutputType | null
  }

  export type MT5TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type MT5TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type MT5TransactionMinAggregateOutputType = {
    id: string | null
    type: string | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    comment: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    currency: string | null
    depositId: string | null
    withdrawalId: string | null
    userId: string | null
    processedBy: string | null
    processedAt: Date | null
    updatedAt: Date | null
  }

  export type MT5TransactionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    comment: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    currency: string | null
    depositId: string | null
    withdrawalId: string | null
    userId: string | null
    processedBy: string | null
    processedAt: Date | null
    updatedAt: Date | null
  }

  export type MT5TransactionCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    status: number
    paymentMethod: number
    transactionId: number
    comment: number
    mt5AccountId: number
    createdAt: number
    currency: number
    depositId: number
    withdrawalId: number
    userId: number
    processedBy: number
    processedAt: number
    updatedAt: number
    _all: number
  }


  export type MT5TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type MT5TransactionSumAggregateInputType = {
    amount?: true
  }

  export type MT5TransactionMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    comment?: true
    mt5AccountId?: true
    createdAt?: true
    currency?: true
    depositId?: true
    withdrawalId?: true
    userId?: true
    processedBy?: true
    processedAt?: true
    updatedAt?: true
  }

  export type MT5TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    comment?: true
    mt5AccountId?: true
    createdAt?: true
    currency?: true
    depositId?: true
    withdrawalId?: true
    userId?: true
    processedBy?: true
    processedAt?: true
    updatedAt?: true
  }

  export type MT5TransactionCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    comment?: true
    mt5AccountId?: true
    createdAt?: true
    currency?: true
    depositId?: true
    withdrawalId?: true
    userId?: true
    processedBy?: true
    processedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MT5TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Transaction to aggregate.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MT5Transactions
    **/
    _count?: true | MT5TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MT5TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MT5TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MT5TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MT5TransactionMaxAggregateInputType
  }

  export type GetMT5TransactionAggregateType<T extends MT5TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMT5Transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMT5Transaction[P]>
      : GetScalarType<T[P], AggregateMT5Transaction[P]>
  }




  export type MT5TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5TransactionWhereInput
    orderBy?: MT5TransactionOrderByWithAggregationInput | MT5TransactionOrderByWithAggregationInput[]
    by: MT5TransactionScalarFieldEnum[] | MT5TransactionScalarFieldEnum
    having?: MT5TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MT5TransactionCountAggregateInputType | true
    _avg?: MT5TransactionAvgAggregateInputType
    _sum?: MT5TransactionSumAggregateInputType
    _min?: MT5TransactionMinAggregateInputType
    _max?: MT5TransactionMaxAggregateInputType
  }

  export type MT5TransactionGroupByOutputType = {
    id: string
    type: string
    amount: number
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    comment: string | null
    mt5AccountId: string
    createdAt: Date | null
    currency: string | null
    depositId: string | null
    withdrawalId: string | null
    userId: string | null
    processedBy: string | null
    processedAt: Date | null
    updatedAt: Date | null
    _count: MT5TransactionCountAggregateOutputType | null
    _avg: MT5TransactionAvgAggregateOutputType | null
    _sum: MT5TransactionSumAggregateOutputType | null
    _min: MT5TransactionMinAggregateOutputType | null
    _max: MT5TransactionMaxAggregateOutputType | null
  }

  type GetMT5TransactionGroupByPayload<T extends MT5TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MT5TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MT5TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MT5TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], MT5TransactionGroupByOutputType[P]>
        }
      >
    >


  export type MT5TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Transaction"]>

  export type MT5TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Transaction"]>

  export type MT5TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Transaction"]>

  export type MT5TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
  }

  export type MT5TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "status" | "paymentMethod" | "transactionId" | "comment" | "mt5AccountId" | "createdAt" | "currency" | "depositId" | "withdrawalId" | "userId" | "processedBy" | "processedAt" | "updatedAt", ExtArgs["result"]["mT5Transaction"]>
  export type MT5TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }
  export type MT5TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }
  export type MT5TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }

  export type $MT5TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MT5Transaction"
    objects: {
      mt5Account: Prisma.$MT5AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      amount: number
      status: string | null
      paymentMethod: string | null
      transactionId: string | null
      comment: string | null
      mt5AccountId: string
      createdAt: Date | null
      currency: string | null
      depositId: string | null
      withdrawalId: string | null
      userId: string | null
      processedBy: string | null
      processedAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["mT5Transaction"]>
    composites: {}
  }

  type MT5TransactionGetPayload<S extends boolean | null | undefined | MT5TransactionDefaultArgs> = $Result.GetResult<Prisma.$MT5TransactionPayload, S>

  type MT5TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MT5TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MT5TransactionCountAggregateInputType | true
    }

  export interface MT5TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MT5Transaction'], meta: { name: 'MT5Transaction' } }
    /**
     * Find zero or one MT5Transaction that matches the filter.
     * @param {MT5TransactionFindUniqueArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MT5TransactionFindUniqueArgs>(args: SelectSubset<T, MT5TransactionFindUniqueArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MT5Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MT5TransactionFindUniqueOrThrowArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MT5TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, MT5TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionFindFirstArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MT5TransactionFindFirstArgs>(args?: SelectSubset<T, MT5TransactionFindFirstArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionFindFirstOrThrowArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MT5TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, MT5TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MT5Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MT5Transactions
     * const mT5Transactions = await prisma.mT5Transaction.findMany()
     * 
     * // Get first 10 MT5Transactions
     * const mT5Transactions = await prisma.mT5Transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mT5TransactionWithIdOnly = await prisma.mT5Transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MT5TransactionFindManyArgs>(args?: SelectSubset<T, MT5TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MT5Transaction.
     * @param {MT5TransactionCreateArgs} args - Arguments to create a MT5Transaction.
     * @example
     * // Create one MT5Transaction
     * const MT5Transaction = await prisma.mT5Transaction.create({
     *   data: {
     *     // ... data to create a MT5Transaction
     *   }
     * })
     * 
     */
    create<T extends MT5TransactionCreateArgs>(args: SelectSubset<T, MT5TransactionCreateArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MT5Transactions.
     * @param {MT5TransactionCreateManyArgs} args - Arguments to create many MT5Transactions.
     * @example
     * // Create many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MT5TransactionCreateManyArgs>(args?: SelectSubset<T, MT5TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MT5Transactions and returns the data saved in the database.
     * @param {MT5TransactionCreateManyAndReturnArgs} args - Arguments to create many MT5Transactions.
     * @example
     * // Create many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MT5Transactions and only return the `id`
     * const mT5TransactionWithIdOnly = await prisma.mT5Transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MT5TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, MT5TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MT5Transaction.
     * @param {MT5TransactionDeleteArgs} args - Arguments to delete one MT5Transaction.
     * @example
     * // Delete one MT5Transaction
     * const MT5Transaction = await prisma.mT5Transaction.delete({
     *   where: {
     *     // ... filter to delete one MT5Transaction
     *   }
     * })
     * 
     */
    delete<T extends MT5TransactionDeleteArgs>(args: SelectSubset<T, MT5TransactionDeleteArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MT5Transaction.
     * @param {MT5TransactionUpdateArgs} args - Arguments to update one MT5Transaction.
     * @example
     * // Update one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MT5TransactionUpdateArgs>(args: SelectSubset<T, MT5TransactionUpdateArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MT5Transactions.
     * @param {MT5TransactionDeleteManyArgs} args - Arguments to filter MT5Transactions to delete.
     * @example
     * // Delete a few MT5Transactions
     * const { count } = await prisma.mT5Transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MT5TransactionDeleteManyArgs>(args?: SelectSubset<T, MT5TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MT5TransactionUpdateManyArgs>(args: SelectSubset<T, MT5TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Transactions and returns the data updated in the database.
     * @param {MT5TransactionUpdateManyAndReturnArgs} args - Arguments to update many MT5Transactions.
     * @example
     * // Update many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MT5Transactions and only return the `id`
     * const mT5TransactionWithIdOnly = await prisma.mT5Transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MT5TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, MT5TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MT5Transaction.
     * @param {MT5TransactionUpsertArgs} args - Arguments to update or create a MT5Transaction.
     * @example
     * // Update or create a MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.upsert({
     *   create: {
     *     // ... data to create a MT5Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MT5Transaction we want to update
     *   }
     * })
     */
    upsert<T extends MT5TransactionUpsertArgs>(args: SelectSubset<T, MT5TransactionUpsertArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MT5Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionCountArgs} args - Arguments to filter MT5Transactions to count.
     * @example
     * // Count the number of MT5Transactions
     * const count = await prisma.mT5Transaction.count({
     *   where: {
     *     // ... the filter for the MT5Transactions we want to count
     *   }
     * })
    **/
    count<T extends MT5TransactionCountArgs>(
      args?: Subset<T, MT5TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MT5TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MT5Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MT5TransactionAggregateArgs>(args: Subset<T, MT5TransactionAggregateArgs>): Prisma.PrismaPromise<GetMT5TransactionAggregateType<T>>

    /**
     * Group by MT5Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MT5TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MT5TransactionGroupByArgs['orderBy'] }
        : { orderBy?: MT5TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MT5TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMT5TransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MT5Transaction model
   */
  readonly fields: MT5TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MT5Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MT5TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mt5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MT5Transaction model
   */
  interface MT5TransactionFieldRefs {
    readonly id: FieldRef<"MT5Transaction", 'String'>
    readonly type: FieldRef<"MT5Transaction", 'String'>
    readonly amount: FieldRef<"MT5Transaction", 'Float'>
    readonly status: FieldRef<"MT5Transaction", 'String'>
    readonly paymentMethod: FieldRef<"MT5Transaction", 'String'>
    readonly transactionId: FieldRef<"MT5Transaction", 'String'>
    readonly comment: FieldRef<"MT5Transaction", 'String'>
    readonly mt5AccountId: FieldRef<"MT5Transaction", 'String'>
    readonly createdAt: FieldRef<"MT5Transaction", 'DateTime'>
    readonly currency: FieldRef<"MT5Transaction", 'String'>
    readonly depositId: FieldRef<"MT5Transaction", 'String'>
    readonly withdrawalId: FieldRef<"MT5Transaction", 'String'>
    readonly userId: FieldRef<"MT5Transaction", 'String'>
    readonly processedBy: FieldRef<"MT5Transaction", 'String'>
    readonly processedAt: FieldRef<"MT5Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"MT5Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MT5Transaction findUnique
   */
  export type MT5TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction findUniqueOrThrow
   */
  export type MT5TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction findFirst
   */
  export type MT5TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Transactions.
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Transactions.
     */
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Transaction findFirstOrThrow
   */
  export type MT5TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Transactions.
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Transactions.
     */
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Transaction findMany
   */
  export type MT5TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transactions to fetch.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MT5Transactions.
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Transaction create
   */
  export type MT5TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a MT5Transaction.
     */
    data: XOR<MT5TransactionCreateInput, MT5TransactionUncheckedCreateInput>
  }

  /**
   * MT5Transaction createMany
   */
  export type MT5TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MT5Transactions.
     */
    data: MT5TransactionCreateManyInput | MT5TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MT5Transaction createManyAndReturn
   */
  export type MT5TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many MT5Transactions.
     */
    data: MT5TransactionCreateManyInput | MT5TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Transaction update
   */
  export type MT5TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a MT5Transaction.
     */
    data: XOR<MT5TransactionUpdateInput, MT5TransactionUncheckedUpdateInput>
    /**
     * Choose, which MT5Transaction to update.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction updateMany
   */
  export type MT5TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MT5Transactions.
     */
    data: XOR<MT5TransactionUpdateManyMutationInput, MT5TransactionUncheckedUpdateManyInput>
    /**
     * Filter which MT5Transactions to update
     */
    where?: MT5TransactionWhereInput
    /**
     * Limit how many MT5Transactions to update.
     */
    limit?: number
  }

  /**
   * MT5Transaction updateManyAndReturn
   */
  export type MT5TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * The data used to update MT5Transactions.
     */
    data: XOR<MT5TransactionUpdateManyMutationInput, MT5TransactionUncheckedUpdateManyInput>
    /**
     * Filter which MT5Transactions to update
     */
    where?: MT5TransactionWhereInput
    /**
     * Limit how many MT5Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Transaction upsert
   */
  export type MT5TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the MT5Transaction to update in case it exists.
     */
    where: MT5TransactionWhereUniqueInput
    /**
     * In case the MT5Transaction found by the `where` argument doesn't exist, create a new MT5Transaction with this data.
     */
    create: XOR<MT5TransactionCreateInput, MT5TransactionUncheckedCreateInput>
    /**
     * In case the MT5Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MT5TransactionUpdateInput, MT5TransactionUncheckedUpdateInput>
  }

  /**
   * MT5Transaction delete
   */
  export type MT5TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter which MT5Transaction to delete.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction deleteMany
   */
  export type MT5TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Transactions to delete
     */
    where?: MT5TransactionWhereInput
    /**
     * Limit how many MT5Transactions to delete.
     */
    limit?: number
  }

  /**
   * MT5Transaction without action
   */
  export type MT5TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    balance: number | null
  }

  export type AccountSumAggregateOutputType = {
    balance: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountType: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    balance?: true
  }

  export type AccountSumAggregateInputType = {
    balance?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountType: string
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountType" | "balance" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountType: string
      balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountType: FieldRef<"Account", 'String'>
    readonly balance: FieldRef<"Account", 'Float'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    amount: number | null
    status: string | null
    currency: string | null
    paymentMethod: string | null
    transactionId: string | null
    description: string | null
    metadata: string | null
    depositId: string | null
    withdrawalId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    amount: number | null
    status: string | null
    currency: string | null
    paymentMethod: string | null
    transactionId: string | null
    description: string | null
    metadata: string | null
    depositId: string | null
    withdrawalId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amount: number
    status: number
    currency: number
    paymentMethod: number
    transactionId: number
    description: number
    metadata: number
    depositId: number
    withdrawalId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    description?: true
    metadata?: true
    depositId?: true
    withdrawalId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    description?: true
    metadata?: true
    depositId?: true
    withdrawalId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    description?: true
    metadata?: true
    depositId?: true
    withdrawalId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    type: string
    amount: number
    status: string
    currency: string
    paymentMethod: string | null
    transactionId: string | null
    description: string | null
    metadata: string | null
    depositId: string | null
    withdrawalId: string | null
    updatedAt: Date
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "amount" | "status" | "currency" | "paymentMethod" | "transactionId" | "description" | "metadata" | "depositId" | "withdrawalId" | "updatedAt" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit?: boolean | Transaction$depositArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    withdrawal?: boolean | Transaction$withdrawalArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      deposit: Prisma.$DepositPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      withdrawal: Prisma.$WithdrawalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      amount: number
      status: string
      currency: string
      paymentMethod: string | null
      transactionId: string | null
      description: string | null
      metadata: string | null
      depositId: string | null
      withdrawalId: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deposit<T extends Transaction$depositArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$depositArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    withdrawal<T extends Transaction$withdrawalArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$withdrawalArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'String'>
    readonly transactionId: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'String'>
    readonly depositId: FieldRef<"Transaction", 'String'>
    readonly withdrawalId: FieldRef<"Transaction", 'String'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.deposit
   */
  export type Transaction$depositArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
  }

  /**
   * Transaction.withdrawal
   */
  export type Transaction$withdrawalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    where?: WithdrawalWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Deposit
   */

  export type AggregateDeposit = {
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  export type DepositAvgAggregateOutputType = {
    amount: number | null
  }

  export type DepositSumAggregateOutputType = {
    amount: number | null
  }

  export type DepositMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    amount: number | null
    currency: string | null
    method: string | null
    paymentMethod: string | null
    transactionHash: string | null
    proofFileUrl: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    depositAddress: string | null
    externalTransactionId: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    amount: number | null
    currency: string | null
    method: string | null
    paymentMethod: string | null
    transactionHash: string | null
    proofFileUrl: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    depositAddress: string | null
    externalTransactionId: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositCountAggregateOutputType = {
    id: number
    userId: number
    mt5AccountId: number
    amount: number
    currency: number
    method: number
    paymentMethod: number
    transactionHash: number
    proofFileUrl: number
    bankDetails: number
    cryptoAddress: number
    depositAddress: number
    externalTransactionId: number
    status: number
    rejectionReason: number
    approvedBy: number
    approvedAt: number
    rejectedAt: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepositAvgAggregateInputType = {
    amount?: true
  }

  export type DepositSumAggregateInputType = {
    amount?: true
  }

  export type DepositMinAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    currency?: true
    method?: true
    paymentMethod?: true
    transactionHash?: true
    proofFileUrl?: true
    bankDetails?: true
    cryptoAddress?: true
    depositAddress?: true
    externalTransactionId?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositMaxAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    currency?: true
    method?: true
    paymentMethod?: true
    transactionHash?: true
    proofFileUrl?: true
    bankDetails?: true
    cryptoAddress?: true
    depositAddress?: true
    externalTransactionId?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositCountAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    currency?: true
    method?: true
    paymentMethod?: true
    transactionHash?: true
    proofFileUrl?: true
    bankDetails?: true
    cryptoAddress?: true
    depositAddress?: true
    externalTransactionId?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepositAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposit to aggregate.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deposits
    **/
    _count?: true | DepositCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositMaxAggregateInputType
  }

  export type GetDepositAggregateType<T extends DepositAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposit[P]>
      : GetScalarType<T[P], AggregateDeposit[P]>
  }




  export type DepositGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithAggregationInput | DepositOrderByWithAggregationInput[]
    by: DepositScalarFieldEnum[] | DepositScalarFieldEnum
    having?: DepositScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositCountAggregateInputType | true
    _avg?: DepositAvgAggregateInputType
    _sum?: DepositSumAggregateInputType
    _min?: DepositMinAggregateInputType
    _max?: DepositMaxAggregateInputType
  }

  export type DepositGroupByOutputType = {
    id: string
    userId: string
    mt5AccountId: string
    amount: number
    currency: string
    method: string
    paymentMethod: string | null
    transactionHash: string | null
    proofFileUrl: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    depositAddress: string | null
    externalTransactionId: string | null
    status: string
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  type GetDepositGroupByPayload<T extends DepositGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositGroupByOutputType[P]>
            : GetScalarType<T[P], DepositGroupByOutputType[P]>
        }
      >
    >


  export type DepositSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | Deposit$transactionsArgs<ExtArgs>
    _count?: boolean | DepositCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectScalar = {
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepositOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mt5AccountId" | "amount" | "currency" | "method" | "paymentMethod" | "transactionHash" | "proofFileUrl" | "bankDetails" | "cryptoAddress" | "depositAddress" | "externalTransactionId" | "status" | "rejectionReason" | "approvedBy" | "approvedAt" | "rejectedAt" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["deposit"]>
  export type DepositInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | Deposit$transactionsArgs<ExtArgs>
    _count?: boolean | DepositCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepositIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepositIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepositPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deposit"
    objects: {
      mt5Account: Prisma.$MT5AccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mt5AccountId: string
      amount: number
      currency: string
      method: string
      paymentMethod: string | null
      transactionHash: string | null
      proofFileUrl: string | null
      bankDetails: string | null
      cryptoAddress: string | null
      depositAddress: string | null
      externalTransactionId: string | null
      status: string
      rejectionReason: string | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectedAt: Date | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deposit"]>
    composites: {}
  }

  type DepositGetPayload<S extends boolean | null | undefined | DepositDefaultArgs> = $Result.GetResult<Prisma.$DepositPayload, S>

  type DepositCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepositFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositCountAggregateInputType | true
    }

  export interface DepositDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deposit'], meta: { name: 'Deposit' } }
    /**
     * Find zero or one Deposit that matches the filter.
     * @param {DepositFindUniqueArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepositFindUniqueArgs>(args: SelectSubset<T, DepositFindUniqueArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deposit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepositFindUniqueOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepositFindUniqueOrThrowArgs>(args: SelectSubset<T, DepositFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepositFindFirstArgs>(args?: SelectSubset<T, DepositFindFirstArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepositFindFirstOrThrowArgs>(args?: SelectSubset<T, DepositFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deposits
     * const deposits = await prisma.deposit.findMany()
     * 
     * // Get first 10 Deposits
     * const deposits = await prisma.deposit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositWithIdOnly = await prisma.deposit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepositFindManyArgs>(args?: SelectSubset<T, DepositFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deposit.
     * @param {DepositCreateArgs} args - Arguments to create a Deposit.
     * @example
     * // Create one Deposit
     * const Deposit = await prisma.deposit.create({
     *   data: {
     *     // ... data to create a Deposit
     *   }
     * })
     * 
     */
    create<T extends DepositCreateArgs>(args: SelectSubset<T, DepositCreateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deposits.
     * @param {DepositCreateManyArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepositCreateManyArgs>(args?: SelectSubset<T, DepositCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deposits and returns the data saved in the database.
     * @param {DepositCreateManyAndReturnArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deposits and only return the `id`
     * const depositWithIdOnly = await prisma.deposit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepositCreateManyAndReturnArgs>(args?: SelectSubset<T, DepositCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deposit.
     * @param {DepositDeleteArgs} args - Arguments to delete one Deposit.
     * @example
     * // Delete one Deposit
     * const Deposit = await prisma.deposit.delete({
     *   where: {
     *     // ... filter to delete one Deposit
     *   }
     * })
     * 
     */
    delete<T extends DepositDeleteArgs>(args: SelectSubset<T, DepositDeleteArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deposit.
     * @param {DepositUpdateArgs} args - Arguments to update one Deposit.
     * @example
     * // Update one Deposit
     * const deposit = await prisma.deposit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepositUpdateArgs>(args: SelectSubset<T, DepositUpdateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deposits.
     * @param {DepositDeleteManyArgs} args - Arguments to filter Deposits to delete.
     * @example
     * // Delete a few Deposits
     * const { count } = await prisma.deposit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepositDeleteManyArgs>(args?: SelectSubset<T, DepositDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deposits
     * const deposit = await prisma.deposit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepositUpdateManyArgs>(args: SelectSubset<T, DepositUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits and returns the data updated in the database.
     * @param {DepositUpdateManyAndReturnArgs} args - Arguments to update many Deposits.
     * @example
     * // Update many Deposits
     * const deposit = await prisma.deposit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deposits and only return the `id`
     * const depositWithIdOnly = await prisma.deposit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepositUpdateManyAndReturnArgs>(args: SelectSubset<T, DepositUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deposit.
     * @param {DepositUpsertArgs} args - Arguments to update or create a Deposit.
     * @example
     * // Update or create a Deposit
     * const deposit = await prisma.deposit.upsert({
     *   create: {
     *     // ... data to create a Deposit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposit we want to update
     *   }
     * })
     */
    upsert<T extends DepositUpsertArgs>(args: SelectSubset<T, DepositUpsertArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositCountArgs} args - Arguments to filter Deposits to count.
     * @example
     * // Count the number of Deposits
     * const count = await prisma.deposit.count({
     *   where: {
     *     // ... the filter for the Deposits we want to count
     *   }
     * })
    **/
    count<T extends DepositCountArgs>(
      args?: Subset<T, DepositCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositAggregateArgs>(args: Subset<T, DepositAggregateArgs>): Prisma.PrismaPromise<GetDepositAggregateType<T>>

    /**
     * Group by Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositGroupByArgs['orderBy'] }
        : { orderBy?: DepositGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deposit model
   */
  readonly fields: DepositFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deposit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mt5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Deposit$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Deposit$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deposit model
   */
  interface DepositFieldRefs {
    readonly id: FieldRef<"Deposit", 'String'>
    readonly userId: FieldRef<"Deposit", 'String'>
    readonly mt5AccountId: FieldRef<"Deposit", 'String'>
    readonly amount: FieldRef<"Deposit", 'Float'>
    readonly currency: FieldRef<"Deposit", 'String'>
    readonly method: FieldRef<"Deposit", 'String'>
    readonly paymentMethod: FieldRef<"Deposit", 'String'>
    readonly transactionHash: FieldRef<"Deposit", 'String'>
    readonly proofFileUrl: FieldRef<"Deposit", 'String'>
    readonly bankDetails: FieldRef<"Deposit", 'String'>
    readonly cryptoAddress: FieldRef<"Deposit", 'String'>
    readonly depositAddress: FieldRef<"Deposit", 'String'>
    readonly externalTransactionId: FieldRef<"Deposit", 'String'>
    readonly status: FieldRef<"Deposit", 'String'>
    readonly rejectionReason: FieldRef<"Deposit", 'String'>
    readonly approvedBy: FieldRef<"Deposit", 'String'>
    readonly approvedAt: FieldRef<"Deposit", 'DateTime'>
    readonly rejectedAt: FieldRef<"Deposit", 'DateTime'>
    readonly processedAt: FieldRef<"Deposit", 'DateTime'>
    readonly createdAt: FieldRef<"Deposit", 'DateTime'>
    readonly updatedAt: FieldRef<"Deposit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deposit findUnique
   */
  export type DepositFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findUniqueOrThrow
   */
  export type DepositFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findFirst
   */
  export type DepositFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findFirstOrThrow
   */
  export type DepositFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findMany
   */
  export type DepositFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit create
   */
  export type DepositCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to create a Deposit.
     */
    data: XOR<DepositCreateInput, DepositUncheckedCreateInput>
  }

  /**
   * Deposit createMany
   */
  export type DepositCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deposit createManyAndReturn
   */
  export type DepositCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposit update
   */
  export type DepositUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to update a Deposit.
     */
    data: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
    /**
     * Choose, which Deposit to update.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit updateMany
   */
  export type DepositUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
  }

  /**
   * Deposit updateManyAndReturn
   */
  export type DepositUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposit upsert
   */
  export type DepositUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The filter to search for the Deposit to update in case it exists.
     */
    where: DepositWhereUniqueInput
    /**
     * In case the Deposit found by the `where` argument doesn't exist, create a new Deposit with this data.
     */
    create: XOR<DepositCreateInput, DepositUncheckedCreateInput>
    /**
     * In case the Deposit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
  }

  /**
   * Deposit delete
   */
  export type DepositDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter which Deposit to delete.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit deleteMany
   */
  export type DepositDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposits to delete
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to delete.
     */
    limit?: number
  }

  /**
   * Deposit.transactions
   */
  export type Deposit$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Deposit without action
   */
  export type DepositDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
  }


  /**
   * Model Withdrawal
   */

  export type AggregateWithdrawal = {
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  export type WithdrawalAvgAggregateOutputType = {
    amount: number | null
  }

  export type WithdrawalSumAggregateOutputType = {
    amount: number | null
  }

  export type WithdrawalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    amount: number | null
    method: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    externalTransactionId: string | null
    paymentMethod: string | null
    processedAt: Date | null
    walletAddress: string | null
  }

  export type WithdrawalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    amount: number | null
    method: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    externalTransactionId: string | null
    paymentMethod: string | null
    processedAt: Date | null
    walletAddress: string | null
  }

  export type WithdrawalCountAggregateOutputType = {
    id: number
    userId: number
    mt5AccountId: number
    amount: number
    method: number
    bankDetails: number
    cryptoAddress: number
    status: number
    rejectionReason: number
    approvedBy: number
    approvedAt: number
    rejectedAt: number
    createdAt: number
    updatedAt: number
    currency: number
    externalTransactionId: number
    paymentMethod: number
    processedAt: number
    walletAddress: number
    _all: number
  }


  export type WithdrawalAvgAggregateInputType = {
    amount?: true
  }

  export type WithdrawalSumAggregateInputType = {
    amount?: true
  }

  export type WithdrawalMinAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    method?: true
    bankDetails?: true
    cryptoAddress?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    externalTransactionId?: true
    paymentMethod?: true
    processedAt?: true
    walletAddress?: true
  }

  export type WithdrawalMaxAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    method?: true
    bankDetails?: true
    cryptoAddress?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    externalTransactionId?: true
    paymentMethod?: true
    processedAt?: true
    walletAddress?: true
  }

  export type WithdrawalCountAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    method?: true
    bankDetails?: true
    cryptoAddress?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    externalTransactionId?: true
    paymentMethod?: true
    processedAt?: true
    walletAddress?: true
    _all?: true
  }

  export type WithdrawalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawal to aggregate.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Withdrawals
    **/
    _count?: true | WithdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalMaxAggregateInputType
  }

  export type GetWithdrawalAggregateType<T extends WithdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawal[P]>
      : GetScalarType<T[P], AggregateWithdrawal[P]>
  }




  export type WithdrawalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithAggregationInput | WithdrawalOrderByWithAggregationInput[]
    by: WithdrawalScalarFieldEnum[] | WithdrawalScalarFieldEnum
    having?: WithdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalCountAggregateInputType | true
    _avg?: WithdrawalAvgAggregateInputType
    _sum?: WithdrawalSumAggregateInputType
    _min?: WithdrawalMinAggregateInputType
    _max?: WithdrawalMaxAggregateInputType
  }

  export type WithdrawalGroupByOutputType = {
    id: string
    userId: string
    mt5AccountId: string
    amount: number
    method: string
    bankDetails: string | null
    cryptoAddress: string | null
    status: string
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date
    updatedAt: Date
    currency: string
    externalTransactionId: string | null
    paymentMethod: string | null
    processedAt: Date | null
    walletAddress: string | null
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  type GetWithdrawalGroupByPayload<T extends WithdrawalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
    transactions?: boolean | Withdrawal$transactionsArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WithdrawalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectScalar = {
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
  }

  export type WithdrawalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mt5AccountId" | "amount" | "method" | "bankDetails" | "cryptoAddress" | "status" | "rejectionReason" | "approvedBy" | "approvedAt" | "rejectedAt" | "createdAt" | "updatedAt" | "currency" | "externalTransactionId" | "paymentMethod" | "processedAt" | "walletAddress", ExtArgs["result"]["withdrawal"]>
  export type WithdrawalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Withdrawal$transactionsArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WithdrawalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WithdrawalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WithdrawalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WithdrawalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Withdrawal"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      mt5Account: Prisma.$MT5AccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mt5AccountId: string
      amount: number
      method: string
      bankDetails: string | null
      cryptoAddress: string | null
      status: string
      rejectionReason: string | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectedAt: Date | null
      createdAt: Date
      updatedAt: Date
      currency: string
      externalTransactionId: string | null
      paymentMethod: string | null
      processedAt: Date | null
      walletAddress: string | null
    }, ExtArgs["result"]["withdrawal"]>
    composites: {}
  }

  type WithdrawalGetPayload<S extends boolean | null | undefined | WithdrawalDefaultArgs> = $Result.GetResult<Prisma.$WithdrawalPayload, S>

  type WithdrawalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WithdrawalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalCountAggregateInputType | true
    }

  export interface WithdrawalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Withdrawal'], meta: { name: 'Withdrawal' } }
    /**
     * Find zero or one Withdrawal that matches the filter.
     * @param {WithdrawalFindUniqueArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WithdrawalFindUniqueArgs>(args: SelectSubset<T, WithdrawalFindUniqueArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Withdrawal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WithdrawalFindUniqueOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WithdrawalFindUniqueOrThrowArgs>(args: SelectSubset<T, WithdrawalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WithdrawalFindFirstArgs>(args?: SelectSubset<T, WithdrawalFindFirstArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WithdrawalFindFirstOrThrowArgs>(args?: SelectSubset<T, WithdrawalFindFirstOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WithdrawalFindManyArgs>(args?: SelectSubset<T, WithdrawalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Withdrawal.
     * @param {WithdrawalCreateArgs} args - Arguments to create a Withdrawal.
     * @example
     * // Create one Withdrawal
     * const Withdrawal = await prisma.withdrawal.create({
     *   data: {
     *     // ... data to create a Withdrawal
     *   }
     * })
     * 
     */
    create<T extends WithdrawalCreateArgs>(args: SelectSubset<T, WithdrawalCreateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Withdrawals.
     * @param {WithdrawalCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WithdrawalCreateManyArgs>(args?: SelectSubset<T, WithdrawalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {WithdrawalCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WithdrawalCreateManyAndReturnArgs>(args?: SelectSubset<T, WithdrawalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Withdrawal.
     * @param {WithdrawalDeleteArgs} args - Arguments to delete one Withdrawal.
     * @example
     * // Delete one Withdrawal
     * const Withdrawal = await prisma.withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Withdrawal
     *   }
     * })
     * 
     */
    delete<T extends WithdrawalDeleteArgs>(args: SelectSubset<T, WithdrawalDeleteArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Withdrawal.
     * @param {WithdrawalUpdateArgs} args - Arguments to update one Withdrawal.
     * @example
     * // Update one Withdrawal
     * const withdrawal = await prisma.withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WithdrawalUpdateArgs>(args: SelectSubset<T, WithdrawalUpdateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Withdrawals.
     * @param {WithdrawalDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WithdrawalDeleteManyArgs>(args?: SelectSubset<T, WithdrawalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WithdrawalUpdateManyArgs>(args: SelectSubset<T, WithdrawalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals and returns the data updated in the database.
     * @param {WithdrawalUpdateManyAndReturnArgs} args - Arguments to update many Withdrawals.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WithdrawalUpdateManyAndReturnArgs>(args: SelectSubset<T, WithdrawalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Withdrawal.
     * @param {WithdrawalUpsertArgs} args - Arguments to update or create a Withdrawal.
     * @example
     * // Update or create a Withdrawal
     * const withdrawal = await prisma.withdrawal.upsert({
     *   create: {
     *     // ... data to create a Withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawal we want to update
     *   }
     * })
     */
    upsert<T extends WithdrawalUpsertArgs>(args: SelectSubset<T, WithdrawalUpsertArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawal.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends WithdrawalCountArgs>(
      args?: Subset<T, WithdrawalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAggregateArgs>(args: Subset<T, WithdrawalAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalAggregateType<T>>

    /**
     * Group by Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Withdrawal model
   */
  readonly fields: WithdrawalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WithdrawalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Withdrawal$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Withdrawal$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mt5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Withdrawal model
   */
  interface WithdrawalFieldRefs {
    readonly id: FieldRef<"Withdrawal", 'String'>
    readonly userId: FieldRef<"Withdrawal", 'String'>
    readonly mt5AccountId: FieldRef<"Withdrawal", 'String'>
    readonly amount: FieldRef<"Withdrawal", 'Float'>
    readonly method: FieldRef<"Withdrawal", 'String'>
    readonly bankDetails: FieldRef<"Withdrawal", 'String'>
    readonly cryptoAddress: FieldRef<"Withdrawal", 'String'>
    readonly status: FieldRef<"Withdrawal", 'String'>
    readonly rejectionReason: FieldRef<"Withdrawal", 'String'>
    readonly approvedBy: FieldRef<"Withdrawal", 'String'>
    readonly approvedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly rejectedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly createdAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly updatedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly currency: FieldRef<"Withdrawal", 'String'>
    readonly externalTransactionId: FieldRef<"Withdrawal", 'String'>
    readonly paymentMethod: FieldRef<"Withdrawal", 'String'>
    readonly processedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly walletAddress: FieldRef<"Withdrawal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Withdrawal findUnique
   */
  export type WithdrawalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findUniqueOrThrow
   */
  export type WithdrawalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findFirst
   */
  export type WithdrawalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findFirstOrThrow
   */
  export type WithdrawalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findMany
   */
  export type WithdrawalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal create
   */
  export type WithdrawalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The data needed to create a Withdrawal.
     */
    data: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
  }

  /**
   * Withdrawal createMany
   */
  export type WithdrawalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Withdrawal createManyAndReturn
   */
  export type WithdrawalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Withdrawal update
   */
  export type WithdrawalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The data needed to update a Withdrawal.
     */
    data: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
    /**
     * Choose, which Withdrawal to update.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal updateMany
   */
  export type WithdrawalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
  }

  /**
   * Withdrawal updateManyAndReturn
   */
  export type WithdrawalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Withdrawal upsert
   */
  export type WithdrawalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The filter to search for the Withdrawal to update in case it exists.
     */
    where: WithdrawalWhereUniqueInput
    /**
     * In case the Withdrawal found by the `where` argument doesn't exist, create a new Withdrawal with this data.
     */
    create: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
    /**
     * In case the Withdrawal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
  }

  /**
   * Withdrawal delete
   */
  export type WithdrawalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter which Withdrawal to delete.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal deleteMany
   */
  export type WithdrawalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawals to delete
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to delete.
     */
    limit?: number
  }

  /**
   * Withdrawal.transactions
   */
  export type Withdrawal$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Withdrawal without action
   */
  export type WithdrawalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    adminId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValues: string | null
    newValues: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    adminId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValues: string | null
    newValues: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    adminId: number
    action: number
    entity: number
    entityId: number
    ipAddress: number
    userAgent: number
    oldValues: number
    newValues: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    oldValues?: true
    newValues?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    oldValues?: true
    newValues?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    oldValues?: true
    newValues?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string | null
    adminId: string
    action: string
    entity: string
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValues: string | null
    newValues: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "adminId" | "action" | "entity" | "entityId" | "ipAddress" | "userAgent" | "oldValues" | "newValues" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      adminId: string
      action: string
      entity: string
      entityId: string | null
      ipAddress: string | null
      userAgent: string | null
      oldValues: string | null
      newValues: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly adminId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly entity: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly oldValues: FieldRef<"ActivityLog", 'String'>
    readonly newValues: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    category: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      category: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly category: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    permissions: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    permissions: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    permissions: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    permissions: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "permissions" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      permissions: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    currency: string | null
    network: string | null
    status: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    currency: string | null
    network: string | null
    status: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    userId: number
    address: number
    currency: number
    network: number
    status: number
    submittedAt: number
    approvedAt: number
    approvedBy: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodMinAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    currency?: true
    network?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    approvedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    currency?: true
    network?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    approvedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    currency?: true
    network?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    approvedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    userId: string
    address: string
    currency: string
    network: string
    status: string
    submittedAt: Date
    approvedAt: Date | null
    approvedBy: string | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "address" | "currency" | "network" | "status" | "submittedAt" | "approvedAt" | "approvedBy" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      address: string
      currency: string
      network: string
      status: string
      submittedAt: Date
      approvedAt: Date | null
      approvedBy: string | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly userId: FieldRef<"PaymentMethod", 'String'>
    readonly address: FieldRef<"PaymentMethod", 'String'>
    readonly currency: FieldRef<"PaymentMethod", 'String'>
    readonly network: FieldRef<"PaymentMethod", 'String'>
    readonly status: FieldRef<"PaymentMethod", 'String'>
    readonly submittedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly approvedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly approvedBy: FieldRef<"PaymentMethod", 'String'>
    readonly rejectionReason: FieldRef<"PaymentMethod", 'String'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    assignedAt: Date
    assignedBy: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId" | "assignedAt" | "assignedBy", ExtArgs["result"]["userRole"]>

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      assignedAt: Date
      assignedBy: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
    readonly assignedBy: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
  }


  /**
   * Model DefaultMT5Account
   */

  export type AggregateDefaultMT5Account = {
    _count: DefaultMT5AccountCountAggregateOutputType | null
    _min: DefaultMT5AccountMinAggregateOutputType | null
    _max: DefaultMT5AccountMaxAggregateOutputType | null
  }

  export type DefaultMT5AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultMT5AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultMT5AccountCountAggregateOutputType = {
    id: number
    userId: number
    mt5AccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DefaultMT5AccountMinAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultMT5AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultMT5AccountCountAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DefaultMT5AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultMT5Account to aggregate.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefaultMT5Accounts
    **/
    _count?: true | DefaultMT5AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefaultMT5AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefaultMT5AccountMaxAggregateInputType
  }

  export type GetDefaultMT5AccountAggregateType<T extends DefaultMT5AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateDefaultMT5Account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefaultMT5Account[P]>
      : GetScalarType<T[P], AggregateDefaultMT5Account[P]>
  }




  export type DefaultMT5AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultMT5AccountWhereInput
    orderBy?: DefaultMT5AccountOrderByWithAggregationInput | DefaultMT5AccountOrderByWithAggregationInput[]
    by: DefaultMT5AccountScalarFieldEnum[] | DefaultMT5AccountScalarFieldEnum
    having?: DefaultMT5AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefaultMT5AccountCountAggregateInputType | true
    _min?: DefaultMT5AccountMinAggregateInputType
    _max?: DefaultMT5AccountMaxAggregateInputType
  }

  export type DefaultMT5AccountGroupByOutputType = {
    id: string
    userId: string
    mt5AccountId: string
    createdAt: Date
    updatedAt: Date
    _count: DefaultMT5AccountCountAggregateOutputType | null
    _min: DefaultMT5AccountMinAggregateOutputType | null
    _max: DefaultMT5AccountMaxAggregateOutputType | null
  }

  type GetDefaultMT5AccountGroupByPayload<T extends DefaultMT5AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefaultMT5AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefaultMT5AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefaultMT5AccountGroupByOutputType[P]>
            : GetScalarType<T[P], DefaultMT5AccountGroupByOutputType[P]>
        }
      >
    >


  export type DefaultMT5AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultMT5Account"]>

  export type DefaultMT5AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultMT5Account"]>

  export type DefaultMT5AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultMT5Account"]>

  export type DefaultMT5AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DefaultMT5AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mt5AccountId" | "createdAt" | "updatedAt", ExtArgs["result"]["defaultMT5Account"]>
  export type DefaultMT5AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DefaultMT5AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DefaultMT5AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DefaultMT5AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefaultMT5Account"
    objects: {
      MT5Account: Prisma.$MT5AccountPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mt5AccountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["defaultMT5Account"]>
    composites: {}
  }

  type DefaultMT5AccountGetPayload<S extends boolean | null | undefined | DefaultMT5AccountDefaultArgs> = $Result.GetResult<Prisma.$DefaultMT5AccountPayload, S>

  type DefaultMT5AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DefaultMT5AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DefaultMT5AccountCountAggregateInputType | true
    }

  export interface DefaultMT5AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefaultMT5Account'], meta: { name: 'DefaultMT5Account' } }
    /**
     * Find zero or one DefaultMT5Account that matches the filter.
     * @param {DefaultMT5AccountFindUniqueArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefaultMT5AccountFindUniqueArgs>(args: SelectSubset<T, DefaultMT5AccountFindUniqueArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DefaultMT5Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DefaultMT5AccountFindUniqueOrThrowArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefaultMT5AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, DefaultMT5AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultMT5Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountFindFirstArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefaultMT5AccountFindFirstArgs>(args?: SelectSubset<T, DefaultMT5AccountFindFirstArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultMT5Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountFindFirstOrThrowArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefaultMT5AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, DefaultMT5AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefaultMT5Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefaultMT5Accounts
     * const defaultMT5Accounts = await prisma.defaultMT5Account.findMany()
     * 
     * // Get first 10 DefaultMT5Accounts
     * const defaultMT5Accounts = await prisma.defaultMT5Account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defaultMT5AccountWithIdOnly = await prisma.defaultMT5Account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefaultMT5AccountFindManyArgs>(args?: SelectSubset<T, DefaultMT5AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DefaultMT5Account.
     * @param {DefaultMT5AccountCreateArgs} args - Arguments to create a DefaultMT5Account.
     * @example
     * // Create one DefaultMT5Account
     * const DefaultMT5Account = await prisma.defaultMT5Account.create({
     *   data: {
     *     // ... data to create a DefaultMT5Account
     *   }
     * })
     * 
     */
    create<T extends DefaultMT5AccountCreateArgs>(args: SelectSubset<T, DefaultMT5AccountCreateArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DefaultMT5Accounts.
     * @param {DefaultMT5AccountCreateManyArgs} args - Arguments to create many DefaultMT5Accounts.
     * @example
     * // Create many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefaultMT5AccountCreateManyArgs>(args?: SelectSubset<T, DefaultMT5AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DefaultMT5Accounts and returns the data saved in the database.
     * @param {DefaultMT5AccountCreateManyAndReturnArgs} args - Arguments to create many DefaultMT5Accounts.
     * @example
     * // Create many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DefaultMT5Accounts and only return the `id`
     * const defaultMT5AccountWithIdOnly = await prisma.defaultMT5Account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefaultMT5AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, DefaultMT5AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DefaultMT5Account.
     * @param {DefaultMT5AccountDeleteArgs} args - Arguments to delete one DefaultMT5Account.
     * @example
     * // Delete one DefaultMT5Account
     * const DefaultMT5Account = await prisma.defaultMT5Account.delete({
     *   where: {
     *     // ... filter to delete one DefaultMT5Account
     *   }
     * })
     * 
     */
    delete<T extends DefaultMT5AccountDeleteArgs>(args: SelectSubset<T, DefaultMT5AccountDeleteArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DefaultMT5Account.
     * @param {DefaultMT5AccountUpdateArgs} args - Arguments to update one DefaultMT5Account.
     * @example
     * // Update one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefaultMT5AccountUpdateArgs>(args: SelectSubset<T, DefaultMT5AccountUpdateArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DefaultMT5Accounts.
     * @param {DefaultMT5AccountDeleteManyArgs} args - Arguments to filter DefaultMT5Accounts to delete.
     * @example
     * // Delete a few DefaultMT5Accounts
     * const { count } = await prisma.defaultMT5Account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefaultMT5AccountDeleteManyArgs>(args?: SelectSubset<T, DefaultMT5AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultMT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefaultMT5AccountUpdateManyArgs>(args: SelectSubset<T, DefaultMT5AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultMT5Accounts and returns the data updated in the database.
     * @param {DefaultMT5AccountUpdateManyAndReturnArgs} args - Arguments to update many DefaultMT5Accounts.
     * @example
     * // Update many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DefaultMT5Accounts and only return the `id`
     * const defaultMT5AccountWithIdOnly = await prisma.defaultMT5Account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DefaultMT5AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, DefaultMT5AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DefaultMT5Account.
     * @param {DefaultMT5AccountUpsertArgs} args - Arguments to update or create a DefaultMT5Account.
     * @example
     * // Update or create a DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.upsert({
     *   create: {
     *     // ... data to create a DefaultMT5Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefaultMT5Account we want to update
     *   }
     * })
     */
    upsert<T extends DefaultMT5AccountUpsertArgs>(args: SelectSubset<T, DefaultMT5AccountUpsertArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DefaultMT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountCountArgs} args - Arguments to filter DefaultMT5Accounts to count.
     * @example
     * // Count the number of DefaultMT5Accounts
     * const count = await prisma.defaultMT5Account.count({
     *   where: {
     *     // ... the filter for the DefaultMT5Accounts we want to count
     *   }
     * })
    **/
    count<T extends DefaultMT5AccountCountArgs>(
      args?: Subset<T, DefaultMT5AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefaultMT5AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefaultMT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefaultMT5AccountAggregateArgs>(args: Subset<T, DefaultMT5AccountAggregateArgs>): Prisma.PrismaPromise<GetDefaultMT5AccountAggregateType<T>>

    /**
     * Group by DefaultMT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefaultMT5AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefaultMT5AccountGroupByArgs['orderBy'] }
        : { orderBy?: DefaultMT5AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefaultMT5AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefaultMT5AccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefaultMT5Account model
   */
  readonly fields: DefaultMT5AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefaultMT5Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefaultMT5AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MT5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefaultMT5Account model
   */
  interface DefaultMT5AccountFieldRefs {
    readonly id: FieldRef<"DefaultMT5Account", 'String'>
    readonly userId: FieldRef<"DefaultMT5Account", 'String'>
    readonly mt5AccountId: FieldRef<"DefaultMT5Account", 'String'>
    readonly createdAt: FieldRef<"DefaultMT5Account", 'DateTime'>
    readonly updatedAt: FieldRef<"DefaultMT5Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DefaultMT5Account findUnique
   */
  export type DefaultMT5AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account findUniqueOrThrow
   */
  export type DefaultMT5AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account findFirst
   */
  export type DefaultMT5AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultMT5Accounts.
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultMT5Accounts.
     */
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * DefaultMT5Account findFirstOrThrow
   */
  export type DefaultMT5AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultMT5Accounts.
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultMT5Accounts.
     */
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * DefaultMT5Account findMany
   */
  export type DefaultMT5AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Accounts to fetch.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefaultMT5Accounts.
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * DefaultMT5Account create
   */
  export type DefaultMT5AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a DefaultMT5Account.
     */
    data: XOR<DefaultMT5AccountCreateInput, DefaultMT5AccountUncheckedCreateInput>
  }

  /**
   * DefaultMT5Account createMany
   */
  export type DefaultMT5AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefaultMT5Accounts.
     */
    data: DefaultMT5AccountCreateManyInput | DefaultMT5AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DefaultMT5Account createManyAndReturn
   */
  export type DefaultMT5AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * The data used to create many DefaultMT5Accounts.
     */
    data: DefaultMT5AccountCreateManyInput | DefaultMT5AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefaultMT5Account update
   */
  export type DefaultMT5AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a DefaultMT5Account.
     */
    data: XOR<DefaultMT5AccountUpdateInput, DefaultMT5AccountUncheckedUpdateInput>
    /**
     * Choose, which DefaultMT5Account to update.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account updateMany
   */
  export type DefaultMT5AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefaultMT5Accounts.
     */
    data: XOR<DefaultMT5AccountUpdateManyMutationInput, DefaultMT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which DefaultMT5Accounts to update
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * Limit how many DefaultMT5Accounts to update.
     */
    limit?: number
  }

  /**
   * DefaultMT5Account updateManyAndReturn
   */
  export type DefaultMT5AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * The data used to update DefaultMT5Accounts.
     */
    data: XOR<DefaultMT5AccountUpdateManyMutationInput, DefaultMT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which DefaultMT5Accounts to update
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * Limit how many DefaultMT5Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefaultMT5Account upsert
   */
  export type DefaultMT5AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the DefaultMT5Account to update in case it exists.
     */
    where: DefaultMT5AccountWhereUniqueInput
    /**
     * In case the DefaultMT5Account found by the `where` argument doesn't exist, create a new DefaultMT5Account with this data.
     */
    create: XOR<DefaultMT5AccountCreateInput, DefaultMT5AccountUncheckedCreateInput>
    /**
     * In case the DefaultMT5Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefaultMT5AccountUpdateInput, DefaultMT5AccountUncheckedUpdateInput>
  }

  /**
   * DefaultMT5Account delete
   */
  export type DefaultMT5AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter which DefaultMT5Account to delete.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account deleteMany
   */
  export type DefaultMT5AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultMT5Accounts to delete
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * Limit how many DefaultMT5Accounts to delete.
     */
    limit?: number
  }

  /**
   * DefaultMT5Account without action
   */
  export type DefaultMT5AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
  }


  /**
   * Model Instrument
   */

  export type AggregateInstrument = {
    _count: InstrumentCountAggregateOutputType | null
    _avg: InstrumentAvgAggregateOutputType | null
    _sum: InstrumentSumAggregateOutputType | null
    _min: InstrumentMinAggregateOutputType | null
    _max: InstrumentMaxAggregateOutputType | null
  }

  export type InstrumentAvgAggregateOutputType = {
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
  }

  export type InstrumentSumAggregateOutputType = {
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
  }

  export type InstrumentMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    name: string | null
    description: string | null
    category: string | null
    group: string | null
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
    isActive: boolean | null
    tradingHours: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstrumentMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    name: string | null
    description: string | null
    category: string | null
    group: string | null
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
    isActive: boolean | null
    tradingHours: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstrumentCountAggregateOutputType = {
    id: number
    symbol: number
    name: number
    description: number
    category: number
    group: number
    digits: number
    contractSize: number
    minVolume: number
    maxVolume: number
    volumeStep: number
    spread: number
    isActive: number
    tradingHours: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstrumentAvgAggregateInputType = {
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
  }

  export type InstrumentSumAggregateInputType = {
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
  }

  export type InstrumentMinAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    description?: true
    category?: true
    group?: true
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    isActive?: true
    tradingHours?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstrumentMaxAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    description?: true
    category?: true
    group?: true
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    isActive?: true
    tradingHours?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstrumentCountAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    description?: true
    category?: true
    group?: true
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    isActive?: true
    tradingHours?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstrumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instrument to aggregate.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instruments
    **/
    _count?: true | InstrumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstrumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstrumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstrumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstrumentMaxAggregateInputType
  }

  export type GetInstrumentAggregateType<T extends InstrumentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstrument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstrument[P]>
      : GetScalarType<T[P], AggregateInstrument[P]>
  }




  export type InstrumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstrumentWhereInput
    orderBy?: InstrumentOrderByWithAggregationInput | InstrumentOrderByWithAggregationInput[]
    by: InstrumentScalarFieldEnum[] | InstrumentScalarFieldEnum
    having?: InstrumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstrumentCountAggregateInputType | true
    _avg?: InstrumentAvgAggregateInputType
    _sum?: InstrumentSumAggregateInputType
    _min?: InstrumentMinAggregateInputType
    _max?: InstrumentMaxAggregateInputType
  }

  export type InstrumentGroupByOutputType = {
    id: string
    symbol: string
    name: string | null
    description: string | null
    category: string
    group: string | null
    digits: number
    contractSize: number
    minVolume: number
    maxVolume: number
    volumeStep: number
    spread: number
    isActive: boolean
    tradingHours: string | null
    lastUpdated: Date
    createdAt: Date
    updatedAt: Date
    _count: InstrumentCountAggregateOutputType | null
    _avg: InstrumentAvgAggregateOutputType | null
    _sum: InstrumentSumAggregateOutputType | null
    _min: InstrumentMinAggregateOutputType | null
    _max: InstrumentMaxAggregateOutputType | null
  }

  type GetInstrumentGroupByPayload<T extends InstrumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstrumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstrumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstrumentGroupByOutputType[P]>
            : GetScalarType<T[P], InstrumentGroupByOutputType[P]>
        }
      >
    >


  export type InstrumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UserFavorite?: boolean | Instrument$UserFavoriteArgs<ExtArgs>
    _count?: boolean | InstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instrument"]>

  export type InstrumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["instrument"]>

  export type InstrumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["instrument"]>

  export type InstrumentSelectScalar = {
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstrumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "name" | "description" | "category" | "group" | "digits" | "contractSize" | "minVolume" | "maxVolume" | "volumeStep" | "spread" | "isActive" | "tradingHours" | "lastUpdated" | "createdAt" | "updatedAt", ExtArgs["result"]["instrument"]>
  export type InstrumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserFavorite?: boolean | Instrument$UserFavoriteArgs<ExtArgs>
    _count?: boolean | InstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstrumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InstrumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InstrumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instrument"
    objects: {
      UserFavorite: Prisma.$UserFavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      name: string | null
      description: string | null
      category: string
      group: string | null
      digits: number
      contractSize: number
      minVolume: number
      maxVolume: number
      volumeStep: number
      spread: number
      isActive: boolean
      tradingHours: string | null
      lastUpdated: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instrument"]>
    composites: {}
  }

  type InstrumentGetPayload<S extends boolean | null | undefined | InstrumentDefaultArgs> = $Result.GetResult<Prisma.$InstrumentPayload, S>

  type InstrumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstrumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstrumentCountAggregateInputType | true
    }

  export interface InstrumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instrument'], meta: { name: 'Instrument' } }
    /**
     * Find zero or one Instrument that matches the filter.
     * @param {InstrumentFindUniqueArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstrumentFindUniqueArgs>(args: SelectSubset<T, InstrumentFindUniqueArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instrument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstrumentFindUniqueOrThrowArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstrumentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstrumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instrument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentFindFirstArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstrumentFindFirstArgs>(args?: SelectSubset<T, InstrumentFindFirstArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instrument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentFindFirstOrThrowArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstrumentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstrumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instruments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instruments
     * const instruments = await prisma.instrument.findMany()
     * 
     * // Get first 10 Instruments
     * const instruments = await prisma.instrument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instrumentWithIdOnly = await prisma.instrument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstrumentFindManyArgs>(args?: SelectSubset<T, InstrumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instrument.
     * @param {InstrumentCreateArgs} args - Arguments to create a Instrument.
     * @example
     * // Create one Instrument
     * const Instrument = await prisma.instrument.create({
     *   data: {
     *     // ... data to create a Instrument
     *   }
     * })
     * 
     */
    create<T extends InstrumentCreateArgs>(args: SelectSubset<T, InstrumentCreateArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instruments.
     * @param {InstrumentCreateManyArgs} args - Arguments to create many Instruments.
     * @example
     * // Create many Instruments
     * const instrument = await prisma.instrument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstrumentCreateManyArgs>(args?: SelectSubset<T, InstrumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instruments and returns the data saved in the database.
     * @param {InstrumentCreateManyAndReturnArgs} args - Arguments to create many Instruments.
     * @example
     * // Create many Instruments
     * const instrument = await prisma.instrument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instruments and only return the `id`
     * const instrumentWithIdOnly = await prisma.instrument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstrumentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstrumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instrument.
     * @param {InstrumentDeleteArgs} args - Arguments to delete one Instrument.
     * @example
     * // Delete one Instrument
     * const Instrument = await prisma.instrument.delete({
     *   where: {
     *     // ... filter to delete one Instrument
     *   }
     * })
     * 
     */
    delete<T extends InstrumentDeleteArgs>(args: SelectSubset<T, InstrumentDeleteArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instrument.
     * @param {InstrumentUpdateArgs} args - Arguments to update one Instrument.
     * @example
     * // Update one Instrument
     * const instrument = await prisma.instrument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstrumentUpdateArgs>(args: SelectSubset<T, InstrumentUpdateArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instruments.
     * @param {InstrumentDeleteManyArgs} args - Arguments to filter Instruments to delete.
     * @example
     * // Delete a few Instruments
     * const { count } = await prisma.instrument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstrumentDeleteManyArgs>(args?: SelectSubset<T, InstrumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instruments
     * const instrument = await prisma.instrument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstrumentUpdateManyArgs>(args: SelectSubset<T, InstrumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instruments and returns the data updated in the database.
     * @param {InstrumentUpdateManyAndReturnArgs} args - Arguments to update many Instruments.
     * @example
     * // Update many Instruments
     * const instrument = await prisma.instrument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instruments and only return the `id`
     * const instrumentWithIdOnly = await prisma.instrument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstrumentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstrumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instrument.
     * @param {InstrumentUpsertArgs} args - Arguments to update or create a Instrument.
     * @example
     * // Update or create a Instrument
     * const instrument = await prisma.instrument.upsert({
     *   create: {
     *     // ... data to create a Instrument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instrument we want to update
     *   }
     * })
     */
    upsert<T extends InstrumentUpsertArgs>(args: SelectSubset<T, InstrumentUpsertArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentCountArgs} args - Arguments to filter Instruments to count.
     * @example
     * // Count the number of Instruments
     * const count = await prisma.instrument.count({
     *   where: {
     *     // ... the filter for the Instruments we want to count
     *   }
     * })
    **/
    count<T extends InstrumentCountArgs>(
      args?: Subset<T, InstrumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstrumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstrumentAggregateArgs>(args: Subset<T, InstrumentAggregateArgs>): Prisma.PrismaPromise<GetInstrumentAggregateType<T>>

    /**
     * Group by Instrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstrumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstrumentGroupByArgs['orderBy'] }
        : { orderBy?: InstrumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstrumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstrumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instrument model
   */
  readonly fields: InstrumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instrument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstrumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserFavorite<T extends Instrument$UserFavoriteArgs<ExtArgs> = {}>(args?: Subset<T, Instrument$UserFavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instrument model
   */
  interface InstrumentFieldRefs {
    readonly id: FieldRef<"Instrument", 'String'>
    readonly symbol: FieldRef<"Instrument", 'String'>
    readonly name: FieldRef<"Instrument", 'String'>
    readonly description: FieldRef<"Instrument", 'String'>
    readonly category: FieldRef<"Instrument", 'String'>
    readonly group: FieldRef<"Instrument", 'String'>
    readonly digits: FieldRef<"Instrument", 'Int'>
    readonly contractSize: FieldRef<"Instrument", 'Float'>
    readonly minVolume: FieldRef<"Instrument", 'Float'>
    readonly maxVolume: FieldRef<"Instrument", 'Float'>
    readonly volumeStep: FieldRef<"Instrument", 'Float'>
    readonly spread: FieldRef<"Instrument", 'Float'>
    readonly isActive: FieldRef<"Instrument", 'Boolean'>
    readonly tradingHours: FieldRef<"Instrument", 'String'>
    readonly lastUpdated: FieldRef<"Instrument", 'DateTime'>
    readonly createdAt: FieldRef<"Instrument", 'DateTime'>
    readonly updatedAt: FieldRef<"Instrument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instrument findUnique
   */
  export type InstrumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument findUniqueOrThrow
   */
  export type InstrumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument findFirst
   */
  export type InstrumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instruments.
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instruments.
     */
    distinct?: InstrumentScalarFieldEnum | InstrumentScalarFieldEnum[]
  }

  /**
   * Instrument findFirstOrThrow
   */
  export type InstrumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instruments.
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instruments.
     */
    distinct?: InstrumentScalarFieldEnum | InstrumentScalarFieldEnum[]
  }

  /**
   * Instrument findMany
   */
  export type InstrumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instruments to fetch.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instruments.
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    distinct?: InstrumentScalarFieldEnum | InstrumentScalarFieldEnum[]
  }

  /**
   * Instrument create
   */
  export type InstrumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Instrument.
     */
    data: XOR<InstrumentCreateInput, InstrumentUncheckedCreateInput>
  }

  /**
   * Instrument createMany
   */
  export type InstrumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instruments.
     */
    data: InstrumentCreateManyInput | InstrumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instrument createManyAndReturn
   */
  export type InstrumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * The data used to create many Instruments.
     */
    data: InstrumentCreateManyInput | InstrumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instrument update
   */
  export type InstrumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Instrument.
     */
    data: XOR<InstrumentUpdateInput, InstrumentUncheckedUpdateInput>
    /**
     * Choose, which Instrument to update.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument updateMany
   */
  export type InstrumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instruments.
     */
    data: XOR<InstrumentUpdateManyMutationInput, InstrumentUncheckedUpdateManyInput>
    /**
     * Filter which Instruments to update
     */
    where?: InstrumentWhereInput
    /**
     * Limit how many Instruments to update.
     */
    limit?: number
  }

  /**
   * Instrument updateManyAndReturn
   */
  export type InstrumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * The data used to update Instruments.
     */
    data: XOR<InstrumentUpdateManyMutationInput, InstrumentUncheckedUpdateManyInput>
    /**
     * Filter which Instruments to update
     */
    where?: InstrumentWhereInput
    /**
     * Limit how many Instruments to update.
     */
    limit?: number
  }

  /**
   * Instrument upsert
   */
  export type InstrumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Instrument to update in case it exists.
     */
    where: InstrumentWhereUniqueInput
    /**
     * In case the Instrument found by the `where` argument doesn't exist, create a new Instrument with this data.
     */
    create: XOR<InstrumentCreateInput, InstrumentUncheckedCreateInput>
    /**
     * In case the Instrument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstrumentUpdateInput, InstrumentUncheckedUpdateInput>
  }

  /**
   * Instrument delete
   */
  export type InstrumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter which Instrument to delete.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument deleteMany
   */
  export type InstrumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instruments to delete
     */
    where?: InstrumentWhereInput
    /**
     * Limit how many Instruments to delete.
     */
    limit?: number
  }

  /**
   * Instrument.UserFavorite
   */
  export type Instrument$UserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * Instrument without action
   */
  export type InstrumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revoked: boolean | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revoked: boolean | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    revoked: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revoked?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revoked?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revoked?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date | null
    revoked: boolean | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt" | "revoked", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date | null
      revoked: boolean | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model UserFavorite
   */

  export type AggregateUserFavorite = {
    _count: UserFavoriteCountAggregateOutputType | null
    _avg: UserFavoriteAvgAggregateOutputType | null
    _sum: UserFavoriteSumAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  export type UserFavoriteAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserFavoriteSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserFavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    instrumentId: string | null
    sortOrder: number | null
    addedAt: Date | null
  }

  export type UserFavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    instrumentId: string | null
    sortOrder: number | null
    addedAt: Date | null
  }

  export type UserFavoriteCountAggregateOutputType = {
    id: number
    userId: number
    instrumentId: number
    sortOrder: number
    addedAt: number
    _all: number
  }


  export type UserFavoriteAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserFavoriteSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserFavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    instrumentId?: true
    sortOrder?: true
    addedAt?: true
  }

  export type UserFavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    instrumentId?: true
    sortOrder?: true
    addedAt?: true
  }

  export type UserFavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    instrumentId?: true
    sortOrder?: true
    addedAt?: true
    _all?: true
  }

  export type UserFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorite to aggregate.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavorites
    **/
    _count?: true | UserFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFavoriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFavoriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type GetUserFavoriteAggregateType<T extends UserFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavorite[P]>
      : GetScalarType<T[P], AggregateUserFavorite[P]>
  }




  export type UserFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithAggregationInput | UserFavoriteOrderByWithAggregationInput[]
    by: UserFavoriteScalarFieldEnum[] | UserFavoriteScalarFieldEnum
    having?: UserFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoriteCountAggregateInputType | true
    _avg?: UserFavoriteAvgAggregateInputType
    _sum?: UserFavoriteSumAggregateInputType
    _min?: UserFavoriteMinAggregateInputType
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type UserFavoriteGroupByOutputType = {
    id: string
    userId: string
    instrumentId: string
    sortOrder: number
    addedAt: Date
    _count: UserFavoriteCountAggregateOutputType | null
    _avg: UserFavoriteAvgAggregateOutputType | null
    _sum: UserFavoriteSumAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  type GetUserFavoriteGroupByPayload<T extends UserFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
  }

  export type UserFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "instrumentId" | "sortOrder" | "addedAt", ExtArgs["result"]["userFavorite"]>
  export type UserFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavorite"
    objects: {
      Instrument: Prisma.$InstrumentPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      instrumentId: string
      sortOrder: number
      addedAt: Date
    }, ExtArgs["result"]["userFavorite"]>
    composites: {}
  }

  type UserFavoriteGetPayload<S extends boolean | null | undefined | UserFavoriteDefaultArgs> = $Result.GetResult<Prisma.$UserFavoritePayload, S>

  type UserFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavoriteCountAggregateInputType | true
    }

  export interface UserFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavorite'], meta: { name: 'UserFavorite' } }
    /**
     * Find zero or one UserFavorite that matches the filter.
     * @param {UserFavoriteFindUniqueArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavoriteFindUniqueArgs>(args: SelectSubset<T, UserFavoriteFindUniqueArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavoriteFindUniqueOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavoriteFindFirstArgs>(args?: SelectSubset<T, UserFavoriteFindFirstArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany()
     * 
     * // Get first 10 UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFavoriteFindManyArgs>(args?: SelectSubset<T, UserFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavorite.
     * @param {UserFavoriteCreateArgs} args - Arguments to create a UserFavorite.
     * @example
     * // Create one UserFavorite
     * const UserFavorite = await prisma.userFavorite.create({
     *   data: {
     *     // ... data to create a UserFavorite
     *   }
     * })
     * 
     */
    create<T extends UserFavoriteCreateArgs>(args: SelectSubset<T, UserFavoriteCreateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavorites.
     * @param {UserFavoriteCreateManyArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavoriteCreateManyArgs>(args?: SelectSubset<T, UserFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFavorites and returns the data saved in the database.
     * @param {UserFavoriteCreateManyAndReturnArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFavorite.
     * @param {UserFavoriteDeleteArgs} args - Arguments to delete one UserFavorite.
     * @example
     * // Delete one UserFavorite
     * const UserFavorite = await prisma.userFavorite.delete({
     *   where: {
     *     // ... filter to delete one UserFavorite
     *   }
     * })
     * 
     */
    delete<T extends UserFavoriteDeleteArgs>(args: SelectSubset<T, UserFavoriteDeleteArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavorite.
     * @param {UserFavoriteUpdateArgs} args - Arguments to update one UserFavorite.
     * @example
     * // Update one UserFavorite
     * const userFavorite = await prisma.userFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavoriteUpdateArgs>(args: SelectSubset<T, UserFavoriteUpdateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavorites.
     * @param {UserFavoriteDeleteManyArgs} args - Arguments to filter UserFavorites to delete.
     * @example
     * // Delete a few UserFavorites
     * const { count } = await prisma.userFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavoriteDeleteManyArgs>(args?: SelectSubset<T, UserFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavoriteUpdateManyArgs>(args: SelectSubset<T, UserFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites and returns the data updated in the database.
     * @param {UserFavoriteUpdateManyAndReturnArgs} args - Arguments to update many UserFavorites.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFavorite.
     * @param {UserFavoriteUpsertArgs} args - Arguments to update or create a UserFavorite.
     * @example
     * // Update or create a UserFavorite
     * const userFavorite = await prisma.userFavorite.upsert({
     *   create: {
     *     // ... data to create a UserFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavorite we want to update
     *   }
     * })
     */
    upsert<T extends UserFavoriteUpsertArgs>(args: SelectSubset<T, UserFavoriteUpsertArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteCountArgs} args - Arguments to filter UserFavorites to count.
     * @example
     * // Count the number of UserFavorites
     * const count = await prisma.userFavorite.count({
     *   where: {
     *     // ... the filter for the UserFavorites we want to count
     *   }
     * })
    **/
    count<T extends UserFavoriteCountArgs>(
      args?: Subset<T, UserFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoriteAggregateArgs>(args: Subset<T, UserFavoriteAggregateArgs>): Prisma.PrismaPromise<GetUserFavoriteAggregateType<T>>

    /**
     * Group by UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavorite model
   */
  readonly fields: UserFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instrument<T extends InstrumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstrumentDefaultArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavorite model
   */
  interface UserFavoriteFieldRefs {
    readonly id: FieldRef<"UserFavorite", 'String'>
    readonly userId: FieldRef<"UserFavorite", 'String'>
    readonly instrumentId: FieldRef<"UserFavorite", 'String'>
    readonly sortOrder: FieldRef<"UserFavorite", 'Int'>
    readonly addedAt: FieldRef<"UserFavorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFavorite findUnique
   */
  export type UserFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findUniqueOrThrow
   */
  export type UserFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findFirst
   */
  export type UserFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findFirstOrThrow
   */
  export type UserFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findMany
   */
  export type UserFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorites to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite create
   */
  export type UserFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavorite.
     */
    data: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
  }

  /**
   * UserFavorite createMany
   */
  export type UserFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFavorite createManyAndReturn
   */
  export type UserFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite update
   */
  export type UserFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavorite.
     */
    data: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
    /**
     * Choose, which UserFavorite to update.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite updateMany
   */
  export type UserFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
  }

  /**
   * UserFavorite updateManyAndReturn
   */
  export type UserFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite upsert
   */
  export type UserFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavorite to update in case it exists.
     */
    where: UserFavoriteWhereUniqueInput
    /**
     * In case the UserFavorite found by the `where` argument doesn't exist, create a new UserFavorite with this data.
     */
    create: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
    /**
     * In case the UserFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
  }

  /**
   * UserFavorite delete
   */
  export type UserFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter which UserFavorite to delete.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite deleteMany
   */
  export type UserFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorites to delete
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to delete.
     */
    limit?: number
  }

  /**
   * UserFavorite without action
   */
  export type UserFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    admin_role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    admin_role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password_hash: number
    admin_role: number
    is_active: number
    last_login: number
    login_attempts: number
    locked_until: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    admin_role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    admin_role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    admin_role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    username: string
    email: string
    password_hash: string
    admin_role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
    admin_login_log?: boolean | admin$admin_login_logArgs<ExtArgs>
    balance_operation_history?: boolean | admin$balance_operation_historyArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin"]>

  export type adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin"]>

  export type adminSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password_hash" | "admin_role" | "is_active" | "last_login" | "login_attempts" | "locked_until" | "created_at" | "updated_at", ExtArgs["result"]["admin"]>
  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_login_log?: boolean | admin$admin_login_logArgs<ExtArgs>
    balance_operation_history?: boolean | admin$balance_operation_historyArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      admin_login_log: Prisma.$admin_login_logPayload<ExtArgs>[]
      balance_operation_history: Prisma.$balance_operation_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password_hash: string
      admin_role: string | null
      is_active: boolean | null
      last_login: Date | null
      login_attempts: number | null
      locked_until: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adminCreateManyAndReturnArgs>(args?: SelectSubset<T, adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {adminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends adminUpdateManyAndReturnArgs>(args: SelectSubset<T, adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_login_log<T extends admin$admin_login_logArgs<ExtArgs> = {}>(args?: Subset<T, admin$admin_login_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    balance_operation_history<T extends admin$balance_operation_historyArgs<ExtArgs> = {}>(args?: Subset<T, admin$balance_operation_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'Int'>
    readonly username: FieldRef<"admin", 'String'>
    readonly email: FieldRef<"admin", 'String'>
    readonly password_hash: FieldRef<"admin", 'String'>
    readonly admin_role: FieldRef<"admin", 'String'>
    readonly is_active: FieldRef<"admin", 'Boolean'>
    readonly last_login: FieldRef<"admin", 'DateTime'>
    readonly login_attempts: FieldRef<"admin", 'Int'>
    readonly locked_until: FieldRef<"admin", 'DateTime'>
    readonly created_at: FieldRef<"admin", 'DateTime'>
    readonly updated_at: FieldRef<"admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin createManyAndReturn
   */
  export type adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin updateManyAndReturn
   */
  export type adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admin.admin_login_log
   */
  export type admin$admin_login_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    where?: admin_login_logWhereInput
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    cursor?: admin_login_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin.balance_operation_history
   */
  export type admin$balance_operation_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    where?: balance_operation_historyWhereInput
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    cursor?: balance_operation_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model admin_login_log
   */

  export type AggregateAdmin_login_log = {
    _count: Admin_login_logCountAggregateOutputType | null
    _avg: Admin_login_logAvgAggregateOutputType | null
    _sum: Admin_login_logSumAggregateOutputType | null
    _min: Admin_login_logMinAggregateOutputType | null
    _max: Admin_login_logMaxAggregateOutputType | null
  }

  export type Admin_login_logAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
  }

  export type Admin_login_logSumAggregateOutputType = {
    id: number | null
    admin_id: number | null
  }

  export type Admin_login_logMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    ip_address: string | null
    user_agent: string | null
    location: string | null
    device: string | null
    browser: string | null
    os: string | null
    success: boolean | null
    failure_reason: string | null
    created_at: Date | null
  }

  export type Admin_login_logMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    ip_address: string | null
    user_agent: string | null
    location: string | null
    device: string | null
    browser: string | null
    os: string | null
    success: boolean | null
    failure_reason: string | null
    created_at: Date | null
  }

  export type Admin_login_logCountAggregateOutputType = {
    id: number
    admin_id: number
    ip_address: number
    user_agent: number
    location: number
    device: number
    browser: number
    os: number
    success: number
    failure_reason: number
    created_at: number
    _all: number
  }


  export type Admin_login_logAvgAggregateInputType = {
    id?: true
    admin_id?: true
  }

  export type Admin_login_logSumAggregateInputType = {
    id?: true
    admin_id?: true
  }

  export type Admin_login_logMinAggregateInputType = {
    id?: true
    admin_id?: true
    ip_address?: true
    user_agent?: true
    location?: true
    device?: true
    browser?: true
    os?: true
    success?: true
    failure_reason?: true
    created_at?: true
  }

  export type Admin_login_logMaxAggregateInputType = {
    id?: true
    admin_id?: true
    ip_address?: true
    user_agent?: true
    location?: true
    device?: true
    browser?: true
    os?: true
    success?: true
    failure_reason?: true
    created_at?: true
  }

  export type Admin_login_logCountAggregateInputType = {
    id?: true
    admin_id?: true
    ip_address?: true
    user_agent?: true
    location?: true
    device?: true
    browser?: true
    os?: true
    success?: true
    failure_reason?: true
    created_at?: true
    _all?: true
  }

  export type Admin_login_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_login_log to aggregate.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_login_logs
    **/
    _count?: true | Admin_login_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_login_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_login_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_login_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_login_logMaxAggregateInputType
  }

  export type GetAdmin_login_logAggregateType<T extends Admin_login_logAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_login_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_login_log[P]>
      : GetScalarType<T[P], AggregateAdmin_login_log[P]>
  }




  export type admin_login_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_login_logWhereInput
    orderBy?: admin_login_logOrderByWithAggregationInput | admin_login_logOrderByWithAggregationInput[]
    by: Admin_login_logScalarFieldEnum[] | Admin_login_logScalarFieldEnum
    having?: admin_login_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_login_logCountAggregateInputType | true
    _avg?: Admin_login_logAvgAggregateInputType
    _sum?: Admin_login_logSumAggregateInputType
    _min?: Admin_login_logMinAggregateInputType
    _max?: Admin_login_logMaxAggregateInputType
  }

  export type Admin_login_logGroupByOutputType = {
    id: number
    admin_id: number
    ip_address: string
    user_agent: string | null
    location: string | null
    device: string | null
    browser: string | null
    os: string | null
    success: boolean
    failure_reason: string | null
    created_at: Date
    _count: Admin_login_logCountAggregateOutputType | null
    _avg: Admin_login_logAvgAggregateOutputType | null
    _sum: Admin_login_logSumAggregateOutputType | null
    _min: Admin_login_logMinAggregateOutputType | null
    _max: Admin_login_logMaxAggregateOutputType | null
  }

  type GetAdmin_login_logGroupByPayload<T extends admin_login_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_login_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_login_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_login_logGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_login_logGroupByOutputType[P]>
        }
      >
    >


  export type admin_login_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_login_log"]>

  export type admin_login_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_login_log"]>

  export type admin_login_logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_login_log"]>

  export type admin_login_logSelectScalar = {
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
  }

  export type admin_login_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "ip_address" | "user_agent" | "location" | "device" | "browser" | "os" | "success" | "failure_reason" | "created_at", ExtArgs["result"]["admin_login_log"]>
  export type admin_login_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type admin_login_logIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type admin_login_logIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }

  export type $admin_login_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_login_log"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      ip_address: string
      user_agent: string | null
      location: string | null
      device: string | null
      browser: string | null
      os: string | null
      success: boolean
      failure_reason: string | null
      created_at: Date
    }, ExtArgs["result"]["admin_login_log"]>
    composites: {}
  }

  type admin_login_logGetPayload<S extends boolean | null | undefined | admin_login_logDefaultArgs> = $Result.GetResult<Prisma.$admin_login_logPayload, S>

  type admin_login_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_login_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_login_logCountAggregateInputType | true
    }

  export interface admin_login_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_login_log'], meta: { name: 'admin_login_log' } }
    /**
     * Find zero or one Admin_login_log that matches the filter.
     * @param {admin_login_logFindUniqueArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_login_logFindUniqueArgs>(args: SelectSubset<T, admin_login_logFindUniqueArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_login_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_login_logFindUniqueOrThrowArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_login_logFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_login_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_login_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logFindFirstArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_login_logFindFirstArgs>(args?: SelectSubset<T, admin_login_logFindFirstArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_login_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logFindFirstOrThrowArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_login_logFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_login_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_login_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_login_logs
     * const admin_login_logs = await prisma.admin_login_log.findMany()
     * 
     * // Get first 10 Admin_login_logs
     * const admin_login_logs = await prisma.admin_login_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_login_logWithIdOnly = await prisma.admin_login_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_login_logFindManyArgs>(args?: SelectSubset<T, admin_login_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_login_log.
     * @param {admin_login_logCreateArgs} args - Arguments to create a Admin_login_log.
     * @example
     * // Create one Admin_login_log
     * const Admin_login_log = await prisma.admin_login_log.create({
     *   data: {
     *     // ... data to create a Admin_login_log
     *   }
     * })
     * 
     */
    create<T extends admin_login_logCreateArgs>(args: SelectSubset<T, admin_login_logCreateArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_login_logs.
     * @param {admin_login_logCreateManyArgs} args - Arguments to create many Admin_login_logs.
     * @example
     * // Create many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_login_logCreateManyArgs>(args?: SelectSubset<T, admin_login_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admin_login_logs and returns the data saved in the database.
     * @param {admin_login_logCreateManyAndReturnArgs} args - Arguments to create many Admin_login_logs.
     * @example
     * // Create many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admin_login_logs and only return the `id`
     * const admin_login_logWithIdOnly = await prisma.admin_login_log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admin_login_logCreateManyAndReturnArgs>(args?: SelectSubset<T, admin_login_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin_login_log.
     * @param {admin_login_logDeleteArgs} args - Arguments to delete one Admin_login_log.
     * @example
     * // Delete one Admin_login_log
     * const Admin_login_log = await prisma.admin_login_log.delete({
     *   where: {
     *     // ... filter to delete one Admin_login_log
     *   }
     * })
     * 
     */
    delete<T extends admin_login_logDeleteArgs>(args: SelectSubset<T, admin_login_logDeleteArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_login_log.
     * @param {admin_login_logUpdateArgs} args - Arguments to update one Admin_login_log.
     * @example
     * // Update one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_login_logUpdateArgs>(args: SelectSubset<T, admin_login_logUpdateArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_login_logs.
     * @param {admin_login_logDeleteManyArgs} args - Arguments to filter Admin_login_logs to delete.
     * @example
     * // Delete a few Admin_login_logs
     * const { count } = await prisma.admin_login_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_login_logDeleteManyArgs>(args?: SelectSubset<T, admin_login_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_login_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_login_logUpdateManyArgs>(args: SelectSubset<T, admin_login_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_login_logs and returns the data updated in the database.
     * @param {admin_login_logUpdateManyAndReturnArgs} args - Arguments to update many Admin_login_logs.
     * @example
     * // Update many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admin_login_logs and only return the `id`
     * const admin_login_logWithIdOnly = await prisma.admin_login_log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends admin_login_logUpdateManyAndReturnArgs>(args: SelectSubset<T, admin_login_logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin_login_log.
     * @param {admin_login_logUpsertArgs} args - Arguments to update or create a Admin_login_log.
     * @example
     * // Update or create a Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.upsert({
     *   create: {
     *     // ... data to create a Admin_login_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_login_log we want to update
     *   }
     * })
     */
    upsert<T extends admin_login_logUpsertArgs>(args: SelectSubset<T, admin_login_logUpsertArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_login_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logCountArgs} args - Arguments to filter Admin_login_logs to count.
     * @example
     * // Count the number of Admin_login_logs
     * const count = await prisma.admin_login_log.count({
     *   where: {
     *     // ... the filter for the Admin_login_logs we want to count
     *   }
     * })
    **/
    count<T extends admin_login_logCountArgs>(
      args?: Subset<T, admin_login_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_login_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_login_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_login_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_login_logAggregateArgs>(args: Subset<T, Admin_login_logAggregateArgs>): Prisma.PrismaPromise<GetAdmin_login_logAggregateType<T>>

    /**
     * Group by Admin_login_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_login_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_login_logGroupByArgs['orderBy'] }
        : { orderBy?: admin_login_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_login_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_login_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_login_log model
   */
  readonly fields: admin_login_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_login_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_login_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_login_log model
   */
  interface admin_login_logFieldRefs {
    readonly id: FieldRef<"admin_login_log", 'Int'>
    readonly admin_id: FieldRef<"admin_login_log", 'Int'>
    readonly ip_address: FieldRef<"admin_login_log", 'String'>
    readonly user_agent: FieldRef<"admin_login_log", 'String'>
    readonly location: FieldRef<"admin_login_log", 'String'>
    readonly device: FieldRef<"admin_login_log", 'String'>
    readonly browser: FieldRef<"admin_login_log", 'String'>
    readonly os: FieldRef<"admin_login_log", 'String'>
    readonly success: FieldRef<"admin_login_log", 'Boolean'>
    readonly failure_reason: FieldRef<"admin_login_log", 'String'>
    readonly created_at: FieldRef<"admin_login_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin_login_log findUnique
   */
  export type admin_login_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log findUniqueOrThrow
   */
  export type admin_login_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log findFirst
   */
  export type admin_login_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_login_logs.
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_login_logs.
     */
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin_login_log findFirstOrThrow
   */
  export type admin_login_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_login_logs.
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_login_logs.
     */
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin_login_log findMany
   */
  export type admin_login_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_logs to fetch.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_login_logs.
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin_login_log create
   */
  export type admin_login_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * The data needed to create a admin_login_log.
     */
    data: XOR<admin_login_logCreateInput, admin_login_logUncheckedCreateInput>
  }

  /**
   * admin_login_log createMany
   */
  export type admin_login_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_login_logs.
     */
    data: admin_login_logCreateManyInput | admin_login_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_login_log createManyAndReturn
   */
  export type admin_login_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * The data used to create many admin_login_logs.
     */
    data: admin_login_logCreateManyInput | admin_login_logCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_login_log update
   */
  export type admin_login_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * The data needed to update a admin_login_log.
     */
    data: XOR<admin_login_logUpdateInput, admin_login_logUncheckedUpdateInput>
    /**
     * Choose, which admin_login_log to update.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log updateMany
   */
  export type admin_login_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_login_logs.
     */
    data: XOR<admin_login_logUpdateManyMutationInput, admin_login_logUncheckedUpdateManyInput>
    /**
     * Filter which admin_login_logs to update
     */
    where?: admin_login_logWhereInput
    /**
     * Limit how many admin_login_logs to update.
     */
    limit?: number
  }

  /**
   * admin_login_log updateManyAndReturn
   */
  export type admin_login_logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * The data used to update admin_login_logs.
     */
    data: XOR<admin_login_logUpdateManyMutationInput, admin_login_logUncheckedUpdateManyInput>
    /**
     * Filter which admin_login_logs to update
     */
    where?: admin_login_logWhereInput
    /**
     * Limit how many admin_login_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_login_log upsert
   */
  export type admin_login_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * The filter to search for the admin_login_log to update in case it exists.
     */
    where: admin_login_logWhereUniqueInput
    /**
     * In case the admin_login_log found by the `where` argument doesn't exist, create a new admin_login_log with this data.
     */
    create: XOR<admin_login_logCreateInput, admin_login_logUncheckedCreateInput>
    /**
     * In case the admin_login_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_login_logUpdateInput, admin_login_logUncheckedUpdateInput>
  }

  /**
   * admin_login_log delete
   */
  export type admin_login_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter which admin_login_log to delete.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log deleteMany
   */
  export type admin_login_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_login_logs to delete
     */
    where?: admin_login_logWhereInput
    /**
     * Limit how many admin_login_logs to delete.
     */
    limit?: number
  }

  /**
   * admin_login_log without action
   */
  export type admin_login_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
  }


  /**
   * Model balance_operation_history
   */

  export type AggregateBalance_operation_history = {
    _count: Balance_operation_historyCountAggregateOutputType | null
    _avg: Balance_operation_historyAvgAggregateOutputType | null
    _sum: Balance_operation_historySumAggregateOutputType | null
    _min: Balance_operation_historyMinAggregateOutputType | null
    _max: Balance_operation_historyMaxAggregateOutputType | null
  }

  export type Balance_operation_historyAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
    amount: number | null
  }

  export type Balance_operation_historySumAggregateOutputType = {
    id: number | null
    admin_id: number | null
    amount: number | null
  }

  export type Balance_operation_historyMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    mt5_login: string | null
    operation_type: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: string | null
    error_message: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
  }

  export type Balance_operation_historyMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    mt5_login: string | null
    operation_type: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: string | null
    error_message: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
  }

  export type Balance_operation_historyCountAggregateOutputType = {
    id: number
    admin_id: number
    mt5_login: number
    operation_type: number
    amount: number
    currency: number
    description: number
    status: number
    error_message: number
    ip_address: number
    user_agent: number
    created_at: number
    _all: number
  }


  export type Balance_operation_historyAvgAggregateInputType = {
    id?: true
    admin_id?: true
    amount?: true
  }

  export type Balance_operation_historySumAggregateInputType = {
    id?: true
    admin_id?: true
    amount?: true
  }

  export type Balance_operation_historyMinAggregateInputType = {
    id?: true
    admin_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    error_message?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
  }

  export type Balance_operation_historyMaxAggregateInputType = {
    id?: true
    admin_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    error_message?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
  }

  export type Balance_operation_historyCountAggregateInputType = {
    id?: true
    admin_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    error_message?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    _all?: true
  }

  export type Balance_operation_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balance_operation_history to aggregate.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned balance_operation_histories
    **/
    _count?: true | Balance_operation_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Balance_operation_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Balance_operation_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Balance_operation_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Balance_operation_historyMaxAggregateInputType
  }

  export type GetBalance_operation_historyAggregateType<T extends Balance_operation_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance_operation_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance_operation_history[P]>
      : GetScalarType<T[P], AggregateBalance_operation_history[P]>
  }




  export type balance_operation_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balance_operation_historyWhereInput
    orderBy?: balance_operation_historyOrderByWithAggregationInput | balance_operation_historyOrderByWithAggregationInput[]
    by: Balance_operation_historyScalarFieldEnum[] | Balance_operation_historyScalarFieldEnum
    having?: balance_operation_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Balance_operation_historyCountAggregateInputType | true
    _avg?: Balance_operation_historyAvgAggregateInputType
    _sum?: Balance_operation_historySumAggregateInputType
    _min?: Balance_operation_historyMinAggregateInputType
    _max?: Balance_operation_historyMaxAggregateInputType
  }

  export type Balance_operation_historyGroupByOutputType = {
    id: number
    admin_id: number
    mt5_login: string
    operation_type: string
    amount: number
    currency: string
    description: string | null
    status: string
    error_message: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date
    _count: Balance_operation_historyCountAggregateOutputType | null
    _avg: Balance_operation_historyAvgAggregateOutputType | null
    _sum: Balance_operation_historySumAggregateOutputType | null
    _min: Balance_operation_historyMinAggregateOutputType | null
    _max: Balance_operation_historyMaxAggregateOutputType | null
  }

  type GetBalance_operation_historyGroupByPayload<T extends balance_operation_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Balance_operation_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Balance_operation_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Balance_operation_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Balance_operation_historyGroupByOutputType[P]>
        }
      >
    >


  export type balance_operation_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance_operation_history"]>

  export type balance_operation_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance_operation_history"]>

  export type balance_operation_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance_operation_history"]>

  export type balance_operation_historySelectScalar = {
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
  }

  export type balance_operation_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "mt5_login" | "operation_type" | "amount" | "currency" | "description" | "status" | "error_message" | "ip_address" | "user_agent" | "created_at", ExtArgs["result"]["balance_operation_history"]>
  export type balance_operation_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type balance_operation_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type balance_operation_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }

  export type $balance_operation_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "balance_operation_history"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      mt5_login: string
      operation_type: string
      amount: number
      currency: string
      description: string | null
      status: string
      error_message: string | null
      ip_address: string | null
      user_agent: string | null
      created_at: Date
    }, ExtArgs["result"]["balance_operation_history"]>
    composites: {}
  }

  type balance_operation_historyGetPayload<S extends boolean | null | undefined | balance_operation_historyDefaultArgs> = $Result.GetResult<Prisma.$balance_operation_historyPayload, S>

  type balance_operation_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<balance_operation_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Balance_operation_historyCountAggregateInputType | true
    }

  export interface balance_operation_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['balance_operation_history'], meta: { name: 'balance_operation_history' } }
    /**
     * Find zero or one Balance_operation_history that matches the filter.
     * @param {balance_operation_historyFindUniqueArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends balance_operation_historyFindUniqueArgs>(args: SelectSubset<T, balance_operation_historyFindUniqueArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balance_operation_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {balance_operation_historyFindUniqueOrThrowArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends balance_operation_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, balance_operation_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance_operation_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyFindFirstArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends balance_operation_historyFindFirstArgs>(args?: SelectSubset<T, balance_operation_historyFindFirstArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance_operation_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyFindFirstOrThrowArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends balance_operation_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, balance_operation_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balance_operation_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balance_operation_histories
     * const balance_operation_histories = await prisma.balance_operation_history.findMany()
     * 
     * // Get first 10 Balance_operation_histories
     * const balance_operation_histories = await prisma.balance_operation_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balance_operation_historyWithIdOnly = await prisma.balance_operation_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends balance_operation_historyFindManyArgs>(args?: SelectSubset<T, balance_operation_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balance_operation_history.
     * @param {balance_operation_historyCreateArgs} args - Arguments to create a Balance_operation_history.
     * @example
     * // Create one Balance_operation_history
     * const Balance_operation_history = await prisma.balance_operation_history.create({
     *   data: {
     *     // ... data to create a Balance_operation_history
     *   }
     * })
     * 
     */
    create<T extends balance_operation_historyCreateArgs>(args: SelectSubset<T, balance_operation_historyCreateArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balance_operation_histories.
     * @param {balance_operation_historyCreateManyArgs} args - Arguments to create many Balance_operation_histories.
     * @example
     * // Create many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends balance_operation_historyCreateManyArgs>(args?: SelectSubset<T, balance_operation_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balance_operation_histories and returns the data saved in the database.
     * @param {balance_operation_historyCreateManyAndReturnArgs} args - Arguments to create many Balance_operation_histories.
     * @example
     * // Create many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balance_operation_histories and only return the `id`
     * const balance_operation_historyWithIdOnly = await prisma.balance_operation_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends balance_operation_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, balance_operation_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Balance_operation_history.
     * @param {balance_operation_historyDeleteArgs} args - Arguments to delete one Balance_operation_history.
     * @example
     * // Delete one Balance_operation_history
     * const Balance_operation_history = await prisma.balance_operation_history.delete({
     *   where: {
     *     // ... filter to delete one Balance_operation_history
     *   }
     * })
     * 
     */
    delete<T extends balance_operation_historyDeleteArgs>(args: SelectSubset<T, balance_operation_historyDeleteArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balance_operation_history.
     * @param {balance_operation_historyUpdateArgs} args - Arguments to update one Balance_operation_history.
     * @example
     * // Update one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends balance_operation_historyUpdateArgs>(args: SelectSubset<T, balance_operation_historyUpdateArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balance_operation_histories.
     * @param {balance_operation_historyDeleteManyArgs} args - Arguments to filter Balance_operation_histories to delete.
     * @example
     * // Delete a few Balance_operation_histories
     * const { count } = await prisma.balance_operation_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends balance_operation_historyDeleteManyArgs>(args?: SelectSubset<T, balance_operation_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balance_operation_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends balance_operation_historyUpdateManyArgs>(args: SelectSubset<T, balance_operation_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balance_operation_histories and returns the data updated in the database.
     * @param {balance_operation_historyUpdateManyAndReturnArgs} args - Arguments to update many Balance_operation_histories.
     * @example
     * // Update many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Balance_operation_histories and only return the `id`
     * const balance_operation_historyWithIdOnly = await prisma.balance_operation_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends balance_operation_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, balance_operation_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Balance_operation_history.
     * @param {balance_operation_historyUpsertArgs} args - Arguments to update or create a Balance_operation_history.
     * @example
     * // Update or create a Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.upsert({
     *   create: {
     *     // ... data to create a Balance_operation_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance_operation_history we want to update
     *   }
     * })
     */
    upsert<T extends balance_operation_historyUpsertArgs>(args: SelectSubset<T, balance_operation_historyUpsertArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balance_operation_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyCountArgs} args - Arguments to filter Balance_operation_histories to count.
     * @example
     * // Count the number of Balance_operation_histories
     * const count = await prisma.balance_operation_history.count({
     *   where: {
     *     // ... the filter for the Balance_operation_histories we want to count
     *   }
     * })
    **/
    count<T extends balance_operation_historyCountArgs>(
      args?: Subset<T, balance_operation_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Balance_operation_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance_operation_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Balance_operation_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Balance_operation_historyAggregateArgs>(args: Subset<T, Balance_operation_historyAggregateArgs>): Prisma.PrismaPromise<GetBalance_operation_historyAggregateType<T>>

    /**
     * Group by Balance_operation_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends balance_operation_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: balance_operation_historyGroupByArgs['orderBy'] }
        : { orderBy?: balance_operation_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, balance_operation_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalance_operation_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the balance_operation_history model
   */
  readonly fields: balance_operation_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for balance_operation_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__balance_operation_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the balance_operation_history model
   */
  interface balance_operation_historyFieldRefs {
    readonly id: FieldRef<"balance_operation_history", 'Int'>
    readonly admin_id: FieldRef<"balance_operation_history", 'Int'>
    readonly mt5_login: FieldRef<"balance_operation_history", 'String'>
    readonly operation_type: FieldRef<"balance_operation_history", 'String'>
    readonly amount: FieldRef<"balance_operation_history", 'Float'>
    readonly currency: FieldRef<"balance_operation_history", 'String'>
    readonly description: FieldRef<"balance_operation_history", 'String'>
    readonly status: FieldRef<"balance_operation_history", 'String'>
    readonly error_message: FieldRef<"balance_operation_history", 'String'>
    readonly ip_address: FieldRef<"balance_operation_history", 'String'>
    readonly user_agent: FieldRef<"balance_operation_history", 'String'>
    readonly created_at: FieldRef<"balance_operation_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * balance_operation_history findUnique
   */
  export type balance_operation_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history findUniqueOrThrow
   */
  export type balance_operation_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history findFirst
   */
  export type balance_operation_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balance_operation_histories.
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balance_operation_histories.
     */
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * balance_operation_history findFirstOrThrow
   */
  export type balance_operation_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balance_operation_histories.
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balance_operation_histories.
     */
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * balance_operation_history findMany
   */
  export type balance_operation_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_histories to fetch.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing balance_operation_histories.
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * balance_operation_history create
   */
  export type balance_operation_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a balance_operation_history.
     */
    data: XOR<balance_operation_historyCreateInput, balance_operation_historyUncheckedCreateInput>
  }

  /**
   * balance_operation_history createMany
   */
  export type balance_operation_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many balance_operation_histories.
     */
    data: balance_operation_historyCreateManyInput | balance_operation_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * balance_operation_history createManyAndReturn
   */
  export type balance_operation_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * The data used to create many balance_operation_histories.
     */
    data: balance_operation_historyCreateManyInput | balance_operation_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * balance_operation_history update
   */
  export type balance_operation_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a balance_operation_history.
     */
    data: XOR<balance_operation_historyUpdateInput, balance_operation_historyUncheckedUpdateInput>
    /**
     * Choose, which balance_operation_history to update.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history updateMany
   */
  export type balance_operation_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update balance_operation_histories.
     */
    data: XOR<balance_operation_historyUpdateManyMutationInput, balance_operation_historyUncheckedUpdateManyInput>
    /**
     * Filter which balance_operation_histories to update
     */
    where?: balance_operation_historyWhereInput
    /**
     * Limit how many balance_operation_histories to update.
     */
    limit?: number
  }

  /**
   * balance_operation_history updateManyAndReturn
   */
  export type balance_operation_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * The data used to update balance_operation_histories.
     */
    data: XOR<balance_operation_historyUpdateManyMutationInput, balance_operation_historyUncheckedUpdateManyInput>
    /**
     * Filter which balance_operation_histories to update
     */
    where?: balance_operation_historyWhereInput
    /**
     * Limit how many balance_operation_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * balance_operation_history upsert
   */
  export type balance_operation_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the balance_operation_history to update in case it exists.
     */
    where: balance_operation_historyWhereUniqueInput
    /**
     * In case the balance_operation_history found by the `where` argument doesn't exist, create a new balance_operation_history with this data.
     */
    create: XOR<balance_operation_historyCreateInput, balance_operation_historyUncheckedCreateInput>
    /**
     * In case the balance_operation_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<balance_operation_historyUpdateInput, balance_operation_historyUncheckedUpdateInput>
  }

  /**
   * balance_operation_history delete
   */
  export type balance_operation_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter which balance_operation_history to delete.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history deleteMany
   */
  export type balance_operation_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balance_operation_histories to delete
     */
    where?: balance_operation_historyWhereInput
    /**
     * Limit how many balance_operation_histories to delete.
     */
    limit?: number
  }

  /**
   * balance_operation_history without action
   */
  export type balance_operation_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
  }


  /**
   * Model chat_conversations
   */

  export type AggregateChat_conversations = {
    _count: Chat_conversationsCountAggregateOutputType | null
    _avg: Chat_conversationsAvgAggregateOutputType | null
    _sum: Chat_conversationsSumAggregateOutputType | null
    _min: Chat_conversationsMinAggregateOutputType | null
    _max: Chat_conversationsMaxAggregateOutputType | null
  }

  export type Chat_conversationsAvgAggregateOutputType = {
    id: number | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsSumAggregateOutputType = {
    id: number | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    admin_id: string | null
    status: string | null
    priority: string | null
    subject: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    admin_id: string | null
    status: string | null
    priority: string | null
    subject: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsCountAggregateOutputType = {
    id: number
    user_id: number
    user_name: number
    user_email: number
    admin_id: number
    status: number
    priority: number
    subject: number
    last_message_at: number
    created_at: number
    updated_at: number
    closed_at: number
    closed_by: number
    tags: number
    unread_count_admin: number
    unread_count_user: number
    _all: number
  }


  export type Chat_conversationsAvgAggregateInputType = {
    id?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsSumAggregateInputType = {
    id?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsMinAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    admin_id?: true
    status?: true
    priority?: true
    subject?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
    closed_at?: true
    closed_by?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    admin_id?: true
    status?: true
    priority?: true
    subject?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
    closed_at?: true
    closed_by?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsCountAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    admin_id?: true
    status?: true
    priority?: true
    subject?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
    closed_at?: true
    closed_by?: true
    tags?: true
    unread_count_admin?: true
    unread_count_user?: true
    _all?: true
  }

  export type Chat_conversationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_conversations to aggregate.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_conversations
    **/
    _count?: true | Chat_conversationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_conversationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_conversationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_conversationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_conversationsMaxAggregateInputType
  }

  export type GetChat_conversationsAggregateType<T extends Chat_conversationsAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_conversations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_conversations[P]>
      : GetScalarType<T[P], AggregateChat_conversations[P]>
  }




  export type chat_conversationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_conversationsWhereInput
    orderBy?: chat_conversationsOrderByWithAggregationInput | chat_conversationsOrderByWithAggregationInput[]
    by: Chat_conversationsScalarFieldEnum[] | Chat_conversationsScalarFieldEnum
    having?: chat_conversationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_conversationsCountAggregateInputType | true
    _avg?: Chat_conversationsAvgAggregateInputType
    _sum?: Chat_conversationsSumAggregateInputType
    _min?: Chat_conversationsMinAggregateInputType
    _max?: Chat_conversationsMaxAggregateInputType
  }

  export type Chat_conversationsGroupByOutputType = {
    id: number
    user_id: string
    user_name: string
    user_email: string
    admin_id: string | null
    status: string | null
    priority: string | null
    subject: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    tags: string[]
    unread_count_admin: number | null
    unread_count_user: number | null
    _count: Chat_conversationsCountAggregateOutputType | null
    _avg: Chat_conversationsAvgAggregateOutputType | null
    _sum: Chat_conversationsSumAggregateOutputType | null
    _min: Chat_conversationsMinAggregateOutputType | null
    _max: Chat_conversationsMaxAggregateOutputType | null
  }

  type GetChat_conversationsGroupByPayload<T extends chat_conversationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_conversationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_conversationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_conversationsGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_conversationsGroupByOutputType[P]>
        }
      >
    >


  export type chat_conversationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
    chat_messages?: boolean | chat_conversations$chat_messagesArgs<ExtArgs>
    chat_participants?: boolean | chat_conversations$chat_participantsArgs<ExtArgs>
    _count?: boolean | Chat_conversationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat_conversations"]>

  export type chat_conversationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
  }, ExtArgs["result"]["chat_conversations"]>

  export type chat_conversationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
  }, ExtArgs["result"]["chat_conversations"]>

  export type chat_conversationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
  }

  export type chat_conversationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "user_name" | "user_email" | "admin_id" | "status" | "priority" | "subject" | "last_message_at" | "created_at" | "updated_at" | "closed_at" | "closed_by" | "tags" | "unread_count_admin" | "unread_count_user", ExtArgs["result"]["chat_conversations"]>
  export type chat_conversationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | chat_conversations$chat_messagesArgs<ExtArgs>
    chat_participants?: boolean | chat_conversations$chat_participantsArgs<ExtArgs>
    _count?: boolean | Chat_conversationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chat_conversationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type chat_conversationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $chat_conversationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_conversations"
    objects: {
      chat_messages: Prisma.$chat_messagesPayload<ExtArgs>[]
      chat_participants: Prisma.$chat_participantsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      user_name: string
      user_email: string
      admin_id: string | null
      status: string | null
      priority: string | null
      subject: string | null
      last_message_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      closed_at: Date | null
      closed_by: string | null
      tags: string[]
      unread_count_admin: number | null
      unread_count_user: number | null
    }, ExtArgs["result"]["chat_conversations"]>
    composites: {}
  }

  type chat_conversationsGetPayload<S extends boolean | null | undefined | chat_conversationsDefaultArgs> = $Result.GetResult<Prisma.$chat_conversationsPayload, S>

  type chat_conversationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_conversationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_conversationsCountAggregateInputType | true
    }

  export interface chat_conversationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_conversations'], meta: { name: 'chat_conversations' } }
    /**
     * Find zero or one Chat_conversations that matches the filter.
     * @param {chat_conversationsFindUniqueArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_conversationsFindUniqueArgs>(args: SelectSubset<T, chat_conversationsFindUniqueArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat_conversations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_conversationsFindUniqueOrThrowArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_conversationsFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_conversationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsFindFirstArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_conversationsFindFirstArgs>(args?: SelectSubset<T, chat_conversationsFindFirstArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_conversations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsFindFirstOrThrowArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_conversationsFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_conversationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chat_conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findMany()
     * 
     * // Get first 10 Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_conversationsWithIdOnly = await prisma.chat_conversations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_conversationsFindManyArgs>(args?: SelectSubset<T, chat_conversationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat_conversations.
     * @param {chat_conversationsCreateArgs} args - Arguments to create a Chat_conversations.
     * @example
     * // Create one Chat_conversations
     * const Chat_conversations = await prisma.chat_conversations.create({
     *   data: {
     *     // ... data to create a Chat_conversations
     *   }
     * })
     * 
     */
    create<T extends chat_conversationsCreateArgs>(args: SelectSubset<T, chat_conversationsCreateArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chat_conversations.
     * @param {chat_conversationsCreateManyArgs} args - Arguments to create many Chat_conversations.
     * @example
     * // Create many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_conversationsCreateManyArgs>(args?: SelectSubset<T, chat_conversationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_conversations and returns the data saved in the database.
     * @param {chat_conversationsCreateManyAndReturnArgs} args - Arguments to create many Chat_conversations.
     * @example
     * // Create many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_conversations and only return the `id`
     * const chat_conversationsWithIdOnly = await prisma.chat_conversations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_conversationsCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_conversationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat_conversations.
     * @param {chat_conversationsDeleteArgs} args - Arguments to delete one Chat_conversations.
     * @example
     * // Delete one Chat_conversations
     * const Chat_conversations = await prisma.chat_conversations.delete({
     *   where: {
     *     // ... filter to delete one Chat_conversations
     *   }
     * })
     * 
     */
    delete<T extends chat_conversationsDeleteArgs>(args: SelectSubset<T, chat_conversationsDeleteArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat_conversations.
     * @param {chat_conversationsUpdateArgs} args - Arguments to update one Chat_conversations.
     * @example
     * // Update one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_conversationsUpdateArgs>(args: SelectSubset<T, chat_conversationsUpdateArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chat_conversations.
     * @param {chat_conversationsDeleteManyArgs} args - Arguments to filter Chat_conversations to delete.
     * @example
     * // Delete a few Chat_conversations
     * const { count } = await prisma.chat_conversations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_conversationsDeleteManyArgs>(args?: SelectSubset<T, chat_conversationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_conversationsUpdateManyArgs>(args: SelectSubset<T, chat_conversationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_conversations and returns the data updated in the database.
     * @param {chat_conversationsUpdateManyAndReturnArgs} args - Arguments to update many Chat_conversations.
     * @example
     * // Update many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_conversations and only return the `id`
     * const chat_conversationsWithIdOnly = await prisma.chat_conversations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_conversationsUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_conversationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat_conversations.
     * @param {chat_conversationsUpsertArgs} args - Arguments to update or create a Chat_conversations.
     * @example
     * // Update or create a Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.upsert({
     *   create: {
     *     // ... data to create a Chat_conversations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_conversations we want to update
     *   }
     * })
     */
    upsert<T extends chat_conversationsUpsertArgs>(args: SelectSubset<T, chat_conversationsUpsertArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsCountArgs} args - Arguments to filter Chat_conversations to count.
     * @example
     * // Count the number of Chat_conversations
     * const count = await prisma.chat_conversations.count({
     *   where: {
     *     // ... the filter for the Chat_conversations we want to count
     *   }
     * })
    **/
    count<T extends chat_conversationsCountArgs>(
      args?: Subset<T, chat_conversationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_conversationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_conversationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_conversationsAggregateArgs>(args: Subset<T, Chat_conversationsAggregateArgs>): Prisma.PrismaPromise<GetChat_conversationsAggregateType<T>>

    /**
     * Group by Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_conversationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_conversationsGroupByArgs['orderBy'] }
        : { orderBy?: chat_conversationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_conversationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_conversationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_conversations model
   */
  readonly fields: chat_conversationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_conversations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_conversationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_messages<T extends chat_conversations$chat_messagesArgs<ExtArgs> = {}>(args?: Subset<T, chat_conversations$chat_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat_participants<T extends chat_conversations$chat_participantsArgs<ExtArgs> = {}>(args?: Subset<T, chat_conversations$chat_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_conversations model
   */
  interface chat_conversationsFieldRefs {
    readonly id: FieldRef<"chat_conversations", 'Int'>
    readonly user_id: FieldRef<"chat_conversations", 'String'>
    readonly user_name: FieldRef<"chat_conversations", 'String'>
    readonly user_email: FieldRef<"chat_conversations", 'String'>
    readonly admin_id: FieldRef<"chat_conversations", 'String'>
    readonly status: FieldRef<"chat_conversations", 'String'>
    readonly priority: FieldRef<"chat_conversations", 'String'>
    readonly subject: FieldRef<"chat_conversations", 'String'>
    readonly last_message_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly created_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly updated_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly closed_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly closed_by: FieldRef<"chat_conversations", 'String'>
    readonly tags: FieldRef<"chat_conversations", 'String[]'>
    readonly unread_count_admin: FieldRef<"chat_conversations", 'Int'>
    readonly unread_count_user: FieldRef<"chat_conversations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * chat_conversations findUnique
   */
  export type chat_conversationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations findUniqueOrThrow
   */
  export type chat_conversationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations findFirst
   */
  export type chat_conversationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_conversations.
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_conversations.
     */
    distinct?: Chat_conversationsScalarFieldEnum | Chat_conversationsScalarFieldEnum[]
  }

  /**
   * chat_conversations findFirstOrThrow
   */
  export type chat_conversationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_conversations.
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_conversations.
     */
    distinct?: Chat_conversationsScalarFieldEnum | Chat_conversationsScalarFieldEnum[]
  }

  /**
   * chat_conversations findMany
   */
  export type chat_conversationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_conversations.
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    distinct?: Chat_conversationsScalarFieldEnum | Chat_conversationsScalarFieldEnum[]
  }

  /**
   * chat_conversations create
   */
  export type chat_conversationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_conversations.
     */
    data: XOR<chat_conversationsCreateInput, chat_conversationsUncheckedCreateInput>
  }

  /**
   * chat_conversations createMany
   */
  export type chat_conversationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_conversations.
     */
    data: chat_conversationsCreateManyInput | chat_conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_conversations createManyAndReturn
   */
  export type chat_conversationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * The data used to create many chat_conversations.
     */
    data: chat_conversationsCreateManyInput | chat_conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_conversations update
   */
  export type chat_conversationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_conversations.
     */
    data: XOR<chat_conversationsUpdateInput, chat_conversationsUncheckedUpdateInput>
    /**
     * Choose, which chat_conversations to update.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations updateMany
   */
  export type chat_conversationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_conversations.
     */
    data: XOR<chat_conversationsUpdateManyMutationInput, chat_conversationsUncheckedUpdateManyInput>
    /**
     * Filter which chat_conversations to update
     */
    where?: chat_conversationsWhereInput
    /**
     * Limit how many chat_conversations to update.
     */
    limit?: number
  }

  /**
   * chat_conversations updateManyAndReturn
   */
  export type chat_conversationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * The data used to update chat_conversations.
     */
    data: XOR<chat_conversationsUpdateManyMutationInput, chat_conversationsUncheckedUpdateManyInput>
    /**
     * Filter which chat_conversations to update
     */
    where?: chat_conversationsWhereInput
    /**
     * Limit how many chat_conversations to update.
     */
    limit?: number
  }

  /**
   * chat_conversations upsert
   */
  export type chat_conversationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_conversations to update in case it exists.
     */
    where: chat_conversationsWhereUniqueInput
    /**
     * In case the chat_conversations found by the `where` argument doesn't exist, create a new chat_conversations with this data.
     */
    create: XOR<chat_conversationsCreateInput, chat_conversationsUncheckedCreateInput>
    /**
     * In case the chat_conversations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_conversationsUpdateInput, chat_conversationsUncheckedUpdateInput>
  }

  /**
   * chat_conversations delete
   */
  export type chat_conversationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter which chat_conversations to delete.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations deleteMany
   */
  export type chat_conversationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_conversations to delete
     */
    where?: chat_conversationsWhereInput
    /**
     * Limit how many chat_conversations to delete.
     */
    limit?: number
  }

  /**
   * chat_conversations.chat_messages
   */
  export type chat_conversations$chat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    cursor?: chat_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_conversations.chat_participants
   */
  export type chat_conversations$chat_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    where?: chat_participantsWhereInput
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    cursor?: chat_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_conversations without action
   */
  export type chat_conversationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
  }


  /**
   * Model chat_messages
   */

  export type AggregateChat_messages = {
    _count: Chat_messagesCountAggregateOutputType | null
    _avg: Chat_messagesAvgAggregateOutputType | null
    _sum: Chat_messagesSumAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  export type Chat_messagesAvgAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_messagesSumAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_messagesMinAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    message_type: string | null
    content: string | null
    is_read: boolean | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Chat_messagesMaxAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    message_type: string | null
    content: string | null
    is_read: boolean | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Chat_messagesCountAggregateOutputType = {
    id: number
    conversation_id: number
    sender_id: number
    sender_name: number
    sender_type: number
    message_type: number
    content: number
    metadata: number
    is_read: number
    read_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Chat_messagesAvgAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_messagesSumAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_messagesMinAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    message_type?: true
    content?: true
    is_read?: true
    read_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Chat_messagesMaxAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    message_type?: true
    content?: true
    is_read?: true
    read_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Chat_messagesCountAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    message_type?: true
    content?: true
    metadata?: true
    is_read?: true
    read_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Chat_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to aggregate.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_messages
    **/
    _count?: true | Chat_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_messagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_messagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type GetChat_messagesAggregateType<T extends Chat_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_messages[P]>
      : GetScalarType<T[P], AggregateChat_messages[P]>
  }




  export type chat_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithAggregationInput | chat_messagesOrderByWithAggregationInput[]
    by: Chat_messagesScalarFieldEnum[] | Chat_messagesScalarFieldEnum
    having?: chat_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_messagesCountAggregateInputType | true
    _avg?: Chat_messagesAvgAggregateInputType
    _sum?: Chat_messagesSumAggregateInputType
    _min?: Chat_messagesMinAggregateInputType
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type Chat_messagesGroupByOutputType = {
    id: number
    conversation_id: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    message_type: string | null
    content: string
    metadata: JsonValue | null
    is_read: boolean | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Chat_messagesCountAggregateOutputType | null
    _avg: Chat_messagesAvgAggregateOutputType | null
    _sum: Chat_messagesSumAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  type GetChat_messagesGroupByPayload<T extends chat_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
        }
      >
    >


  export type chat_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectScalar = {
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type chat_messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversation_id" | "sender_id" | "sender_name" | "sender_type" | "message_type" | "content" | "metadata" | "is_read" | "read_at" | "created_at" | "updated_at", ExtArgs["result"]["chat_messages"]>
  export type chat_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }
  export type chat_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }
  export type chat_messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }

  export type $chat_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_messages"
    objects: {
      chat_conversations: Prisma.$chat_conversationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversation_id: number | null
      sender_id: string
      sender_name: string
      sender_type: string
      message_type: string | null
      content: string
      metadata: Prisma.JsonValue | null
      is_read: boolean | null
      read_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["chat_messages"]>
    composites: {}
  }

  type chat_messagesGetPayload<S extends boolean | null | undefined | chat_messagesDefaultArgs> = $Result.GetResult<Prisma.$chat_messagesPayload, S>

  type chat_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_messagesCountAggregateInputType | true
    }

  export interface chat_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_messages'], meta: { name: 'chat_messages' } }
    /**
     * Find zero or one Chat_messages that matches the filter.
     * @param {chat_messagesFindUniqueArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_messagesFindUniqueArgs>(args: SelectSubset<T, chat_messagesFindUniqueArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat_messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_messagesFindUniqueOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_messagesFindFirstArgs>(args?: SelectSubset<T, chat_messagesFindFirstArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany()
     * 
     * // Get first 10 Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_messagesFindManyArgs>(args?: SelectSubset<T, chat_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat_messages.
     * @param {chat_messagesCreateArgs} args - Arguments to create a Chat_messages.
     * @example
     * // Create one Chat_messages
     * const Chat_messages = await prisma.chat_messages.create({
     *   data: {
     *     // ... data to create a Chat_messages
     *   }
     * })
     * 
     */
    create<T extends chat_messagesCreateArgs>(args: SelectSubset<T, chat_messagesCreateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chat_messages.
     * @param {chat_messagesCreateManyArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_messagesCreateManyArgs>(args?: SelectSubset<T, chat_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_messages and returns the data saved in the database.
     * @param {chat_messagesCreateManyAndReturnArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat_messages.
     * @param {chat_messagesDeleteArgs} args - Arguments to delete one Chat_messages.
     * @example
     * // Delete one Chat_messages
     * const Chat_messages = await prisma.chat_messages.delete({
     *   where: {
     *     // ... filter to delete one Chat_messages
     *   }
     * })
     * 
     */
    delete<T extends chat_messagesDeleteArgs>(args: SelectSubset<T, chat_messagesDeleteArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat_messages.
     * @param {chat_messagesUpdateArgs} args - Arguments to update one Chat_messages.
     * @example
     * // Update one Chat_messages
     * const chat_messages = await prisma.chat_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_messagesUpdateArgs>(args: SelectSubset<T, chat_messagesUpdateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chat_messages.
     * @param {chat_messagesDeleteManyArgs} args - Arguments to filter Chat_messages to delete.
     * @example
     * // Delete a few Chat_messages
     * const { count } = await prisma.chat_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_messagesDeleteManyArgs>(args?: SelectSubset<T, chat_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_messagesUpdateManyArgs>(args: SelectSubset<T, chat_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages and returns the data updated in the database.
     * @param {chat_messagesUpdateManyAndReturnArgs} args - Arguments to update many Chat_messages.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat_messages.
     * @param {chat_messagesUpsertArgs} args - Arguments to update or create a Chat_messages.
     * @example
     * // Update or create a Chat_messages
     * const chat_messages = await prisma.chat_messages.upsert({
     *   create: {
     *     // ... data to create a Chat_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_messages we want to update
     *   }
     * })
     */
    upsert<T extends chat_messagesUpsertArgs>(args: SelectSubset<T, chat_messagesUpsertArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesCountArgs} args - Arguments to filter Chat_messages to count.
     * @example
     * // Count the number of Chat_messages
     * const count = await prisma.chat_messages.count({
     *   where: {
     *     // ... the filter for the Chat_messages we want to count
     *   }
     * })
    **/
    count<T extends chat_messagesCountArgs>(
      args?: Subset<T, chat_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_messagesAggregateArgs>(args: Subset<T, Chat_messagesAggregateArgs>): Prisma.PrismaPromise<GetChat_messagesAggregateType<T>>

    /**
     * Group by Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_messagesGroupByArgs['orderBy'] }
        : { orderBy?: chat_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_messages model
   */
  readonly fields: chat_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_conversations<T extends chat_messages$chat_conversationsArgs<ExtArgs> = {}>(args?: Subset<T, chat_messages$chat_conversationsArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_messages model
   */
  interface chat_messagesFieldRefs {
    readonly id: FieldRef<"chat_messages", 'Int'>
    readonly conversation_id: FieldRef<"chat_messages", 'Int'>
    readonly sender_id: FieldRef<"chat_messages", 'String'>
    readonly sender_name: FieldRef<"chat_messages", 'String'>
    readonly sender_type: FieldRef<"chat_messages", 'String'>
    readonly message_type: FieldRef<"chat_messages", 'String'>
    readonly content: FieldRef<"chat_messages", 'String'>
    readonly metadata: FieldRef<"chat_messages", 'Json'>
    readonly is_read: FieldRef<"chat_messages", 'Boolean'>
    readonly read_at: FieldRef<"chat_messages", 'DateTime'>
    readonly created_at: FieldRef<"chat_messages", 'DateTime'>
    readonly updated_at: FieldRef<"chat_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chat_messages findUnique
   */
  export type chat_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findUniqueOrThrow
   */
  export type chat_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findFirst
   */
  export type chat_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findFirstOrThrow
   */
  export type chat_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findMany
   */
  export type chat_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages create
   */
  export type chat_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_messages.
     */
    data: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
  }

  /**
   * chat_messages createMany
   */
  export type chat_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_messages createManyAndReturn
   */
  export type chat_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages update
   */
  export type chat_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_messages.
     */
    data: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
    /**
     * Choose, which chat_messages to update.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages updateMany
   */
  export type chat_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to update.
     */
    limit?: number
  }

  /**
   * chat_messages updateManyAndReturn
   */
  export type chat_messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages upsert
   */
  export type chat_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_messages to update in case it exists.
     */
    where: chat_messagesWhereUniqueInput
    /**
     * In case the chat_messages found by the `where` argument doesn't exist, create a new chat_messages with this data.
     */
    create: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
    /**
     * In case the chat_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
  }

  /**
   * chat_messages delete
   */
  export type chat_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter which chat_messages to delete.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages deleteMany
   */
  export type chat_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to delete
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to delete.
     */
    limit?: number
  }

  /**
   * chat_messages.chat_conversations
   */
  export type chat_messages$chat_conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    where?: chat_conversationsWhereInput
  }

  /**
   * chat_messages without action
   */
  export type chat_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
  }


  /**
   * Model chat_participants
   */

  export type AggregateChat_participants = {
    _count: Chat_participantsCountAggregateOutputType | null
    _avg: Chat_participantsAvgAggregateOutputType | null
    _sum: Chat_participantsSumAggregateOutputType | null
    _min: Chat_participantsMinAggregateOutputType | null
    _max: Chat_participantsMaxAggregateOutputType | null
  }

  export type Chat_participantsAvgAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_participantsSumAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_participantsMinAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    user_id: string | null
    user_name: string | null
    user_type: string | null
    role: string | null
    joined_at: Date | null
    left_at: Date | null
    is_active: boolean | null
  }

  export type Chat_participantsMaxAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    user_id: string | null
    user_name: string | null
    user_type: string | null
    role: string | null
    joined_at: Date | null
    left_at: Date | null
    is_active: boolean | null
  }

  export type Chat_participantsCountAggregateOutputType = {
    id: number
    conversation_id: number
    user_id: number
    user_name: number
    user_type: number
    role: number
    joined_at: number
    left_at: number
    is_active: number
    _all: number
  }


  export type Chat_participantsAvgAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_participantsSumAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_participantsMinAggregateInputType = {
    id?: true
    conversation_id?: true
    user_id?: true
    user_name?: true
    user_type?: true
    role?: true
    joined_at?: true
    left_at?: true
    is_active?: true
  }

  export type Chat_participantsMaxAggregateInputType = {
    id?: true
    conversation_id?: true
    user_id?: true
    user_name?: true
    user_type?: true
    role?: true
    joined_at?: true
    left_at?: true
    is_active?: true
  }

  export type Chat_participantsCountAggregateInputType = {
    id?: true
    conversation_id?: true
    user_id?: true
    user_name?: true
    user_type?: true
    role?: true
    joined_at?: true
    left_at?: true
    is_active?: true
    _all?: true
  }

  export type Chat_participantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_participants to aggregate.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_participants
    **/
    _count?: true | Chat_participantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_participantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_participantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_participantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_participantsMaxAggregateInputType
  }

  export type GetChat_participantsAggregateType<T extends Chat_participantsAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_participants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_participants[P]>
      : GetScalarType<T[P], AggregateChat_participants[P]>
  }




  export type chat_participantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_participantsWhereInput
    orderBy?: chat_participantsOrderByWithAggregationInput | chat_participantsOrderByWithAggregationInput[]
    by: Chat_participantsScalarFieldEnum[] | Chat_participantsScalarFieldEnum
    having?: chat_participantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_participantsCountAggregateInputType | true
    _avg?: Chat_participantsAvgAggregateInputType
    _sum?: Chat_participantsSumAggregateInputType
    _min?: Chat_participantsMinAggregateInputType
    _max?: Chat_participantsMaxAggregateInputType
  }

  export type Chat_participantsGroupByOutputType = {
    id: number
    conversation_id: number | null
    user_id: string
    user_name: string
    user_type: string
    role: string | null
    joined_at: Date | null
    left_at: Date | null
    is_active: boolean | null
    _count: Chat_participantsCountAggregateOutputType | null
    _avg: Chat_participantsAvgAggregateOutputType | null
    _sum: Chat_participantsSumAggregateOutputType | null
    _min: Chat_participantsMinAggregateOutputType | null
    _max: Chat_participantsMaxAggregateOutputType | null
  }

  type GetChat_participantsGroupByPayload<T extends chat_participantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_participantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_participantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_participantsGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_participantsGroupByOutputType[P]>
        }
      >
    >


  export type chat_participantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_participants"]>

  export type chat_participantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_participants"]>

  export type chat_participantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_participants"]>

  export type chat_participantsSelectScalar = {
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
  }

  export type chat_participantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversation_id" | "user_id" | "user_name" | "user_type" | "role" | "joined_at" | "left_at" | "is_active", ExtArgs["result"]["chat_participants"]>
  export type chat_participantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }
  export type chat_participantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }
  export type chat_participantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }

  export type $chat_participantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_participants"
    objects: {
      chat_conversations: Prisma.$chat_conversationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversation_id: number | null
      user_id: string
      user_name: string
      user_type: string
      role: string | null
      joined_at: Date | null
      left_at: Date | null
      is_active: boolean | null
    }, ExtArgs["result"]["chat_participants"]>
    composites: {}
  }

  type chat_participantsGetPayload<S extends boolean | null | undefined | chat_participantsDefaultArgs> = $Result.GetResult<Prisma.$chat_participantsPayload, S>

  type chat_participantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_participantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_participantsCountAggregateInputType | true
    }

  export interface chat_participantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_participants'], meta: { name: 'chat_participants' } }
    /**
     * Find zero or one Chat_participants that matches the filter.
     * @param {chat_participantsFindUniqueArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_participantsFindUniqueArgs>(args: SelectSubset<T, chat_participantsFindUniqueArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat_participants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_participantsFindUniqueOrThrowArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_participantsFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_participantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsFindFirstArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_participantsFindFirstArgs>(args?: SelectSubset<T, chat_participantsFindFirstArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_participants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsFindFirstOrThrowArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_participantsFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_participantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chat_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_participants
     * const chat_participants = await prisma.chat_participants.findMany()
     * 
     * // Get first 10 Chat_participants
     * const chat_participants = await prisma.chat_participants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_participantsWithIdOnly = await prisma.chat_participants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_participantsFindManyArgs>(args?: SelectSubset<T, chat_participantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat_participants.
     * @param {chat_participantsCreateArgs} args - Arguments to create a Chat_participants.
     * @example
     * // Create one Chat_participants
     * const Chat_participants = await prisma.chat_participants.create({
     *   data: {
     *     // ... data to create a Chat_participants
     *   }
     * })
     * 
     */
    create<T extends chat_participantsCreateArgs>(args: SelectSubset<T, chat_participantsCreateArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chat_participants.
     * @param {chat_participantsCreateManyArgs} args - Arguments to create many Chat_participants.
     * @example
     * // Create many Chat_participants
     * const chat_participants = await prisma.chat_participants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_participantsCreateManyArgs>(args?: SelectSubset<T, chat_participantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_participants and returns the data saved in the database.
     * @param {chat_participantsCreateManyAndReturnArgs} args - Arguments to create many Chat_participants.
     * @example
     * // Create many Chat_participants
     * const chat_participants = await prisma.chat_participants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_participants and only return the `id`
     * const chat_participantsWithIdOnly = await prisma.chat_participants.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_participantsCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_participantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat_participants.
     * @param {chat_participantsDeleteArgs} args - Arguments to delete one Chat_participants.
     * @example
     * // Delete one Chat_participants
     * const Chat_participants = await prisma.chat_participants.delete({
     *   where: {
     *     // ... filter to delete one Chat_participants
     *   }
     * })
     * 
     */
    delete<T extends chat_participantsDeleteArgs>(args: SelectSubset<T, chat_participantsDeleteArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat_participants.
     * @param {chat_participantsUpdateArgs} args - Arguments to update one Chat_participants.
     * @example
     * // Update one Chat_participants
     * const chat_participants = await prisma.chat_participants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_participantsUpdateArgs>(args: SelectSubset<T, chat_participantsUpdateArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chat_participants.
     * @param {chat_participantsDeleteManyArgs} args - Arguments to filter Chat_participants to delete.
     * @example
     * // Delete a few Chat_participants
     * const { count } = await prisma.chat_participants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_participantsDeleteManyArgs>(args?: SelectSubset<T, chat_participantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_participants
     * const chat_participants = await prisma.chat_participants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_participantsUpdateManyArgs>(args: SelectSubset<T, chat_participantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_participants and returns the data updated in the database.
     * @param {chat_participantsUpdateManyAndReturnArgs} args - Arguments to update many Chat_participants.
     * @example
     * // Update many Chat_participants
     * const chat_participants = await prisma.chat_participants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_participants and only return the `id`
     * const chat_participantsWithIdOnly = await prisma.chat_participants.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_participantsUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_participantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat_participants.
     * @param {chat_participantsUpsertArgs} args - Arguments to update or create a Chat_participants.
     * @example
     * // Update or create a Chat_participants
     * const chat_participants = await prisma.chat_participants.upsert({
     *   create: {
     *     // ... data to create a Chat_participants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_participants we want to update
     *   }
     * })
     */
    upsert<T extends chat_participantsUpsertArgs>(args: SelectSubset<T, chat_participantsUpsertArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsCountArgs} args - Arguments to filter Chat_participants to count.
     * @example
     * // Count the number of Chat_participants
     * const count = await prisma.chat_participants.count({
     *   where: {
     *     // ... the filter for the Chat_participants we want to count
     *   }
     * })
    **/
    count<T extends chat_participantsCountArgs>(
      args?: Subset<T, chat_participantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_participantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_participantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_participantsAggregateArgs>(args: Subset<T, Chat_participantsAggregateArgs>): Prisma.PrismaPromise<GetChat_participantsAggregateType<T>>

    /**
     * Group by Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_participantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_participantsGroupByArgs['orderBy'] }
        : { orderBy?: chat_participantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_participantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_participantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_participants model
   */
  readonly fields: chat_participantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_participants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_participantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_conversations<T extends chat_participants$chat_conversationsArgs<ExtArgs> = {}>(args?: Subset<T, chat_participants$chat_conversationsArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_participants model
   */
  interface chat_participantsFieldRefs {
    readonly id: FieldRef<"chat_participants", 'Int'>
    readonly conversation_id: FieldRef<"chat_participants", 'Int'>
    readonly user_id: FieldRef<"chat_participants", 'String'>
    readonly user_name: FieldRef<"chat_participants", 'String'>
    readonly user_type: FieldRef<"chat_participants", 'String'>
    readonly role: FieldRef<"chat_participants", 'String'>
    readonly joined_at: FieldRef<"chat_participants", 'DateTime'>
    readonly left_at: FieldRef<"chat_participants", 'DateTime'>
    readonly is_active: FieldRef<"chat_participants", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * chat_participants findUnique
   */
  export type chat_participantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants findUniqueOrThrow
   */
  export type chat_participantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants findFirst
   */
  export type chat_participantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_participants.
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_participants.
     */
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_participants findFirstOrThrow
   */
  export type chat_participantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_participants.
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_participants.
     */
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_participants findMany
   */
  export type chat_participantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_participants.
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_participants create
   */
  export type chat_participantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_participants.
     */
    data: XOR<chat_participantsCreateInput, chat_participantsUncheckedCreateInput>
  }

  /**
   * chat_participants createMany
   */
  export type chat_participantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_participants.
     */
    data: chat_participantsCreateManyInput | chat_participantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_participants createManyAndReturn
   */
  export type chat_participantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * The data used to create many chat_participants.
     */
    data: chat_participantsCreateManyInput | chat_participantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_participants update
   */
  export type chat_participantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_participants.
     */
    data: XOR<chat_participantsUpdateInput, chat_participantsUncheckedUpdateInput>
    /**
     * Choose, which chat_participants to update.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants updateMany
   */
  export type chat_participantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_participants.
     */
    data: XOR<chat_participantsUpdateManyMutationInput, chat_participantsUncheckedUpdateManyInput>
    /**
     * Filter which chat_participants to update
     */
    where?: chat_participantsWhereInput
    /**
     * Limit how many chat_participants to update.
     */
    limit?: number
  }

  /**
   * chat_participants updateManyAndReturn
   */
  export type chat_participantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * The data used to update chat_participants.
     */
    data: XOR<chat_participantsUpdateManyMutationInput, chat_participantsUncheckedUpdateManyInput>
    /**
     * Filter which chat_participants to update
     */
    where?: chat_participantsWhereInput
    /**
     * Limit how many chat_participants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_participants upsert
   */
  export type chat_participantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_participants to update in case it exists.
     */
    where: chat_participantsWhereUniqueInput
    /**
     * In case the chat_participants found by the `where` argument doesn't exist, create a new chat_participants with this data.
     */
    create: XOR<chat_participantsCreateInput, chat_participantsUncheckedCreateInput>
    /**
     * In case the chat_participants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_participantsUpdateInput, chat_participantsUncheckedUpdateInput>
  }

  /**
   * chat_participants delete
   */
  export type chat_participantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter which chat_participants to delete.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants deleteMany
   */
  export type chat_participantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_participants to delete
     */
    where?: chat_participantsWhereInput
    /**
     * Limit how many chat_participants to delete.
     */
    limit?: number
  }

  /**
   * chat_participants.chat_conversations
   */
  export type chat_participants$chat_conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    where?: chat_conversationsWhereInput
  }

  /**
   * chat_participants without action
   */
  export type chat_participantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
  }


  /**
   * Model group_commission_structures
   */

  export type AggregateGroup_commission_structures = {
    _count: Group_commission_structuresCountAggregateOutputType | null
    _avg: Group_commission_structuresAvgAggregateOutputType | null
    _sum: Group_commission_structuresSumAggregateOutputType | null
    _min: Group_commission_structuresMinAggregateOutputType | null
    _max: Group_commission_structuresMaxAggregateOutputType | null
  }

  export type Group_commission_structuresAvgAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
  }

  export type Group_commission_structuresSumAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
  }

  export type Group_commission_structuresMinAggregateOutputType = {
    id: number | null
    group_id: string | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Group_commission_structuresMaxAggregateOutputType = {
    id: number | null
    group_id: string | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Group_commission_structuresCountAggregateOutputType = {
    id: number
    group_id: number
    structure_name: number
    usd_per_lot: number
    spread_share_percentage: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Group_commission_structuresAvgAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
  }

  export type Group_commission_structuresSumAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
  }

  export type Group_commission_structuresMinAggregateInputType = {
    id?: true
    group_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Group_commission_structuresMaxAggregateInputType = {
    id?: true
    group_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Group_commission_structuresCountAggregateInputType = {
    id?: true
    group_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Group_commission_structuresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_commission_structures to aggregate.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned group_commission_structures
    **/
    _count?: true | Group_commission_structuresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Group_commission_structuresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Group_commission_structuresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Group_commission_structuresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Group_commission_structuresMaxAggregateInputType
  }

  export type GetGroup_commission_structuresAggregateType<T extends Group_commission_structuresAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup_commission_structures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup_commission_structures[P]>
      : GetScalarType<T[P], AggregateGroup_commission_structures[P]>
  }




  export type group_commission_structuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_commission_structuresWhereInput
    orderBy?: group_commission_structuresOrderByWithAggregationInput | group_commission_structuresOrderByWithAggregationInput[]
    by: Group_commission_structuresScalarFieldEnum[] | Group_commission_structuresScalarFieldEnum
    having?: group_commission_structuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Group_commission_structuresCountAggregateInputType | true
    _avg?: Group_commission_structuresAvgAggregateInputType
    _sum?: Group_commission_structuresSumAggregateInputType
    _min?: Group_commission_structuresMinAggregateInputType
    _max?: Group_commission_structuresMaxAggregateInputType
  }

  export type Group_commission_structuresGroupByOutputType = {
    id: number
    group_id: string
    structure_name: string
    usd_per_lot: Decimal
    spread_share_percentage: Decimal
    is_active: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: Group_commission_structuresCountAggregateOutputType | null
    _avg: Group_commission_structuresAvgAggregateOutputType | null
    _sum: Group_commission_structuresSumAggregateOutputType | null
    _min: Group_commission_structuresMinAggregateOutputType | null
    _max: Group_commission_structuresMaxAggregateOutputType | null
  }

  type GetGroup_commission_structuresGroupByPayload<T extends group_commission_structuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Group_commission_structuresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Group_commission_structuresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Group_commission_structuresGroupByOutputType[P]>
            : GetScalarType<T[P], Group_commission_structuresGroupByOutputType[P]>
        }
      >
    >


  export type group_commission_structuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["group_commission_structures"]>

  export type group_commission_structuresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["group_commission_structures"]>

  export type group_commission_structuresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["group_commission_structures"]>

  export type group_commission_structuresSelectScalar = {
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type group_commission_structuresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "group_id" | "structure_name" | "usd_per_lot" | "spread_share_percentage" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["group_commission_structures"]>

  export type $group_commission_structuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group_commission_structures"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      group_id: string
      structure_name: string
      usd_per_lot: Prisma.Decimal
      spread_share_percentage: Prisma.Decimal
      is_active: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["group_commission_structures"]>
    composites: {}
  }

  type group_commission_structuresGetPayload<S extends boolean | null | undefined | group_commission_structuresDefaultArgs> = $Result.GetResult<Prisma.$group_commission_structuresPayload, S>

  type group_commission_structuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<group_commission_structuresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Group_commission_structuresCountAggregateInputType | true
    }

  export interface group_commission_structuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group_commission_structures'], meta: { name: 'group_commission_structures' } }
    /**
     * Find zero or one Group_commission_structures that matches the filter.
     * @param {group_commission_structuresFindUniqueArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends group_commission_structuresFindUniqueArgs>(args: SelectSubset<T, group_commission_structuresFindUniqueArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group_commission_structures that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {group_commission_structuresFindUniqueOrThrowArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends group_commission_structuresFindUniqueOrThrowArgs>(args: SelectSubset<T, group_commission_structuresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_commission_structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresFindFirstArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends group_commission_structuresFindFirstArgs>(args?: SelectSubset<T, group_commission_structuresFindFirstArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_commission_structures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresFindFirstOrThrowArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends group_commission_structuresFindFirstOrThrowArgs>(args?: SelectSubset<T, group_commission_structuresFindFirstOrThrowArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Group_commission_structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findMany()
     * 
     * // Get first 10 Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const group_commission_structuresWithIdOnly = await prisma.group_commission_structures.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends group_commission_structuresFindManyArgs>(args?: SelectSubset<T, group_commission_structuresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group_commission_structures.
     * @param {group_commission_structuresCreateArgs} args - Arguments to create a Group_commission_structures.
     * @example
     * // Create one Group_commission_structures
     * const Group_commission_structures = await prisma.group_commission_structures.create({
     *   data: {
     *     // ... data to create a Group_commission_structures
     *   }
     * })
     * 
     */
    create<T extends group_commission_structuresCreateArgs>(args: SelectSubset<T, group_commission_structuresCreateArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Group_commission_structures.
     * @param {group_commission_structuresCreateManyArgs} args - Arguments to create many Group_commission_structures.
     * @example
     * // Create many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends group_commission_structuresCreateManyArgs>(args?: SelectSubset<T, group_commission_structuresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Group_commission_structures and returns the data saved in the database.
     * @param {group_commission_structuresCreateManyAndReturnArgs} args - Arguments to create many Group_commission_structures.
     * @example
     * // Create many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Group_commission_structures and only return the `id`
     * const group_commission_structuresWithIdOnly = await prisma.group_commission_structures.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends group_commission_structuresCreateManyAndReturnArgs>(args?: SelectSubset<T, group_commission_structuresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group_commission_structures.
     * @param {group_commission_structuresDeleteArgs} args - Arguments to delete one Group_commission_structures.
     * @example
     * // Delete one Group_commission_structures
     * const Group_commission_structures = await prisma.group_commission_structures.delete({
     *   where: {
     *     // ... filter to delete one Group_commission_structures
     *   }
     * })
     * 
     */
    delete<T extends group_commission_structuresDeleteArgs>(args: SelectSubset<T, group_commission_structuresDeleteArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group_commission_structures.
     * @param {group_commission_structuresUpdateArgs} args - Arguments to update one Group_commission_structures.
     * @example
     * // Update one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends group_commission_structuresUpdateArgs>(args: SelectSubset<T, group_commission_structuresUpdateArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Group_commission_structures.
     * @param {group_commission_structuresDeleteManyArgs} args - Arguments to filter Group_commission_structures to delete.
     * @example
     * // Delete a few Group_commission_structures
     * const { count } = await prisma.group_commission_structures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends group_commission_structuresDeleteManyArgs>(args?: SelectSubset<T, group_commission_structuresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends group_commission_structuresUpdateManyArgs>(args: SelectSubset<T, group_commission_structuresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_commission_structures and returns the data updated in the database.
     * @param {group_commission_structuresUpdateManyAndReturnArgs} args - Arguments to update many Group_commission_structures.
     * @example
     * // Update many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Group_commission_structures and only return the `id`
     * const group_commission_structuresWithIdOnly = await prisma.group_commission_structures.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends group_commission_structuresUpdateManyAndReturnArgs>(args: SelectSubset<T, group_commission_structuresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group_commission_structures.
     * @param {group_commission_structuresUpsertArgs} args - Arguments to update or create a Group_commission_structures.
     * @example
     * // Update or create a Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.upsert({
     *   create: {
     *     // ... data to create a Group_commission_structures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group_commission_structures we want to update
     *   }
     * })
     */
    upsert<T extends group_commission_structuresUpsertArgs>(args: SelectSubset<T, group_commission_structuresUpsertArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresCountArgs} args - Arguments to filter Group_commission_structures to count.
     * @example
     * // Count the number of Group_commission_structures
     * const count = await prisma.group_commission_structures.count({
     *   where: {
     *     // ... the filter for the Group_commission_structures we want to count
     *   }
     * })
    **/
    count<T extends group_commission_structuresCountArgs>(
      args?: Subset<T, group_commission_structuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Group_commission_structuresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Group_commission_structuresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Group_commission_structuresAggregateArgs>(args: Subset<T, Group_commission_structuresAggregateArgs>): Prisma.PrismaPromise<GetGroup_commission_structuresAggregateType<T>>

    /**
     * Group by Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends group_commission_structuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: group_commission_structuresGroupByArgs['orderBy'] }
        : { orderBy?: group_commission_structuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, group_commission_structuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroup_commission_structuresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group_commission_structures model
   */
  readonly fields: group_commission_structuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group_commission_structures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__group_commission_structuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group_commission_structures model
   */
  interface group_commission_structuresFieldRefs {
    readonly id: FieldRef<"group_commission_structures", 'Int'>
    readonly group_id: FieldRef<"group_commission_structures", 'String'>
    readonly structure_name: FieldRef<"group_commission_structures", 'String'>
    readonly usd_per_lot: FieldRef<"group_commission_structures", 'Decimal'>
    readonly spread_share_percentage: FieldRef<"group_commission_structures", 'Decimal'>
    readonly is_active: FieldRef<"group_commission_structures", 'Boolean'>
    readonly created_at: FieldRef<"group_commission_structures", 'DateTime'>
    readonly updated_at: FieldRef<"group_commission_structures", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * group_commission_structures findUnique
   */
  export type group_commission_structuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures findUniqueOrThrow
   */
  export type group_commission_structuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures findFirst
   */
  export type group_commission_structuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_commission_structures.
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_commission_structures.
     */
    distinct?: Group_commission_structuresScalarFieldEnum | Group_commission_structuresScalarFieldEnum[]
  }

  /**
   * group_commission_structures findFirstOrThrow
   */
  export type group_commission_structuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_commission_structures.
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_commission_structures.
     */
    distinct?: Group_commission_structuresScalarFieldEnum | Group_commission_structuresScalarFieldEnum[]
  }

  /**
   * group_commission_structures findMany
   */
  export type group_commission_structuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing group_commission_structures.
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    distinct?: Group_commission_structuresScalarFieldEnum | Group_commission_structuresScalarFieldEnum[]
  }

  /**
   * group_commission_structures create
   */
  export type group_commission_structuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data needed to create a group_commission_structures.
     */
    data: XOR<group_commission_structuresCreateInput, group_commission_structuresUncheckedCreateInput>
  }

  /**
   * group_commission_structures createMany
   */
  export type group_commission_structuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many group_commission_structures.
     */
    data: group_commission_structuresCreateManyInput | group_commission_structuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_commission_structures createManyAndReturn
   */
  export type group_commission_structuresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data used to create many group_commission_structures.
     */
    data: group_commission_structuresCreateManyInput | group_commission_structuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_commission_structures update
   */
  export type group_commission_structuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data needed to update a group_commission_structures.
     */
    data: XOR<group_commission_structuresUpdateInput, group_commission_structuresUncheckedUpdateInput>
    /**
     * Choose, which group_commission_structures to update.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures updateMany
   */
  export type group_commission_structuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update group_commission_structures.
     */
    data: XOR<group_commission_structuresUpdateManyMutationInput, group_commission_structuresUncheckedUpdateManyInput>
    /**
     * Filter which group_commission_structures to update
     */
    where?: group_commission_structuresWhereInput
    /**
     * Limit how many group_commission_structures to update.
     */
    limit?: number
  }

  /**
   * group_commission_structures updateManyAndReturn
   */
  export type group_commission_structuresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data used to update group_commission_structures.
     */
    data: XOR<group_commission_structuresUpdateManyMutationInput, group_commission_structuresUncheckedUpdateManyInput>
    /**
     * Filter which group_commission_structures to update
     */
    where?: group_commission_structuresWhereInput
    /**
     * Limit how many group_commission_structures to update.
     */
    limit?: number
  }

  /**
   * group_commission_structures upsert
   */
  export type group_commission_structuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The filter to search for the group_commission_structures to update in case it exists.
     */
    where: group_commission_structuresWhereUniqueInput
    /**
     * In case the group_commission_structures found by the `where` argument doesn't exist, create a new group_commission_structures with this data.
     */
    create: XOR<group_commission_structuresCreateInput, group_commission_structuresUncheckedCreateInput>
    /**
     * In case the group_commission_structures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<group_commission_structuresUpdateInput, group_commission_structuresUncheckedUpdateInput>
  }

  /**
   * group_commission_structures delete
   */
  export type group_commission_structuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter which group_commission_structures to delete.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures deleteMany
   */
  export type group_commission_structuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_commission_structures to delete
     */
    where?: group_commission_structuresWhereInput
    /**
     * Limit how many group_commission_structures to delete.
     */
    limit?: number
  }

  /**
   * group_commission_structures without action
   */
  export type group_commission_structuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
  }


  /**
   * Model ib_admin
   */

  export type AggregateIb_admin = {
    _count: Ib_adminCountAggregateOutputType | null
    _avg: Ib_adminAvgAggregateOutputType | null
    _sum: Ib_adminSumAggregateOutputType | null
    _min: Ib_adminMinAggregateOutputType | null
    _max: Ib_adminMaxAggregateOutputType | null
  }

  export type Ib_adminAvgAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type Ib_adminSumAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type Ib_adminMinAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_adminMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_adminCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    role: number
    is_active: number
    last_login: number
    login_attempts: number
    locked_until: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ib_adminAvgAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type Ib_adminSumAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type Ib_adminMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_adminMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_adminCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ib_adminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_admin to aggregate.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_admins
    **/
    _count?: true | Ib_adminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_adminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_adminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_adminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_adminMaxAggregateInputType
  }

  export type GetIb_adminAggregateType<T extends Ib_adminAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_admin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_admin[P]>
      : GetScalarType<T[P], AggregateIb_admin[P]>
  }




  export type ib_adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_adminWhereInput
    orderBy?: ib_adminOrderByWithAggregationInput | ib_adminOrderByWithAggregationInput[]
    by: Ib_adminScalarFieldEnum[] | Ib_adminScalarFieldEnum
    having?: ib_adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_adminCountAggregateInputType | true
    _avg?: Ib_adminAvgAggregateInputType
    _sum?: Ib_adminSumAggregateInputType
    _min?: Ib_adminMinAggregateInputType
    _max?: Ib_adminMaxAggregateInputType
  }

  export type Ib_adminGroupByOutputType = {
    id: number
    email: string
    password_hash: string
    role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Ib_adminCountAggregateOutputType | null
    _avg: Ib_adminAvgAggregateOutputType | null
    _sum: Ib_adminSumAggregateOutputType | null
    _min: Ib_adminMinAggregateOutputType | null
    _max: Ib_adminMaxAggregateOutputType | null
  }

  type GetIb_adminGroupByPayload<T extends ib_adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_adminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_adminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_adminGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_adminGroupByOutputType[P]>
        }
      >
    >


  export type ib_adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_admin"]>

  export type ib_adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_admin"]>

  export type ib_adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_admin"]>

  export type ib_adminSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ib_adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "role" | "is_active" | "last_login" | "login_attempts" | "locked_until" | "created_at" | "updated_at", ExtArgs["result"]["ib_admin"]>

  export type $ib_adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password_hash: string
      role: string | null
      is_active: boolean | null
      last_login: Date | null
      login_attempts: number | null
      locked_until: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ib_admin"]>
    composites: {}
  }

  type ib_adminGetPayload<S extends boolean | null | undefined | ib_adminDefaultArgs> = $Result.GetResult<Prisma.$ib_adminPayload, S>

  type ib_adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_adminCountAggregateInputType | true
    }

  export interface ib_adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_admin'], meta: { name: 'ib_admin' } }
    /**
     * Find zero or one Ib_admin that matches the filter.
     * @param {ib_adminFindUniqueArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_adminFindUniqueArgs>(args: SelectSubset<T, ib_adminFindUniqueArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_adminFindUniqueOrThrowArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_adminFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminFindFirstArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_adminFindFirstArgs>(args?: SelectSubset<T, ib_adminFindFirstArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminFindFirstOrThrowArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_adminFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_admins
     * const ib_admins = await prisma.ib_admin.findMany()
     * 
     * // Get first 10 Ib_admins
     * const ib_admins = await prisma.ib_admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_adminWithIdOnly = await prisma.ib_admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_adminFindManyArgs>(args?: SelectSubset<T, ib_adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_admin.
     * @param {ib_adminCreateArgs} args - Arguments to create a Ib_admin.
     * @example
     * // Create one Ib_admin
     * const Ib_admin = await prisma.ib_admin.create({
     *   data: {
     *     // ... data to create a Ib_admin
     *   }
     * })
     * 
     */
    create<T extends ib_adminCreateArgs>(args: SelectSubset<T, ib_adminCreateArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_admins.
     * @param {ib_adminCreateManyArgs} args - Arguments to create many Ib_admins.
     * @example
     * // Create many Ib_admins
     * const ib_admin = await prisma.ib_admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_adminCreateManyArgs>(args?: SelectSubset<T, ib_adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_admins and returns the data saved in the database.
     * @param {ib_adminCreateManyAndReturnArgs} args - Arguments to create many Ib_admins.
     * @example
     * // Create many Ib_admins
     * const ib_admin = await prisma.ib_admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_admins and only return the `id`
     * const ib_adminWithIdOnly = await prisma.ib_admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_adminCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_admin.
     * @param {ib_adminDeleteArgs} args - Arguments to delete one Ib_admin.
     * @example
     * // Delete one Ib_admin
     * const Ib_admin = await prisma.ib_admin.delete({
     *   where: {
     *     // ... filter to delete one Ib_admin
     *   }
     * })
     * 
     */
    delete<T extends ib_adminDeleteArgs>(args: SelectSubset<T, ib_adminDeleteArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_admin.
     * @param {ib_adminUpdateArgs} args - Arguments to update one Ib_admin.
     * @example
     * // Update one Ib_admin
     * const ib_admin = await prisma.ib_admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_adminUpdateArgs>(args: SelectSubset<T, ib_adminUpdateArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_admins.
     * @param {ib_adminDeleteManyArgs} args - Arguments to filter Ib_admins to delete.
     * @example
     * // Delete a few Ib_admins
     * const { count } = await prisma.ib_admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_adminDeleteManyArgs>(args?: SelectSubset<T, ib_adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_admins
     * const ib_admin = await prisma.ib_admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_adminUpdateManyArgs>(args: SelectSubset<T, ib_adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_admins and returns the data updated in the database.
     * @param {ib_adminUpdateManyAndReturnArgs} args - Arguments to update many Ib_admins.
     * @example
     * // Update many Ib_admins
     * const ib_admin = await prisma.ib_admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_admins and only return the `id`
     * const ib_adminWithIdOnly = await prisma.ib_admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_adminUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_admin.
     * @param {ib_adminUpsertArgs} args - Arguments to update or create a Ib_admin.
     * @example
     * // Update or create a Ib_admin
     * const ib_admin = await prisma.ib_admin.upsert({
     *   create: {
     *     // ... data to create a Ib_admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_admin we want to update
     *   }
     * })
     */
    upsert<T extends ib_adminUpsertArgs>(args: SelectSubset<T, ib_adminUpsertArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminCountArgs} args - Arguments to filter Ib_admins to count.
     * @example
     * // Count the number of Ib_admins
     * const count = await prisma.ib_admin.count({
     *   where: {
     *     // ... the filter for the Ib_admins we want to count
     *   }
     * })
    **/
    count<T extends ib_adminCountArgs>(
      args?: Subset<T, ib_adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_adminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_adminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_adminAggregateArgs>(args: Subset<T, Ib_adminAggregateArgs>): Prisma.PrismaPromise<GetIb_adminAggregateType<T>>

    /**
     * Group by Ib_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_adminGroupByArgs['orderBy'] }
        : { orderBy?: ib_adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_adminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_admin model
   */
  readonly fields: ib_adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_admin model
   */
  interface ib_adminFieldRefs {
    readonly id: FieldRef<"ib_admin", 'Int'>
    readonly email: FieldRef<"ib_admin", 'String'>
    readonly password_hash: FieldRef<"ib_admin", 'String'>
    readonly role: FieldRef<"ib_admin", 'String'>
    readonly is_active: FieldRef<"ib_admin", 'Boolean'>
    readonly last_login: FieldRef<"ib_admin", 'DateTime'>
    readonly login_attempts: FieldRef<"ib_admin", 'Int'>
    readonly locked_until: FieldRef<"ib_admin", 'DateTime'>
    readonly created_at: FieldRef<"ib_admin", 'DateTime'>
    readonly updated_at: FieldRef<"ib_admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_admin findUnique
   */
  export type ib_adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin findUniqueOrThrow
   */
  export type ib_adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin findFirst
   */
  export type ib_adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_admins.
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_admins.
     */
    distinct?: Ib_adminScalarFieldEnum | Ib_adminScalarFieldEnum[]
  }

  /**
   * ib_admin findFirstOrThrow
   */
  export type ib_adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_admins.
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_admins.
     */
    distinct?: Ib_adminScalarFieldEnum | Ib_adminScalarFieldEnum[]
  }

  /**
   * ib_admin findMany
   */
  export type ib_adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admins to fetch.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_admins.
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    distinct?: Ib_adminScalarFieldEnum | Ib_adminScalarFieldEnum[]
  }

  /**
   * ib_admin create
   */
  export type ib_adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_admin.
     */
    data: XOR<ib_adminCreateInput, ib_adminUncheckedCreateInput>
  }

  /**
   * ib_admin createMany
   */
  export type ib_adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_admins.
     */
    data: ib_adminCreateManyInput | ib_adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_admin createManyAndReturn
   */
  export type ib_adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data used to create many ib_admins.
     */
    data: ib_adminCreateManyInput | ib_adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_admin update
   */
  export type ib_adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_admin.
     */
    data: XOR<ib_adminUpdateInput, ib_adminUncheckedUpdateInput>
    /**
     * Choose, which ib_admin to update.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin updateMany
   */
  export type ib_adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_admins.
     */
    data: XOR<ib_adminUpdateManyMutationInput, ib_adminUncheckedUpdateManyInput>
    /**
     * Filter which ib_admins to update
     */
    where?: ib_adminWhereInput
    /**
     * Limit how many ib_admins to update.
     */
    limit?: number
  }

  /**
   * ib_admin updateManyAndReturn
   */
  export type ib_adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data used to update ib_admins.
     */
    data: XOR<ib_adminUpdateManyMutationInput, ib_adminUncheckedUpdateManyInput>
    /**
     * Filter which ib_admins to update
     */
    where?: ib_adminWhereInput
    /**
     * Limit how many ib_admins to update.
     */
    limit?: number
  }

  /**
   * ib_admin upsert
   */
  export type ib_adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_admin to update in case it exists.
     */
    where: ib_adminWhereUniqueInput
    /**
     * In case the ib_admin found by the `where` argument doesn't exist, create a new ib_admin with this data.
     */
    create: XOR<ib_adminCreateInput, ib_adminUncheckedCreateInput>
    /**
     * In case the ib_admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_adminUpdateInput, ib_adminUncheckedUpdateInput>
  }

  /**
   * ib_admin delete
   */
  export type ib_adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter which ib_admin to delete.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin deleteMany
   */
  export type ib_adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_admins to delete
     */
    where?: ib_adminWhereInput
    /**
     * Limit how many ib_admins to delete.
     */
    limit?: number
  }

  /**
   * ib_admin without action
   */
  export type ib_adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
  }


  /**
   * Model ib_requests
   */

  export type AggregateIb_requests = {
    _count: Ib_requestsCountAggregateOutputType | null
    _avg: Ib_requestsAvgAggregateOutputType | null
    _sum: Ib_requestsSumAggregateOutputType | null
    _min: Ib_requestsMinAggregateOutputType | null
    _max: Ib_requestsMaxAggregateOutputType | null
  }

  export type Ib_requestsAvgAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    structure_id: number | null
  }

  export type Ib_requestsSumAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    structure_id: number | null
  }

  export type Ib_requestsMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password_hash: string | null
    status: string | null
    ib_type: string | null
    submitted_at: Date | null
    approved_at: Date | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    admin_comments: string | null
    group_id: string | null
    structure_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_requestsMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password_hash: string | null
    status: string | null
    ib_type: string | null
    submitted_at: Date | null
    approved_at: Date | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    admin_comments: string | null
    group_id: string | null
    structure_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_requestsCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    password_hash: number
    status: number
    ib_type: number
    submitted_at: number
    approved_at: number
    usd_per_lot: number
    spread_percentage_per_lot: number
    admin_comments: number
    group_id: number
    structure_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ib_requestsAvgAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    structure_id?: true
  }

  export type Ib_requestsSumAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    structure_id?: true
  }

  export type Ib_requestsMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    status?: true
    ib_type?: true
    submitted_at?: true
    approved_at?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    admin_comments?: true
    group_id?: true
    structure_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_requestsMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    status?: true
    ib_type?: true
    submitted_at?: true
    approved_at?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    admin_comments?: true
    group_id?: true
    structure_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_requestsCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    status?: true
    ib_type?: true
    submitted_at?: true
    approved_at?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    admin_comments?: true
    group_id?: true
    structure_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ib_requestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_requests to aggregate.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_requests
    **/
    _count?: true | Ib_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_requestsMaxAggregateInputType
  }

  export type GetIb_requestsAggregateType<T extends Ib_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_requests[P]>
      : GetScalarType<T[P], AggregateIb_requests[P]>
  }




  export type ib_requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_requestsWhereInput
    orderBy?: ib_requestsOrderByWithAggregationInput | ib_requestsOrderByWithAggregationInput[]
    by: Ib_requestsScalarFieldEnum[] | Ib_requestsScalarFieldEnum
    having?: ib_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_requestsCountAggregateInputType | true
    _avg?: Ib_requestsAvgAggregateInputType
    _sum?: Ib_requestsSumAggregateInputType
    _min?: Ib_requestsMinAggregateInputType
    _max?: Ib_requestsMaxAggregateInputType
  }

  export type Ib_requestsGroupByOutputType = {
    id: number
    full_name: string
    email: string
    password_hash: string
    status: string
    ib_type: string
    submitted_at: Date | null
    approved_at: Date | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    admin_comments: string | null
    group_id: string | null
    structure_id: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Ib_requestsCountAggregateOutputType | null
    _avg: Ib_requestsAvgAggregateOutputType | null
    _sum: Ib_requestsSumAggregateOutputType | null
    _min: Ib_requestsMinAggregateOutputType | null
    _max: Ib_requestsMaxAggregateOutputType | null
  }

  type GetIb_requestsGroupByPayload<T extends ib_requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_requestsGroupByOutputType[P]>
        }
      >
    >


  export type ib_requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    ib_group_assignments?: boolean | ib_requests$ib_group_assignmentsArgs<ExtArgs>
    _count?: boolean | Ib_requestsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ib_requests"]>

  export type ib_requestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_requests"]>

  export type ib_requestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_requests"]>

  export type ib_requestsSelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ib_requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "email" | "password_hash" | "status" | "ib_type" | "submitted_at" | "approved_at" | "usd_per_lot" | "spread_percentage_per_lot" | "admin_comments" | "group_id" | "structure_id" | "created_at" | "updated_at", ExtArgs["result"]["ib_requests"]>
  export type ib_requestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_group_assignments?: boolean | ib_requests$ib_group_assignmentsArgs<ExtArgs>
    _count?: boolean | Ib_requestsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ib_requestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ib_requestsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ib_requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_requests"
    objects: {
      ib_group_assignments: Prisma.$ib_group_assignmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      email: string
      password_hash: string
      status: string
      ib_type: string
      submitted_at: Date | null
      approved_at: Date | null
      usd_per_lot: Prisma.Decimal | null
      spread_percentage_per_lot: Prisma.Decimal | null
      admin_comments: string | null
      group_id: string | null
      structure_id: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ib_requests"]>
    composites: {}
  }

  type ib_requestsGetPayload<S extends boolean | null | undefined | ib_requestsDefaultArgs> = $Result.GetResult<Prisma.$ib_requestsPayload, S>

  type ib_requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_requestsCountAggregateInputType | true
    }

  export interface ib_requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_requests'], meta: { name: 'ib_requests' } }
    /**
     * Find zero or one Ib_requests that matches the filter.
     * @param {ib_requestsFindUniqueArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_requestsFindUniqueArgs>(args: SelectSubset<T, ib_requestsFindUniqueArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_requestsFindUniqueOrThrowArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsFindFirstArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_requestsFindFirstArgs>(args?: SelectSubset<T, ib_requestsFindFirstArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsFindFirstOrThrowArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_requests
     * const ib_requests = await prisma.ib_requests.findMany()
     * 
     * // Get first 10 Ib_requests
     * const ib_requests = await prisma.ib_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_requestsWithIdOnly = await prisma.ib_requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_requestsFindManyArgs>(args?: SelectSubset<T, ib_requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_requests.
     * @param {ib_requestsCreateArgs} args - Arguments to create a Ib_requests.
     * @example
     * // Create one Ib_requests
     * const Ib_requests = await prisma.ib_requests.create({
     *   data: {
     *     // ... data to create a Ib_requests
     *   }
     * })
     * 
     */
    create<T extends ib_requestsCreateArgs>(args: SelectSubset<T, ib_requestsCreateArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_requests.
     * @param {ib_requestsCreateManyArgs} args - Arguments to create many Ib_requests.
     * @example
     * // Create many Ib_requests
     * const ib_requests = await prisma.ib_requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_requestsCreateManyArgs>(args?: SelectSubset<T, ib_requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_requests and returns the data saved in the database.
     * @param {ib_requestsCreateManyAndReturnArgs} args - Arguments to create many Ib_requests.
     * @example
     * // Create many Ib_requests
     * const ib_requests = await prisma.ib_requests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_requests and only return the `id`
     * const ib_requestsWithIdOnly = await prisma.ib_requests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_requestsCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_requestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_requests.
     * @param {ib_requestsDeleteArgs} args - Arguments to delete one Ib_requests.
     * @example
     * // Delete one Ib_requests
     * const Ib_requests = await prisma.ib_requests.delete({
     *   where: {
     *     // ... filter to delete one Ib_requests
     *   }
     * })
     * 
     */
    delete<T extends ib_requestsDeleteArgs>(args: SelectSubset<T, ib_requestsDeleteArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_requests.
     * @param {ib_requestsUpdateArgs} args - Arguments to update one Ib_requests.
     * @example
     * // Update one Ib_requests
     * const ib_requests = await prisma.ib_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_requestsUpdateArgs>(args: SelectSubset<T, ib_requestsUpdateArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_requests.
     * @param {ib_requestsDeleteManyArgs} args - Arguments to filter Ib_requests to delete.
     * @example
     * // Delete a few Ib_requests
     * const { count } = await prisma.ib_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_requestsDeleteManyArgs>(args?: SelectSubset<T, ib_requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_requests
     * const ib_requests = await prisma.ib_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_requestsUpdateManyArgs>(args: SelectSubset<T, ib_requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_requests and returns the data updated in the database.
     * @param {ib_requestsUpdateManyAndReturnArgs} args - Arguments to update many Ib_requests.
     * @example
     * // Update many Ib_requests
     * const ib_requests = await prisma.ib_requests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_requests and only return the `id`
     * const ib_requestsWithIdOnly = await prisma.ib_requests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_requestsUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_requestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_requests.
     * @param {ib_requestsUpsertArgs} args - Arguments to update or create a Ib_requests.
     * @example
     * // Update or create a Ib_requests
     * const ib_requests = await prisma.ib_requests.upsert({
     *   create: {
     *     // ... data to create a Ib_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_requests we want to update
     *   }
     * })
     */
    upsert<T extends ib_requestsUpsertArgs>(args: SelectSubset<T, ib_requestsUpsertArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsCountArgs} args - Arguments to filter Ib_requests to count.
     * @example
     * // Count the number of Ib_requests
     * const count = await prisma.ib_requests.count({
     *   where: {
     *     // ... the filter for the Ib_requests we want to count
     *   }
     * })
    **/
    count<T extends ib_requestsCountArgs>(
      args?: Subset<T, ib_requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_requestsAggregateArgs>(args: Subset<T, Ib_requestsAggregateArgs>): Prisma.PrismaPromise<GetIb_requestsAggregateType<T>>

    /**
     * Group by Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_requestsGroupByArgs['orderBy'] }
        : { orderBy?: ib_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_requestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_requests model
   */
  readonly fields: ib_requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ib_group_assignments<T extends ib_requests$ib_group_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ib_requests$ib_group_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_requests model
   */
  interface ib_requestsFieldRefs {
    readonly id: FieldRef<"ib_requests", 'Int'>
    readonly full_name: FieldRef<"ib_requests", 'String'>
    readonly email: FieldRef<"ib_requests", 'String'>
    readonly password_hash: FieldRef<"ib_requests", 'String'>
    readonly status: FieldRef<"ib_requests", 'String'>
    readonly ib_type: FieldRef<"ib_requests", 'String'>
    readonly submitted_at: FieldRef<"ib_requests", 'DateTime'>
    readonly approved_at: FieldRef<"ib_requests", 'DateTime'>
    readonly usd_per_lot: FieldRef<"ib_requests", 'Decimal'>
    readonly spread_percentage_per_lot: FieldRef<"ib_requests", 'Decimal'>
    readonly admin_comments: FieldRef<"ib_requests", 'String'>
    readonly group_id: FieldRef<"ib_requests", 'String'>
    readonly structure_id: FieldRef<"ib_requests", 'Int'>
    readonly created_at: FieldRef<"ib_requests", 'DateTime'>
    readonly updated_at: FieldRef<"ib_requests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_requests findUnique
   */
  export type ib_requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests findUniqueOrThrow
   */
  export type ib_requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests findFirst
   */
  export type ib_requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_requests.
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_requests.
     */
    distinct?: Ib_requestsScalarFieldEnum | Ib_requestsScalarFieldEnum[]
  }

  /**
   * ib_requests findFirstOrThrow
   */
  export type ib_requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_requests.
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_requests.
     */
    distinct?: Ib_requestsScalarFieldEnum | Ib_requestsScalarFieldEnum[]
  }

  /**
   * ib_requests findMany
   */
  export type ib_requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_requests.
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    distinct?: Ib_requestsScalarFieldEnum | Ib_requestsScalarFieldEnum[]
  }

  /**
   * ib_requests create
   */
  export type ib_requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * The data needed to create a ib_requests.
     */
    data: XOR<ib_requestsCreateInput, ib_requestsUncheckedCreateInput>
  }

  /**
   * ib_requests createMany
   */
  export type ib_requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_requests.
     */
    data: ib_requestsCreateManyInput | ib_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_requests createManyAndReturn
   */
  export type ib_requestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * The data used to create many ib_requests.
     */
    data: ib_requestsCreateManyInput | ib_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_requests update
   */
  export type ib_requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * The data needed to update a ib_requests.
     */
    data: XOR<ib_requestsUpdateInput, ib_requestsUncheckedUpdateInput>
    /**
     * Choose, which ib_requests to update.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests updateMany
   */
  export type ib_requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_requests.
     */
    data: XOR<ib_requestsUpdateManyMutationInput, ib_requestsUncheckedUpdateManyInput>
    /**
     * Filter which ib_requests to update
     */
    where?: ib_requestsWhereInput
    /**
     * Limit how many ib_requests to update.
     */
    limit?: number
  }

  /**
   * ib_requests updateManyAndReturn
   */
  export type ib_requestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * The data used to update ib_requests.
     */
    data: XOR<ib_requestsUpdateManyMutationInput, ib_requestsUncheckedUpdateManyInput>
    /**
     * Filter which ib_requests to update
     */
    where?: ib_requestsWhereInput
    /**
     * Limit how many ib_requests to update.
     */
    limit?: number
  }

  /**
   * ib_requests upsert
   */
  export type ib_requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * The filter to search for the ib_requests to update in case it exists.
     */
    where: ib_requestsWhereUniqueInput
    /**
     * In case the ib_requests found by the `where` argument doesn't exist, create a new ib_requests with this data.
     */
    create: XOR<ib_requestsCreateInput, ib_requestsUncheckedCreateInput>
    /**
     * In case the ib_requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_requestsUpdateInput, ib_requestsUncheckedUpdateInput>
  }

  /**
   * ib_requests delete
   */
  export type ib_requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter which ib_requests to delete.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests deleteMany
   */
  export type ib_requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_requests to delete
     */
    where?: ib_requestsWhereInput
    /**
     * Limit how many ib_requests to delete.
     */
    limit?: number
  }

  /**
   * ib_requests.ib_group_assignments
   */
  export type ib_requests$ib_group_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    where?: ib_group_assignmentsWhereInput
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    cursor?: ib_group_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_requests without action
   */
  export type ib_requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
  }


  /**
   * Model manual_gateway
   */

  export type AggregateManual_gateway = {
    _count: Manual_gatewayCountAggregateOutputType | null
    _avg: Manual_gatewayAvgAggregateOutputType | null
    _sum: Manual_gatewaySumAggregateOutputType | null
    _min: Manual_gatewayMinAggregateOutputType | null
    _max: Manual_gatewayMaxAggregateOutputType | null
  }

  export type Manual_gatewayAvgAggregateOutputType = {
    id: number | null
  }

  export type Manual_gatewaySumAggregateOutputType = {
    id: number | null
  }

  export type Manual_gatewayMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    details: string | null
    icon_url: string | null
    qr_code_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Manual_gatewayMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    details: string | null
    icon_url: string | null
    qr_code_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Manual_gatewayCountAggregateOutputType = {
    id: number
    type: number
    name: number
    details: number
    icon_url: number
    qr_code_url: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Manual_gatewayAvgAggregateInputType = {
    id?: true
  }

  export type Manual_gatewaySumAggregateInputType = {
    id?: true
  }

  export type Manual_gatewayMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    details?: true
    icon_url?: true
    qr_code_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Manual_gatewayMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    details?: true
    icon_url?: true
    qr_code_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Manual_gatewayCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    details?: true
    icon_url?: true
    qr_code_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Manual_gatewayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_gateway to aggregate.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manual_gateways
    **/
    _count?: true | Manual_gatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Manual_gatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Manual_gatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Manual_gatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Manual_gatewayMaxAggregateInputType
  }

  export type GetManual_gatewayAggregateType<T extends Manual_gatewayAggregateArgs> = {
        [P in keyof T & keyof AggregateManual_gateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManual_gateway[P]>
      : GetScalarType<T[P], AggregateManual_gateway[P]>
  }




  export type manual_gatewayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manual_gatewayWhereInput
    orderBy?: manual_gatewayOrderByWithAggregationInput | manual_gatewayOrderByWithAggregationInput[]
    by: Manual_gatewayScalarFieldEnum[] | Manual_gatewayScalarFieldEnum
    having?: manual_gatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Manual_gatewayCountAggregateInputType | true
    _avg?: Manual_gatewayAvgAggregateInputType
    _sum?: Manual_gatewaySumAggregateInputType
    _min?: Manual_gatewayMinAggregateInputType
    _max?: Manual_gatewayMaxAggregateInputType
  }

  export type Manual_gatewayGroupByOutputType = {
    id: number
    type: string
    name: string
    details: string
    icon_url: string | null
    qr_code_url: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Manual_gatewayCountAggregateOutputType | null
    _avg: Manual_gatewayAvgAggregateOutputType | null
    _sum: Manual_gatewaySumAggregateOutputType | null
    _min: Manual_gatewayMinAggregateOutputType | null
    _max: Manual_gatewayMaxAggregateOutputType | null
  }

  type GetManual_gatewayGroupByPayload<T extends manual_gatewayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Manual_gatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Manual_gatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Manual_gatewayGroupByOutputType[P]>
            : GetScalarType<T[P], Manual_gatewayGroupByOutputType[P]>
        }
      >
    >


  export type manual_gatewaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["manual_gateway"]>

  export type manual_gatewaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["manual_gateway"]>

  export type manual_gatewaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["manual_gateway"]>

  export type manual_gatewaySelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type manual_gatewayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "details" | "icon_url" | "qr_code_url" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["manual_gateway"]>

  export type $manual_gatewayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "manual_gateway"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      name: string
      details: string
      icon_url: string | null
      qr_code_url: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["manual_gateway"]>
    composites: {}
  }

  type manual_gatewayGetPayload<S extends boolean | null | undefined | manual_gatewayDefaultArgs> = $Result.GetResult<Prisma.$manual_gatewayPayload, S>

  type manual_gatewayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<manual_gatewayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Manual_gatewayCountAggregateInputType | true
    }

  export interface manual_gatewayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['manual_gateway'], meta: { name: 'manual_gateway' } }
    /**
     * Find zero or one Manual_gateway that matches the filter.
     * @param {manual_gatewayFindUniqueArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends manual_gatewayFindUniqueArgs>(args: SelectSubset<T, manual_gatewayFindUniqueArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manual_gateway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {manual_gatewayFindUniqueOrThrowArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends manual_gatewayFindUniqueOrThrowArgs>(args: SelectSubset<T, manual_gatewayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manual_gateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayFindFirstArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends manual_gatewayFindFirstArgs>(args?: SelectSubset<T, manual_gatewayFindFirstArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manual_gateway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayFindFirstOrThrowArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends manual_gatewayFindFirstOrThrowArgs>(args?: SelectSubset<T, manual_gatewayFindFirstOrThrowArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manual_gateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manual_gateways
     * const manual_gateways = await prisma.manual_gateway.findMany()
     * 
     * // Get first 10 Manual_gateways
     * const manual_gateways = await prisma.manual_gateway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manual_gatewayWithIdOnly = await prisma.manual_gateway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends manual_gatewayFindManyArgs>(args?: SelectSubset<T, manual_gatewayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manual_gateway.
     * @param {manual_gatewayCreateArgs} args - Arguments to create a Manual_gateway.
     * @example
     * // Create one Manual_gateway
     * const Manual_gateway = await prisma.manual_gateway.create({
     *   data: {
     *     // ... data to create a Manual_gateway
     *   }
     * })
     * 
     */
    create<T extends manual_gatewayCreateArgs>(args: SelectSubset<T, manual_gatewayCreateArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manual_gateways.
     * @param {manual_gatewayCreateManyArgs} args - Arguments to create many Manual_gateways.
     * @example
     * // Create many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends manual_gatewayCreateManyArgs>(args?: SelectSubset<T, manual_gatewayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Manual_gateways and returns the data saved in the database.
     * @param {manual_gatewayCreateManyAndReturnArgs} args - Arguments to create many Manual_gateways.
     * @example
     * // Create many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Manual_gateways and only return the `id`
     * const manual_gatewayWithIdOnly = await prisma.manual_gateway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends manual_gatewayCreateManyAndReturnArgs>(args?: SelectSubset<T, manual_gatewayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manual_gateway.
     * @param {manual_gatewayDeleteArgs} args - Arguments to delete one Manual_gateway.
     * @example
     * // Delete one Manual_gateway
     * const Manual_gateway = await prisma.manual_gateway.delete({
     *   where: {
     *     // ... filter to delete one Manual_gateway
     *   }
     * })
     * 
     */
    delete<T extends manual_gatewayDeleteArgs>(args: SelectSubset<T, manual_gatewayDeleteArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manual_gateway.
     * @param {manual_gatewayUpdateArgs} args - Arguments to update one Manual_gateway.
     * @example
     * // Update one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends manual_gatewayUpdateArgs>(args: SelectSubset<T, manual_gatewayUpdateArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manual_gateways.
     * @param {manual_gatewayDeleteManyArgs} args - Arguments to filter Manual_gateways to delete.
     * @example
     * // Delete a few Manual_gateways
     * const { count } = await prisma.manual_gateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends manual_gatewayDeleteManyArgs>(args?: SelectSubset<T, manual_gatewayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manual_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends manual_gatewayUpdateManyArgs>(args: SelectSubset<T, manual_gatewayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manual_gateways and returns the data updated in the database.
     * @param {manual_gatewayUpdateManyAndReturnArgs} args - Arguments to update many Manual_gateways.
     * @example
     * // Update many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Manual_gateways and only return the `id`
     * const manual_gatewayWithIdOnly = await prisma.manual_gateway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends manual_gatewayUpdateManyAndReturnArgs>(args: SelectSubset<T, manual_gatewayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manual_gateway.
     * @param {manual_gatewayUpsertArgs} args - Arguments to update or create a Manual_gateway.
     * @example
     * // Update or create a Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.upsert({
     *   create: {
     *     // ... data to create a Manual_gateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manual_gateway we want to update
     *   }
     * })
     */
    upsert<T extends manual_gatewayUpsertArgs>(args: SelectSubset<T, manual_gatewayUpsertArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manual_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayCountArgs} args - Arguments to filter Manual_gateways to count.
     * @example
     * // Count the number of Manual_gateways
     * const count = await prisma.manual_gateway.count({
     *   where: {
     *     // ... the filter for the Manual_gateways we want to count
     *   }
     * })
    **/
    count<T extends manual_gatewayCountArgs>(
      args?: Subset<T, manual_gatewayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Manual_gatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manual_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Manual_gatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Manual_gatewayAggregateArgs>(args: Subset<T, Manual_gatewayAggregateArgs>): Prisma.PrismaPromise<GetManual_gatewayAggregateType<T>>

    /**
     * Group by Manual_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends manual_gatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: manual_gatewayGroupByArgs['orderBy'] }
        : { orderBy?: manual_gatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, manual_gatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManual_gatewayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the manual_gateway model
   */
  readonly fields: manual_gatewayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for manual_gateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__manual_gatewayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the manual_gateway model
   */
  interface manual_gatewayFieldRefs {
    readonly id: FieldRef<"manual_gateway", 'Int'>
    readonly type: FieldRef<"manual_gateway", 'String'>
    readonly name: FieldRef<"manual_gateway", 'String'>
    readonly details: FieldRef<"manual_gateway", 'String'>
    readonly icon_url: FieldRef<"manual_gateway", 'String'>
    readonly qr_code_url: FieldRef<"manual_gateway", 'String'>
    readonly is_active: FieldRef<"manual_gateway", 'Boolean'>
    readonly created_at: FieldRef<"manual_gateway", 'DateTime'>
    readonly updated_at: FieldRef<"manual_gateway", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * manual_gateway findUnique
   */
  export type manual_gatewayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway findUniqueOrThrow
   */
  export type manual_gatewayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway findFirst
   */
  export type manual_gatewayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_gateways.
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_gateways.
     */
    distinct?: Manual_gatewayScalarFieldEnum | Manual_gatewayScalarFieldEnum[]
  }

  /**
   * manual_gateway findFirstOrThrow
   */
  export type manual_gatewayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_gateways.
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_gateways.
     */
    distinct?: Manual_gatewayScalarFieldEnum | Manual_gatewayScalarFieldEnum[]
  }

  /**
   * manual_gateway findMany
   */
  export type manual_gatewayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateways to fetch.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manual_gateways.
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    distinct?: Manual_gatewayScalarFieldEnum | Manual_gatewayScalarFieldEnum[]
  }

  /**
   * manual_gateway create
   */
  export type manual_gatewayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to create a manual_gateway.
     */
    data: XOR<manual_gatewayCreateInput, manual_gatewayUncheckedCreateInput>
  }

  /**
   * manual_gateway createMany
   */
  export type manual_gatewayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many manual_gateways.
     */
    data: manual_gatewayCreateManyInput | manual_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * manual_gateway createManyAndReturn
   */
  export type manual_gatewayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data used to create many manual_gateways.
     */
    data: manual_gatewayCreateManyInput | manual_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * manual_gateway update
   */
  export type manual_gatewayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to update a manual_gateway.
     */
    data: XOR<manual_gatewayUpdateInput, manual_gatewayUncheckedUpdateInput>
    /**
     * Choose, which manual_gateway to update.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway updateMany
   */
  export type manual_gatewayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update manual_gateways.
     */
    data: XOR<manual_gatewayUpdateManyMutationInput, manual_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which manual_gateways to update
     */
    where?: manual_gatewayWhereInput
    /**
     * Limit how many manual_gateways to update.
     */
    limit?: number
  }

  /**
   * manual_gateway updateManyAndReturn
   */
  export type manual_gatewayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data used to update manual_gateways.
     */
    data: XOR<manual_gatewayUpdateManyMutationInput, manual_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which manual_gateways to update
     */
    where?: manual_gatewayWhereInput
    /**
     * Limit how many manual_gateways to update.
     */
    limit?: number
  }

  /**
   * manual_gateway upsert
   */
  export type manual_gatewayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The filter to search for the manual_gateway to update in case it exists.
     */
    where: manual_gatewayWhereUniqueInput
    /**
     * In case the manual_gateway found by the `where` argument doesn't exist, create a new manual_gateway with this data.
     */
    create: XOR<manual_gatewayCreateInput, manual_gatewayUncheckedCreateInput>
    /**
     * In case the manual_gateway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manual_gatewayUpdateInput, manual_gatewayUncheckedUpdateInput>
  }

  /**
   * manual_gateway delete
   */
  export type manual_gatewayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter which manual_gateway to delete.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway deleteMany
   */
  export type manual_gatewayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_gateways to delete
     */
    where?: manual_gatewayWhereInput
    /**
     * Limit how many manual_gateways to delete.
     */
    limit?: number
  }

  /**
   * manual_gateway without action
   */
  export type manual_gatewayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
  }


  /**
   * Model mt5_groups
   */

  export type AggregateMt5_groups = {
    _count: Mt5_groupsCountAggregateOutputType | null
    _avg: Mt5_groupsAvgAggregateOutputType | null
    _sum: Mt5_groupsSumAggregateOutputType | null
    _min: Mt5_groupsMinAggregateOutputType | null
    _max: Mt5_groupsMaxAggregateOutputType | null
  }

  export type Mt5_groupsAvgAggregateOutputType = {
    id: number | null
  }

  export type Mt5_groupsSumAggregateOutputType = {
    id: number | null
  }

  export type Mt5_groupsMinAggregateOutputType = {
    id: number | null
    group_id: string | null
    name: string | null
    description: string | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Mt5_groupsMaxAggregateOutputType = {
    id: number | null
    group_id: string | null
    name: string | null
    description: string | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Mt5_groupsCountAggregateOutputType = {
    id: number
    group_id: number
    name: number
    description: number
    synced_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Mt5_groupsAvgAggregateInputType = {
    id?: true
  }

  export type Mt5_groupsSumAggregateInputType = {
    id?: true
  }

  export type Mt5_groupsMinAggregateInputType = {
    id?: true
    group_id?: true
    name?: true
    description?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Mt5_groupsMaxAggregateInputType = {
    id?: true
    group_id?: true
    name?: true
    description?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Mt5_groupsCountAggregateInputType = {
    id?: true
    group_id?: true
    name?: true
    description?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Mt5_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mt5_groups to aggregate.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mt5_groups
    **/
    _count?: true | Mt5_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mt5_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mt5_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mt5_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mt5_groupsMaxAggregateInputType
  }

  export type GetMt5_groupsAggregateType<T extends Mt5_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateMt5_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMt5_groups[P]>
      : GetScalarType<T[P], AggregateMt5_groups[P]>
  }




  export type mt5_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mt5_groupsWhereInput
    orderBy?: mt5_groupsOrderByWithAggregationInput | mt5_groupsOrderByWithAggregationInput[]
    by: Mt5_groupsScalarFieldEnum[] | Mt5_groupsScalarFieldEnum
    having?: mt5_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mt5_groupsCountAggregateInputType | true
    _avg?: Mt5_groupsAvgAggregateInputType
    _sum?: Mt5_groupsSumAggregateInputType
    _min?: Mt5_groupsMinAggregateInputType
    _max?: Mt5_groupsMaxAggregateInputType
  }

  export type Mt5_groupsGroupByOutputType = {
    id: number
    group_id: string
    name: string
    description: string | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Mt5_groupsCountAggregateOutputType | null
    _avg: Mt5_groupsAvgAggregateOutputType | null
    _sum: Mt5_groupsSumAggregateOutputType | null
    _min: Mt5_groupsMinAggregateOutputType | null
    _max: Mt5_groupsMaxAggregateOutputType | null
  }

  type GetMt5_groupsGroupByPayload<T extends mt5_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mt5_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mt5_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mt5_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Mt5_groupsGroupByOutputType[P]>
        }
      >
    >


  export type mt5_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["mt5_groups"]>

  export type mt5_groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["mt5_groups"]>

  export type mt5_groupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["mt5_groups"]>

  export type mt5_groupsSelectScalar = {
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type mt5_groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "group_id" | "name" | "description" | "synced_at" | "created_at" | "updated_at", ExtArgs["result"]["mt5_groups"]>

  export type $mt5_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mt5_groups"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      group_id: string
      name: string
      description: string | null
      synced_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["mt5_groups"]>
    composites: {}
  }

  type mt5_groupsGetPayload<S extends boolean | null | undefined | mt5_groupsDefaultArgs> = $Result.GetResult<Prisma.$mt5_groupsPayload, S>

  type mt5_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mt5_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mt5_groupsCountAggregateInputType | true
    }

  export interface mt5_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mt5_groups'], meta: { name: 'mt5_groups' } }
    /**
     * Find zero or one Mt5_groups that matches the filter.
     * @param {mt5_groupsFindUniqueArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mt5_groupsFindUniqueArgs>(args: SelectSubset<T, mt5_groupsFindUniqueArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mt5_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mt5_groupsFindUniqueOrThrowArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mt5_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, mt5_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mt5_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsFindFirstArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mt5_groupsFindFirstArgs>(args?: SelectSubset<T, mt5_groupsFindFirstArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mt5_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsFindFirstOrThrowArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mt5_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, mt5_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mt5_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findMany()
     * 
     * // Get first 10 Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mt5_groupsWithIdOnly = await prisma.mt5_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mt5_groupsFindManyArgs>(args?: SelectSubset<T, mt5_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mt5_groups.
     * @param {mt5_groupsCreateArgs} args - Arguments to create a Mt5_groups.
     * @example
     * // Create one Mt5_groups
     * const Mt5_groups = await prisma.mt5_groups.create({
     *   data: {
     *     // ... data to create a Mt5_groups
     *   }
     * })
     * 
     */
    create<T extends mt5_groupsCreateArgs>(args: SelectSubset<T, mt5_groupsCreateArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mt5_groups.
     * @param {mt5_groupsCreateManyArgs} args - Arguments to create many Mt5_groups.
     * @example
     * // Create many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mt5_groupsCreateManyArgs>(args?: SelectSubset<T, mt5_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mt5_groups and returns the data saved in the database.
     * @param {mt5_groupsCreateManyAndReturnArgs} args - Arguments to create many Mt5_groups.
     * @example
     * // Create many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mt5_groups and only return the `id`
     * const mt5_groupsWithIdOnly = await prisma.mt5_groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mt5_groupsCreateManyAndReturnArgs>(args?: SelectSubset<T, mt5_groupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mt5_groups.
     * @param {mt5_groupsDeleteArgs} args - Arguments to delete one Mt5_groups.
     * @example
     * // Delete one Mt5_groups
     * const Mt5_groups = await prisma.mt5_groups.delete({
     *   where: {
     *     // ... filter to delete one Mt5_groups
     *   }
     * })
     * 
     */
    delete<T extends mt5_groupsDeleteArgs>(args: SelectSubset<T, mt5_groupsDeleteArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mt5_groups.
     * @param {mt5_groupsUpdateArgs} args - Arguments to update one Mt5_groups.
     * @example
     * // Update one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mt5_groupsUpdateArgs>(args: SelectSubset<T, mt5_groupsUpdateArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mt5_groups.
     * @param {mt5_groupsDeleteManyArgs} args - Arguments to filter Mt5_groups to delete.
     * @example
     * // Delete a few Mt5_groups
     * const { count } = await prisma.mt5_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mt5_groupsDeleteManyArgs>(args?: SelectSubset<T, mt5_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mt5_groupsUpdateManyArgs>(args: SelectSubset<T, mt5_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mt5_groups and returns the data updated in the database.
     * @param {mt5_groupsUpdateManyAndReturnArgs} args - Arguments to update many Mt5_groups.
     * @example
     * // Update many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mt5_groups and only return the `id`
     * const mt5_groupsWithIdOnly = await prisma.mt5_groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mt5_groupsUpdateManyAndReturnArgs>(args: SelectSubset<T, mt5_groupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mt5_groups.
     * @param {mt5_groupsUpsertArgs} args - Arguments to update or create a Mt5_groups.
     * @example
     * // Update or create a Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.upsert({
     *   create: {
     *     // ... data to create a Mt5_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mt5_groups we want to update
     *   }
     * })
     */
    upsert<T extends mt5_groupsUpsertArgs>(args: SelectSubset<T, mt5_groupsUpsertArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsCountArgs} args - Arguments to filter Mt5_groups to count.
     * @example
     * // Count the number of Mt5_groups
     * const count = await prisma.mt5_groups.count({
     *   where: {
     *     // ... the filter for the Mt5_groups we want to count
     *   }
     * })
    **/
    count<T extends mt5_groupsCountArgs>(
      args?: Subset<T, mt5_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mt5_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mt5_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mt5_groupsAggregateArgs>(args: Subset<T, Mt5_groupsAggregateArgs>): Prisma.PrismaPromise<GetMt5_groupsAggregateType<T>>

    /**
     * Group by Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mt5_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mt5_groupsGroupByArgs['orderBy'] }
        : { orderBy?: mt5_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mt5_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMt5_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mt5_groups model
   */
  readonly fields: mt5_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mt5_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mt5_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mt5_groups model
   */
  interface mt5_groupsFieldRefs {
    readonly id: FieldRef<"mt5_groups", 'Int'>
    readonly group_id: FieldRef<"mt5_groups", 'String'>
    readonly name: FieldRef<"mt5_groups", 'String'>
    readonly description: FieldRef<"mt5_groups", 'String'>
    readonly synced_at: FieldRef<"mt5_groups", 'DateTime'>
    readonly created_at: FieldRef<"mt5_groups", 'DateTime'>
    readonly updated_at: FieldRef<"mt5_groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mt5_groups findUnique
   */
  export type mt5_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups findUniqueOrThrow
   */
  export type mt5_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups findFirst
   */
  export type mt5_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mt5_groups.
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mt5_groups.
     */
    distinct?: Mt5_groupsScalarFieldEnum | Mt5_groupsScalarFieldEnum[]
  }

  /**
   * mt5_groups findFirstOrThrow
   */
  export type mt5_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mt5_groups.
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mt5_groups.
     */
    distinct?: Mt5_groupsScalarFieldEnum | Mt5_groupsScalarFieldEnum[]
  }

  /**
   * mt5_groups findMany
   */
  export type mt5_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mt5_groups.
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    distinct?: Mt5_groupsScalarFieldEnum | Mt5_groupsScalarFieldEnum[]
  }

  /**
   * mt5_groups create
   */
  export type mt5_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data needed to create a mt5_groups.
     */
    data: XOR<mt5_groupsCreateInput, mt5_groupsUncheckedCreateInput>
  }

  /**
   * mt5_groups createMany
   */
  export type mt5_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mt5_groups.
     */
    data: mt5_groupsCreateManyInput | mt5_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mt5_groups createManyAndReturn
   */
  export type mt5_groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data used to create many mt5_groups.
     */
    data: mt5_groupsCreateManyInput | mt5_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mt5_groups update
   */
  export type mt5_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data needed to update a mt5_groups.
     */
    data: XOR<mt5_groupsUpdateInput, mt5_groupsUncheckedUpdateInput>
    /**
     * Choose, which mt5_groups to update.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups updateMany
   */
  export type mt5_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mt5_groups.
     */
    data: XOR<mt5_groupsUpdateManyMutationInput, mt5_groupsUncheckedUpdateManyInput>
    /**
     * Filter which mt5_groups to update
     */
    where?: mt5_groupsWhereInput
    /**
     * Limit how many mt5_groups to update.
     */
    limit?: number
  }

  /**
   * mt5_groups updateManyAndReturn
   */
  export type mt5_groupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data used to update mt5_groups.
     */
    data: XOR<mt5_groupsUpdateManyMutationInput, mt5_groupsUncheckedUpdateManyInput>
    /**
     * Filter which mt5_groups to update
     */
    where?: mt5_groupsWhereInput
    /**
     * Limit how many mt5_groups to update.
     */
    limit?: number
  }

  /**
   * mt5_groups upsert
   */
  export type mt5_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The filter to search for the mt5_groups to update in case it exists.
     */
    where: mt5_groupsWhereUniqueInput
    /**
     * In case the mt5_groups found by the `where` argument doesn't exist, create a new mt5_groups with this data.
     */
    create: XOR<mt5_groupsCreateInput, mt5_groupsUncheckedCreateInput>
    /**
     * In case the mt5_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mt5_groupsUpdateInput, mt5_groupsUncheckedUpdateInput>
  }

  /**
   * mt5_groups delete
   */
  export type mt5_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter which mt5_groups to delete.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups deleteMany
   */
  export type mt5_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mt5_groups to delete
     */
    where?: mt5_groupsWhereInput
    /**
     * Limit how many mt5_groups to delete.
     */
    limit?: number
  }

  /**
   * mt5_groups without action
   */
  export type mt5_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
  }


  /**
   * Model payment_gateway
   */

  export type AggregatePayment_gateway = {
    _count: Payment_gatewayCountAggregateOutputType | null
    _avg: Payment_gatewayAvgAggregateOutputType | null
    _sum: Payment_gatewaySumAggregateOutputType | null
    _min: Payment_gatewayMinAggregateOutputType | null
    _max: Payment_gatewayMaxAggregateOutputType | null
  }

  export type Payment_gatewayAvgAggregateOutputType = {
    id: number | null
  }

  export type Payment_gatewaySumAggregateOutputType = {
    id: number | null
  }

  export type Payment_gatewayMinAggregateOutputType = {
    id: number | null
    wallet_name: string | null
    deposit_wallet_address: string | null
    api_key: string | null
    secret_key: string | null
    gateway_type: string | null
    is_active: boolean | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_gatewayMaxAggregateOutputType = {
    id: number | null
    wallet_name: string | null
    deposit_wallet_address: string | null
    api_key: string | null
    secret_key: string | null
    gateway_type: string | null
    is_active: boolean | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_gatewayCountAggregateOutputType = {
    id: number
    wallet_name: number
    deposit_wallet_address: number
    api_key: number
    secret_key: number
    gateway_type: number
    is_active: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Payment_gatewayAvgAggregateInputType = {
    id?: true
  }

  export type Payment_gatewaySumAggregateInputType = {
    id?: true
  }

  export type Payment_gatewayMinAggregateInputType = {
    id?: true
    wallet_name?: true
    deposit_wallet_address?: true
    api_key?: true
    secret_key?: true
    gateway_type?: true
    is_active?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_gatewayMaxAggregateInputType = {
    id?: true
    wallet_name?: true
    deposit_wallet_address?: true
    api_key?: true
    secret_key?: true
    gateway_type?: true
    is_active?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_gatewayCountAggregateInputType = {
    id?: true
    wallet_name?: true
    deposit_wallet_address?: true
    api_key?: true
    secret_key?: true
    gateway_type?: true
    is_active?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Payment_gatewayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_gateway to aggregate.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_gateways
    **/
    _count?: true | Payment_gatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_gatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_gatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_gatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_gatewayMaxAggregateInputType
  }

  export type GetPayment_gatewayAggregateType<T extends Payment_gatewayAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_gateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_gateway[P]>
      : GetScalarType<T[P], AggregatePayment_gateway[P]>
  }




  export type payment_gatewayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_gatewayWhereInput
    orderBy?: payment_gatewayOrderByWithAggregationInput | payment_gatewayOrderByWithAggregationInput[]
    by: Payment_gatewayScalarFieldEnum[] | Payment_gatewayScalarFieldEnum
    having?: payment_gatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_gatewayCountAggregateInputType | true
    _avg?: Payment_gatewayAvgAggregateInputType
    _sum?: Payment_gatewaySumAggregateInputType
    _min?: Payment_gatewayMinAggregateInputType
    _max?: Payment_gatewayMaxAggregateInputType
  }

  export type Payment_gatewayGroupByOutputType = {
    id: number
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active: boolean
    description: string | null
    created_at: Date
    updated_at: Date
    _count: Payment_gatewayCountAggregateOutputType | null
    _avg: Payment_gatewayAvgAggregateOutputType | null
    _sum: Payment_gatewaySumAggregateOutputType | null
    _min: Payment_gatewayMinAggregateOutputType | null
    _max: Payment_gatewayMaxAggregateOutputType | null
  }

  type GetPayment_gatewayGroupByPayload<T extends payment_gatewayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_gatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_gatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_gatewayGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_gatewayGroupByOutputType[P]>
        }
      >
    >


  export type payment_gatewaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_gateway"]>

  export type payment_gatewaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_gateway"]>

  export type payment_gatewaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_gateway"]>

  export type payment_gatewaySelectScalar = {
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type payment_gatewayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wallet_name" | "deposit_wallet_address" | "api_key" | "secret_key" | "gateway_type" | "is_active" | "description" | "created_at" | "updated_at", ExtArgs["result"]["payment_gateway"]>

  export type $payment_gatewayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_gateway"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wallet_name: string
      deposit_wallet_address: string
      api_key: string
      secret_key: string
      gateway_type: string
      is_active: boolean
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payment_gateway"]>
    composites: {}
  }

  type payment_gatewayGetPayload<S extends boolean | null | undefined | payment_gatewayDefaultArgs> = $Result.GetResult<Prisma.$payment_gatewayPayload, S>

  type payment_gatewayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_gatewayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_gatewayCountAggregateInputType | true
    }

  export interface payment_gatewayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_gateway'], meta: { name: 'payment_gateway' } }
    /**
     * Find zero or one Payment_gateway that matches the filter.
     * @param {payment_gatewayFindUniqueArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_gatewayFindUniqueArgs>(args: SelectSubset<T, payment_gatewayFindUniqueArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_gateway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_gatewayFindUniqueOrThrowArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_gatewayFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_gatewayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_gateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayFindFirstArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_gatewayFindFirstArgs>(args?: SelectSubset<T, payment_gatewayFindFirstArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_gateway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayFindFirstOrThrowArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_gatewayFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_gatewayFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_gateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_gateways
     * const payment_gateways = await prisma.payment_gateway.findMany()
     * 
     * // Get first 10 Payment_gateways
     * const payment_gateways = await prisma.payment_gateway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_gatewayWithIdOnly = await prisma.payment_gateway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_gatewayFindManyArgs>(args?: SelectSubset<T, payment_gatewayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_gateway.
     * @param {payment_gatewayCreateArgs} args - Arguments to create a Payment_gateway.
     * @example
     * // Create one Payment_gateway
     * const Payment_gateway = await prisma.payment_gateway.create({
     *   data: {
     *     // ... data to create a Payment_gateway
     *   }
     * })
     * 
     */
    create<T extends payment_gatewayCreateArgs>(args: SelectSubset<T, payment_gatewayCreateArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_gateways.
     * @param {payment_gatewayCreateManyArgs} args - Arguments to create many Payment_gateways.
     * @example
     * // Create many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_gatewayCreateManyArgs>(args?: SelectSubset<T, payment_gatewayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_gateways and returns the data saved in the database.
     * @param {payment_gatewayCreateManyAndReturnArgs} args - Arguments to create many Payment_gateways.
     * @example
     * // Create many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_gateways and only return the `id`
     * const payment_gatewayWithIdOnly = await prisma.payment_gateway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_gatewayCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_gatewayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_gateway.
     * @param {payment_gatewayDeleteArgs} args - Arguments to delete one Payment_gateway.
     * @example
     * // Delete one Payment_gateway
     * const Payment_gateway = await prisma.payment_gateway.delete({
     *   where: {
     *     // ... filter to delete one Payment_gateway
     *   }
     * })
     * 
     */
    delete<T extends payment_gatewayDeleteArgs>(args: SelectSubset<T, payment_gatewayDeleteArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_gateway.
     * @param {payment_gatewayUpdateArgs} args - Arguments to update one Payment_gateway.
     * @example
     * // Update one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_gatewayUpdateArgs>(args: SelectSubset<T, payment_gatewayUpdateArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_gateways.
     * @param {payment_gatewayDeleteManyArgs} args - Arguments to filter Payment_gateways to delete.
     * @example
     * // Delete a few Payment_gateways
     * const { count } = await prisma.payment_gateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_gatewayDeleteManyArgs>(args?: SelectSubset<T, payment_gatewayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_gatewayUpdateManyArgs>(args: SelectSubset<T, payment_gatewayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_gateways and returns the data updated in the database.
     * @param {payment_gatewayUpdateManyAndReturnArgs} args - Arguments to update many Payment_gateways.
     * @example
     * // Update many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_gateways and only return the `id`
     * const payment_gatewayWithIdOnly = await prisma.payment_gateway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_gatewayUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_gatewayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_gateway.
     * @param {payment_gatewayUpsertArgs} args - Arguments to update or create a Payment_gateway.
     * @example
     * // Update or create a Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.upsert({
     *   create: {
     *     // ... data to create a Payment_gateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_gateway we want to update
     *   }
     * })
     */
    upsert<T extends payment_gatewayUpsertArgs>(args: SelectSubset<T, payment_gatewayUpsertArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayCountArgs} args - Arguments to filter Payment_gateways to count.
     * @example
     * // Count the number of Payment_gateways
     * const count = await prisma.payment_gateway.count({
     *   where: {
     *     // ... the filter for the Payment_gateways we want to count
     *   }
     * })
    **/
    count<T extends payment_gatewayCountArgs>(
      args?: Subset<T, payment_gatewayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_gatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_gatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_gatewayAggregateArgs>(args: Subset<T, Payment_gatewayAggregateArgs>): Prisma.PrismaPromise<GetPayment_gatewayAggregateType<T>>

    /**
     * Group by Payment_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_gatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_gatewayGroupByArgs['orderBy'] }
        : { orderBy?: payment_gatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_gatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_gatewayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_gateway model
   */
  readonly fields: payment_gatewayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_gateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_gatewayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_gateway model
   */
  interface payment_gatewayFieldRefs {
    readonly id: FieldRef<"payment_gateway", 'Int'>
    readonly wallet_name: FieldRef<"payment_gateway", 'String'>
    readonly deposit_wallet_address: FieldRef<"payment_gateway", 'String'>
    readonly api_key: FieldRef<"payment_gateway", 'String'>
    readonly secret_key: FieldRef<"payment_gateway", 'String'>
    readonly gateway_type: FieldRef<"payment_gateway", 'String'>
    readonly is_active: FieldRef<"payment_gateway", 'Boolean'>
    readonly description: FieldRef<"payment_gateway", 'String'>
    readonly created_at: FieldRef<"payment_gateway", 'DateTime'>
    readonly updated_at: FieldRef<"payment_gateway", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_gateway findUnique
   */
  export type payment_gatewayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway findUniqueOrThrow
   */
  export type payment_gatewayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway findFirst
   */
  export type payment_gatewayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_gateways.
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_gateways.
     */
    distinct?: Payment_gatewayScalarFieldEnum | Payment_gatewayScalarFieldEnum[]
  }

  /**
   * payment_gateway findFirstOrThrow
   */
  export type payment_gatewayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_gateways.
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_gateways.
     */
    distinct?: Payment_gatewayScalarFieldEnum | Payment_gatewayScalarFieldEnum[]
  }

  /**
   * payment_gateway findMany
   */
  export type payment_gatewayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateways to fetch.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_gateways.
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    distinct?: Payment_gatewayScalarFieldEnum | Payment_gatewayScalarFieldEnum[]
  }

  /**
   * payment_gateway create
   */
  export type payment_gatewayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to create a payment_gateway.
     */
    data: XOR<payment_gatewayCreateInput, payment_gatewayUncheckedCreateInput>
  }

  /**
   * payment_gateway createMany
   */
  export type payment_gatewayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_gateways.
     */
    data: payment_gatewayCreateManyInput | payment_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_gateway createManyAndReturn
   */
  export type payment_gatewayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data used to create many payment_gateways.
     */
    data: payment_gatewayCreateManyInput | payment_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_gateway update
   */
  export type payment_gatewayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to update a payment_gateway.
     */
    data: XOR<payment_gatewayUpdateInput, payment_gatewayUncheckedUpdateInput>
    /**
     * Choose, which payment_gateway to update.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway updateMany
   */
  export type payment_gatewayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_gateways.
     */
    data: XOR<payment_gatewayUpdateManyMutationInput, payment_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which payment_gateways to update
     */
    where?: payment_gatewayWhereInput
    /**
     * Limit how many payment_gateways to update.
     */
    limit?: number
  }

  /**
   * payment_gateway updateManyAndReturn
   */
  export type payment_gatewayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data used to update payment_gateways.
     */
    data: XOR<payment_gatewayUpdateManyMutationInput, payment_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which payment_gateways to update
     */
    where?: payment_gatewayWhereInput
    /**
     * Limit how many payment_gateways to update.
     */
    limit?: number
  }

  /**
   * payment_gateway upsert
   */
  export type payment_gatewayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The filter to search for the payment_gateway to update in case it exists.
     */
    where: payment_gatewayWhereUniqueInput
    /**
     * In case the payment_gateway found by the `where` argument doesn't exist, create a new payment_gateway with this data.
     */
    create: XOR<payment_gatewayCreateInput, payment_gatewayUncheckedCreateInput>
    /**
     * In case the payment_gateway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_gatewayUpdateInput, payment_gatewayUncheckedUpdateInput>
  }

  /**
   * payment_gateway delete
   */
  export type payment_gatewayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter which payment_gateway to delete.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway deleteMany
   */
  export type payment_gatewayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_gateways to delete
     */
    where?: payment_gatewayWhereInput
    /**
     * Limit how many payment_gateways to delete.
     */
    limit?: number
  }

  /**
   * payment_gateway without action
   */
  export type payment_gatewayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
  }


  /**
   * Model symbols
   */

  export type AggregateSymbols = {
    _count: SymbolsCountAggregateOutputType | null
    _avg: SymbolsAvgAggregateOutputType | null
    _sum: SymbolsSumAggregateOutputType | null
    _min: SymbolsMinAggregateOutputType | null
    _max: SymbolsMaxAggregateOutputType | null
  }

  export type SymbolsAvgAggregateOutputType = {
    id: number | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    swap_long: number | null
    swap_short: number | null
  }

  export type SymbolsSumAggregateOutputType = {
    id: number | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    swap_long: number | null
    swap_short: number | null
  }

  export type SymbolsMinAggregateOutputType = {
    id: number | null
    symbol_name: string | null
    description: string | null
    symbol_type: string | null
    group_name: string | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    profit_mode: string | null
    enable: boolean | null
    swap_mode: string | null
    swap_long: number | null
    swap_short: number | null
    swap3_day: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SymbolsMaxAggregateOutputType = {
    id: number | null
    symbol_name: string | null
    description: string | null
    symbol_type: string | null
    group_name: string | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    profit_mode: string | null
    enable: boolean | null
    swap_mode: string | null
    swap_long: number | null
    swap_short: number | null
    swap3_day: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SymbolsCountAggregateOutputType = {
    id: number
    symbol_name: number
    description: number
    symbol_type: number
    group_name: number
    digits: number
    spread: number
    contract_size: number
    profit_mode: number
    enable: number
    swap_mode: number
    swap_long: number
    swap_short: number
    swap3_day: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SymbolsAvgAggregateInputType = {
    id?: true
    digits?: true
    spread?: true
    contract_size?: true
    swap_long?: true
    swap_short?: true
  }

  export type SymbolsSumAggregateInputType = {
    id?: true
    digits?: true
    spread?: true
    contract_size?: true
    swap_long?: true
    swap_short?: true
  }

  export type SymbolsMinAggregateInputType = {
    id?: true
    symbol_name?: true
    description?: true
    symbol_type?: true
    group_name?: true
    digits?: true
    spread?: true
    contract_size?: true
    profit_mode?: true
    enable?: true
    swap_mode?: true
    swap_long?: true
    swap_short?: true
    swap3_day?: true
    created_at?: true
    updated_at?: true
  }

  export type SymbolsMaxAggregateInputType = {
    id?: true
    symbol_name?: true
    description?: true
    symbol_type?: true
    group_name?: true
    digits?: true
    spread?: true
    contract_size?: true
    profit_mode?: true
    enable?: true
    swap_mode?: true
    swap_long?: true
    swap_short?: true
    swap3_day?: true
    created_at?: true
    updated_at?: true
  }

  export type SymbolsCountAggregateInputType = {
    id?: true
    symbol_name?: true
    description?: true
    symbol_type?: true
    group_name?: true
    digits?: true
    spread?: true
    contract_size?: true
    profit_mode?: true
    enable?: true
    swap_mode?: true
    swap_long?: true
    swap_short?: true
    swap3_day?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SymbolsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which symbols to aggregate.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned symbols
    **/
    _count?: true | SymbolsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SymbolsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SymbolsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymbolsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymbolsMaxAggregateInputType
  }

  export type GetSymbolsAggregateType<T extends SymbolsAggregateArgs> = {
        [P in keyof T & keyof AggregateSymbols]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbols[P]>
      : GetScalarType<T[P], AggregateSymbols[P]>
  }




  export type symbolsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: symbolsWhereInput
    orderBy?: symbolsOrderByWithAggregationInput | symbolsOrderByWithAggregationInput[]
    by: SymbolsScalarFieldEnum[] | SymbolsScalarFieldEnum
    having?: symbolsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymbolsCountAggregateInputType | true
    _avg?: SymbolsAvgAggregateInputType
    _sum?: SymbolsSumAggregateInputType
    _min?: SymbolsMinAggregateInputType
    _max?: SymbolsMaxAggregateInputType
  }

  export type SymbolsGroupByOutputType = {
    id: number
    symbol_name: string
    description: string | null
    symbol_type: string | null
    group_name: string | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    profit_mode: string | null
    enable: boolean | null
    swap_mode: string | null
    swap_long: number | null
    swap_short: number | null
    swap3_day: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: SymbolsCountAggregateOutputType | null
    _avg: SymbolsAvgAggregateOutputType | null
    _sum: SymbolsSumAggregateOutputType | null
    _min: SymbolsMinAggregateOutputType | null
    _max: SymbolsMaxAggregateOutputType | null
  }

  type GetSymbolsGroupByPayload<T extends symbolsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymbolsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymbolsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymbolsGroupByOutputType[P]>
            : GetScalarType<T[P], SymbolsGroupByOutputType[P]>
        }
      >
    >


  export type symbolsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols"]>

  export type symbolsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols"]>

  export type symbolsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols"]>

  export type symbolsSelectScalar = {
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type symbolsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol_name" | "description" | "symbol_type" | "group_name" | "digits" | "spread" | "contract_size" | "profit_mode" | "enable" | "swap_mode" | "swap_long" | "swap_short" | "swap3_day" | "created_at" | "updated_at", ExtArgs["result"]["symbols"]>

  export type $symbolsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "symbols"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol_name: string
      description: string | null
      symbol_type: string | null
      group_name: string | null
      digits: number | null
      spread: number | null
      contract_size: number | null
      profit_mode: string | null
      enable: boolean | null
      swap_mode: string | null
      swap_long: number | null
      swap_short: number | null
      swap3_day: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["symbols"]>
    composites: {}
  }

  type symbolsGetPayload<S extends boolean | null | undefined | symbolsDefaultArgs> = $Result.GetResult<Prisma.$symbolsPayload, S>

  type symbolsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<symbolsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SymbolsCountAggregateInputType | true
    }

  export interface symbolsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['symbols'], meta: { name: 'symbols' } }
    /**
     * Find zero or one Symbols that matches the filter.
     * @param {symbolsFindUniqueArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends symbolsFindUniqueArgs>(args: SelectSubset<T, symbolsFindUniqueArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Symbols that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {symbolsFindUniqueOrThrowArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends symbolsFindUniqueOrThrowArgs>(args: SelectSubset<T, symbolsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsFindFirstArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends symbolsFindFirstArgs>(args?: SelectSubset<T, symbolsFindFirstArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbols that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsFindFirstOrThrowArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends symbolsFindFirstOrThrowArgs>(args?: SelectSubset<T, symbolsFindFirstOrThrowArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symbols
     * const symbols = await prisma.symbols.findMany()
     * 
     * // Get first 10 Symbols
     * const symbols = await prisma.symbols.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symbolsWithIdOnly = await prisma.symbols.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends symbolsFindManyArgs>(args?: SelectSubset<T, symbolsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Symbols.
     * @param {symbolsCreateArgs} args - Arguments to create a Symbols.
     * @example
     * // Create one Symbols
     * const Symbols = await prisma.symbols.create({
     *   data: {
     *     // ... data to create a Symbols
     *   }
     * })
     * 
     */
    create<T extends symbolsCreateArgs>(args: SelectSubset<T, symbolsCreateArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Symbols.
     * @param {symbolsCreateManyArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbols = await prisma.symbols.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends symbolsCreateManyArgs>(args?: SelectSubset<T, symbolsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Symbols and returns the data saved in the database.
     * @param {symbolsCreateManyAndReturnArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbols = await prisma.symbols.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Symbols and only return the `id`
     * const symbolsWithIdOnly = await prisma.symbols.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends symbolsCreateManyAndReturnArgs>(args?: SelectSubset<T, symbolsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Symbols.
     * @param {symbolsDeleteArgs} args - Arguments to delete one Symbols.
     * @example
     * // Delete one Symbols
     * const Symbols = await prisma.symbols.delete({
     *   where: {
     *     // ... filter to delete one Symbols
     *   }
     * })
     * 
     */
    delete<T extends symbolsDeleteArgs>(args: SelectSubset<T, symbolsDeleteArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Symbols.
     * @param {symbolsUpdateArgs} args - Arguments to update one Symbols.
     * @example
     * // Update one Symbols
     * const symbols = await prisma.symbols.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends symbolsUpdateArgs>(args: SelectSubset<T, symbolsUpdateArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Symbols.
     * @param {symbolsDeleteManyArgs} args - Arguments to filter Symbols to delete.
     * @example
     * // Delete a few Symbols
     * const { count } = await prisma.symbols.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends symbolsDeleteManyArgs>(args?: SelectSubset<T, symbolsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symbols
     * const symbols = await prisma.symbols.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends symbolsUpdateManyArgs>(args: SelectSubset<T, symbolsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols and returns the data updated in the database.
     * @param {symbolsUpdateManyAndReturnArgs} args - Arguments to update many Symbols.
     * @example
     * // Update many Symbols
     * const symbols = await prisma.symbols.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Symbols and only return the `id`
     * const symbolsWithIdOnly = await prisma.symbols.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends symbolsUpdateManyAndReturnArgs>(args: SelectSubset<T, symbolsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Symbols.
     * @param {symbolsUpsertArgs} args - Arguments to update or create a Symbols.
     * @example
     * // Update or create a Symbols
     * const symbols = await prisma.symbols.upsert({
     *   create: {
     *     // ... data to create a Symbols
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symbols we want to update
     *   }
     * })
     */
    upsert<T extends symbolsUpsertArgs>(args: SelectSubset<T, symbolsUpsertArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsCountArgs} args - Arguments to filter Symbols to count.
     * @example
     * // Count the number of Symbols
     * const count = await prisma.symbols.count({
     *   where: {
     *     // ... the filter for the Symbols we want to count
     *   }
     * })
    **/
    count<T extends symbolsCountArgs>(
      args?: Subset<T, symbolsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymbolsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymbolsAggregateArgs>(args: Subset<T, SymbolsAggregateArgs>): Prisma.PrismaPromise<GetSymbolsAggregateType<T>>

    /**
     * Group by Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends symbolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: symbolsGroupByArgs['orderBy'] }
        : { orderBy?: symbolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, symbolsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymbolsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the symbols model
   */
  readonly fields: symbolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for symbols.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__symbolsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the symbols model
   */
  interface symbolsFieldRefs {
    readonly id: FieldRef<"symbols", 'Int'>
    readonly symbol_name: FieldRef<"symbols", 'String'>
    readonly description: FieldRef<"symbols", 'String'>
    readonly symbol_type: FieldRef<"symbols", 'String'>
    readonly group_name: FieldRef<"symbols", 'String'>
    readonly digits: FieldRef<"symbols", 'Int'>
    readonly spread: FieldRef<"symbols", 'Float'>
    readonly contract_size: FieldRef<"symbols", 'Int'>
    readonly profit_mode: FieldRef<"symbols", 'String'>
    readonly enable: FieldRef<"symbols", 'Boolean'>
    readonly swap_mode: FieldRef<"symbols", 'String'>
    readonly swap_long: FieldRef<"symbols", 'Float'>
    readonly swap_short: FieldRef<"symbols", 'Float'>
    readonly swap3_day: FieldRef<"symbols", 'String'>
    readonly created_at: FieldRef<"symbols", 'DateTime'>
    readonly updated_at: FieldRef<"symbols", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * symbols findUnique
   */
  export type symbolsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols findUniqueOrThrow
   */
  export type symbolsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols findFirst
   */
  export type symbolsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for symbols.
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of symbols.
     */
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[]
  }

  /**
   * symbols findFirstOrThrow
   */
  export type symbolsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for symbols.
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of symbols.
     */
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[]
  }

  /**
   * symbols findMany
   */
  export type symbolsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing symbols.
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[]
  }

  /**
   * symbols create
   */
  export type symbolsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data needed to create a symbols.
     */
    data: XOR<symbolsCreateInput, symbolsUncheckedCreateInput>
  }

  /**
   * symbols createMany
   */
  export type symbolsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many symbols.
     */
    data: symbolsCreateManyInput | symbolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * symbols createManyAndReturn
   */
  export type symbolsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data used to create many symbols.
     */
    data: symbolsCreateManyInput | symbolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * symbols update
   */
  export type symbolsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data needed to update a symbols.
     */
    data: XOR<symbolsUpdateInput, symbolsUncheckedUpdateInput>
    /**
     * Choose, which symbols to update.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols updateMany
   */
  export type symbolsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update symbols.
     */
    data: XOR<symbolsUpdateManyMutationInput, symbolsUncheckedUpdateManyInput>
    /**
     * Filter which symbols to update
     */
    where?: symbolsWhereInput
    /**
     * Limit how many symbols to update.
     */
    limit?: number
  }

  /**
   * symbols updateManyAndReturn
   */
  export type symbolsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data used to update symbols.
     */
    data: XOR<symbolsUpdateManyMutationInput, symbolsUncheckedUpdateManyInput>
    /**
     * Filter which symbols to update
     */
    where?: symbolsWhereInput
    /**
     * Limit how many symbols to update.
     */
    limit?: number
  }

  /**
   * symbols upsert
   */
  export type symbolsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The filter to search for the symbols to update in case it exists.
     */
    where: symbolsWhereUniqueInput
    /**
     * In case the symbols found by the `where` argument doesn't exist, create a new symbols with this data.
     */
    create: XOR<symbolsCreateInput, symbolsUncheckedCreateInput>
    /**
     * In case the symbols was found with the provided `where` argument, update it with this data.
     */
    update: XOR<symbolsUpdateInput, symbolsUncheckedUpdateInput>
  }

  /**
   * symbols delete
   */
  export type symbolsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter which symbols to delete.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols deleteMany
   */
  export type symbolsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which symbols to delete
     */
    where?: symbolsWhereInput
    /**
     * Limit how many symbols to delete.
     */
    limit?: number
  }

  /**
   * symbols without action
   */
  export type symbolsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
  }


  /**
   * Model ib_group_assignments
   */

  export type AggregateIb_group_assignments = {
    _count: Ib_group_assignmentsCountAggregateOutputType | null
    _avg: Ib_group_assignmentsAvgAggregateOutputType | null
    _sum: Ib_group_assignmentsSumAggregateOutputType | null
    _min: Ib_group_assignmentsMinAggregateOutputType | null
    _max: Ib_group_assignmentsMaxAggregateOutputType | null
  }

  export type Ib_group_assignmentsAvgAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    structure_id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
  }

  export type Ib_group_assignmentsSumAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    structure_id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
  }

  export type Ib_group_assignmentsMinAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    group_id: string | null
    group_name: string | null
    structure_id: number | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_group_assignmentsMaxAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    group_id: string | null
    group_name: string | null
    structure_id: number | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_group_assignmentsCountAggregateOutputType = {
    id: number
    ib_request_id: number
    group_id: number
    group_name: number
    structure_id: number
    structure_name: number
    usd_per_lot: number
    spread_share_percentage: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ib_group_assignmentsAvgAggregateInputType = {
    id?: true
    ib_request_id?: true
    structure_id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
  }

  export type Ib_group_assignmentsSumAggregateInputType = {
    id?: true
    ib_request_id?: true
    structure_id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
  }

  export type Ib_group_assignmentsMinAggregateInputType = {
    id?: true
    ib_request_id?: true
    group_id?: true
    group_name?: true
    structure_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_group_assignmentsMaxAggregateInputType = {
    id?: true
    ib_request_id?: true
    group_id?: true
    group_name?: true
    structure_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_group_assignmentsCountAggregateInputType = {
    id?: true
    ib_request_id?: true
    group_id?: true
    group_name?: true
    structure_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ib_group_assignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_group_assignments to aggregate.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_group_assignments
    **/
    _count?: true | Ib_group_assignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_group_assignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_group_assignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_group_assignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_group_assignmentsMaxAggregateInputType
  }

  export type GetIb_group_assignmentsAggregateType<T extends Ib_group_assignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_group_assignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_group_assignments[P]>
      : GetScalarType<T[P], AggregateIb_group_assignments[P]>
  }




  export type ib_group_assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_group_assignmentsWhereInput
    orderBy?: ib_group_assignmentsOrderByWithAggregationInput | ib_group_assignmentsOrderByWithAggregationInput[]
    by: Ib_group_assignmentsScalarFieldEnum[] | Ib_group_assignmentsScalarFieldEnum
    having?: ib_group_assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_group_assignmentsCountAggregateInputType | true
    _avg?: Ib_group_assignmentsAvgAggregateInputType
    _sum?: Ib_group_assignmentsSumAggregateInputType
    _min?: Ib_group_assignmentsMinAggregateInputType
    _max?: Ib_group_assignmentsMaxAggregateInputType
  }

  export type Ib_group_assignmentsGroupByOutputType = {
    id: number
    ib_request_id: number | null
    group_id: string
    group_name: string | null
    structure_id: number | null
    structure_name: string | null
    usd_per_lot: Decimal
    spread_share_percentage: Decimal
    created_at: Date | null
    updated_at: Date | null
    _count: Ib_group_assignmentsCountAggregateOutputType | null
    _avg: Ib_group_assignmentsAvgAggregateOutputType | null
    _sum: Ib_group_assignmentsSumAggregateOutputType | null
    _min: Ib_group_assignmentsMinAggregateOutputType | null
    _max: Ib_group_assignmentsMaxAggregateOutputType | null
  }

  type GetIb_group_assignmentsGroupByPayload<T extends ib_group_assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_group_assignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_group_assignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_group_assignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_group_assignmentsGroupByOutputType[P]>
        }
      >
    >


  export type ib_group_assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }, ExtArgs["result"]["ib_group_assignments"]>

  export type ib_group_assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }, ExtArgs["result"]["ib_group_assignments"]>

  export type ib_group_assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }, ExtArgs["result"]["ib_group_assignments"]>

  export type ib_group_assignmentsSelectScalar = {
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ib_group_assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ib_request_id" | "group_id" | "group_name" | "structure_id" | "structure_name" | "usd_per_lot" | "spread_share_percentage" | "created_at" | "updated_at", ExtArgs["result"]["ib_group_assignments"]>
  export type ib_group_assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }
  export type ib_group_assignmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }
  export type ib_group_assignmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }

  export type $ib_group_assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_group_assignments"
    objects: {
      ib_requests: Prisma.$ib_requestsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ib_request_id: number | null
      group_id: string
      group_name: string | null
      structure_id: number | null
      structure_name: string | null
      usd_per_lot: Prisma.Decimal
      spread_share_percentage: Prisma.Decimal
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ib_group_assignments"]>
    composites: {}
  }

  type ib_group_assignmentsGetPayload<S extends boolean | null | undefined | ib_group_assignmentsDefaultArgs> = $Result.GetResult<Prisma.$ib_group_assignmentsPayload, S>

  type ib_group_assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_group_assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_group_assignmentsCountAggregateInputType | true
    }

  export interface ib_group_assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_group_assignments'], meta: { name: 'ib_group_assignments' } }
    /**
     * Find zero or one Ib_group_assignments that matches the filter.
     * @param {ib_group_assignmentsFindUniqueArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_group_assignmentsFindUniqueArgs>(args: SelectSubset<T, ib_group_assignmentsFindUniqueArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_group_assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_group_assignmentsFindUniqueOrThrowArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_group_assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_group_assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_group_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsFindFirstArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_group_assignmentsFindFirstArgs>(args?: SelectSubset<T, ib_group_assignmentsFindFirstArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_group_assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsFindFirstOrThrowArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_group_assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_group_assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_group_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findMany()
     * 
     * // Get first 10 Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_group_assignmentsWithIdOnly = await prisma.ib_group_assignments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_group_assignmentsFindManyArgs>(args?: SelectSubset<T, ib_group_assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_group_assignments.
     * @param {ib_group_assignmentsCreateArgs} args - Arguments to create a Ib_group_assignments.
     * @example
     * // Create one Ib_group_assignments
     * const Ib_group_assignments = await prisma.ib_group_assignments.create({
     *   data: {
     *     // ... data to create a Ib_group_assignments
     *   }
     * })
     * 
     */
    create<T extends ib_group_assignmentsCreateArgs>(args: SelectSubset<T, ib_group_assignmentsCreateArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_group_assignments.
     * @param {ib_group_assignmentsCreateManyArgs} args - Arguments to create many Ib_group_assignments.
     * @example
     * // Create many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_group_assignmentsCreateManyArgs>(args?: SelectSubset<T, ib_group_assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_group_assignments and returns the data saved in the database.
     * @param {ib_group_assignmentsCreateManyAndReturnArgs} args - Arguments to create many Ib_group_assignments.
     * @example
     * // Create many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_group_assignments and only return the `id`
     * const ib_group_assignmentsWithIdOnly = await prisma.ib_group_assignments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_group_assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_group_assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_group_assignments.
     * @param {ib_group_assignmentsDeleteArgs} args - Arguments to delete one Ib_group_assignments.
     * @example
     * // Delete one Ib_group_assignments
     * const Ib_group_assignments = await prisma.ib_group_assignments.delete({
     *   where: {
     *     // ... filter to delete one Ib_group_assignments
     *   }
     * })
     * 
     */
    delete<T extends ib_group_assignmentsDeleteArgs>(args: SelectSubset<T, ib_group_assignmentsDeleteArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_group_assignments.
     * @param {ib_group_assignmentsUpdateArgs} args - Arguments to update one Ib_group_assignments.
     * @example
     * // Update one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_group_assignmentsUpdateArgs>(args: SelectSubset<T, ib_group_assignmentsUpdateArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_group_assignments.
     * @param {ib_group_assignmentsDeleteManyArgs} args - Arguments to filter Ib_group_assignments to delete.
     * @example
     * // Delete a few Ib_group_assignments
     * const { count } = await prisma.ib_group_assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_group_assignmentsDeleteManyArgs>(args?: SelectSubset<T, ib_group_assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_group_assignmentsUpdateManyArgs>(args: SelectSubset<T, ib_group_assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_group_assignments and returns the data updated in the database.
     * @param {ib_group_assignmentsUpdateManyAndReturnArgs} args - Arguments to update many Ib_group_assignments.
     * @example
     * // Update many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_group_assignments and only return the `id`
     * const ib_group_assignmentsWithIdOnly = await prisma.ib_group_assignments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_group_assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_group_assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_group_assignments.
     * @param {ib_group_assignmentsUpsertArgs} args - Arguments to update or create a Ib_group_assignments.
     * @example
     * // Update or create a Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.upsert({
     *   create: {
     *     // ... data to create a Ib_group_assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_group_assignments we want to update
     *   }
     * })
     */
    upsert<T extends ib_group_assignmentsUpsertArgs>(args: SelectSubset<T, ib_group_assignmentsUpsertArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsCountArgs} args - Arguments to filter Ib_group_assignments to count.
     * @example
     * // Count the number of Ib_group_assignments
     * const count = await prisma.ib_group_assignments.count({
     *   where: {
     *     // ... the filter for the Ib_group_assignments we want to count
     *   }
     * })
    **/
    count<T extends ib_group_assignmentsCountArgs>(
      args?: Subset<T, ib_group_assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_group_assignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_group_assignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_group_assignmentsAggregateArgs>(args: Subset<T, Ib_group_assignmentsAggregateArgs>): Prisma.PrismaPromise<GetIb_group_assignmentsAggregateType<T>>

    /**
     * Group by Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_group_assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_group_assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: ib_group_assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_group_assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_group_assignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_group_assignments model
   */
  readonly fields: ib_group_assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_group_assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_group_assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ib_requests<T extends ib_group_assignments$ib_requestsArgs<ExtArgs> = {}>(args?: Subset<T, ib_group_assignments$ib_requestsArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_group_assignments model
   */
  interface ib_group_assignmentsFieldRefs {
    readonly id: FieldRef<"ib_group_assignments", 'Int'>
    readonly ib_request_id: FieldRef<"ib_group_assignments", 'Int'>
    readonly group_id: FieldRef<"ib_group_assignments", 'String'>
    readonly group_name: FieldRef<"ib_group_assignments", 'String'>
    readonly structure_id: FieldRef<"ib_group_assignments", 'Int'>
    readonly structure_name: FieldRef<"ib_group_assignments", 'String'>
    readonly usd_per_lot: FieldRef<"ib_group_assignments", 'Decimal'>
    readonly spread_share_percentage: FieldRef<"ib_group_assignments", 'Decimal'>
    readonly created_at: FieldRef<"ib_group_assignments", 'DateTime'>
    readonly updated_at: FieldRef<"ib_group_assignments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_group_assignments findUnique
   */
  export type ib_group_assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments findUniqueOrThrow
   */
  export type ib_group_assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments findFirst
   */
  export type ib_group_assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_group_assignments.
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_group_assignments.
     */
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_group_assignments findFirstOrThrow
   */
  export type ib_group_assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_group_assignments.
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_group_assignments.
     */
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_group_assignments findMany
   */
  export type ib_group_assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_group_assignments.
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_group_assignments create
   */
  export type ib_group_assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsCreateInput, ib_group_assignmentsUncheckedCreateInput>
  }

  /**
   * ib_group_assignments createMany
   */
  export type ib_group_assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_group_assignments.
     */
    data: ib_group_assignmentsCreateManyInput | ib_group_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_group_assignments createManyAndReturn
   */
  export type ib_group_assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many ib_group_assignments.
     */
    data: ib_group_assignmentsCreateManyInput | ib_group_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ib_group_assignments update
   */
  export type ib_group_assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsUpdateInput, ib_group_assignmentsUncheckedUpdateInput>
    /**
     * Choose, which ib_group_assignments to update.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments updateMany
   */
  export type ib_group_assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsUpdateManyMutationInput, ib_group_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which ib_group_assignments to update
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * Limit how many ib_group_assignments to update.
     */
    limit?: number
  }

  /**
   * ib_group_assignments updateManyAndReturn
   */
  export type ib_group_assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsUpdateManyMutationInput, ib_group_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which ib_group_assignments to update
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * Limit how many ib_group_assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ib_group_assignments upsert
   */
  export type ib_group_assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the ib_group_assignments to update in case it exists.
     */
    where: ib_group_assignmentsWhereUniqueInput
    /**
     * In case the ib_group_assignments found by the `where` argument doesn't exist, create a new ib_group_assignments with this data.
     */
    create: XOR<ib_group_assignmentsCreateInput, ib_group_assignmentsUncheckedCreateInput>
    /**
     * In case the ib_group_assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_group_assignmentsUpdateInput, ib_group_assignmentsUncheckedUpdateInput>
  }

  /**
   * ib_group_assignments delete
   */
  export type ib_group_assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter which ib_group_assignments to delete.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments deleteMany
   */
  export type ib_group_assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_group_assignments to delete
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * Limit how many ib_group_assignments to delete.
     */
    limit?: number
  }

  /**
   * ib_group_assignments.ib_requests
   */
  export type ib_group_assignments$ib_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    where?: ib_requestsWhereInput
  }

  /**
   * ib_group_assignments without action
   */
  export type ib_group_assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
  }


  /**
   * Model ib_trade_history
   */

  export type AggregateIb_trade_history = {
    _count: Ib_trade_historyCountAggregateOutputType | null
    _avg: Ib_trade_historyAvgAggregateOutputType | null
    _sum: Ib_trade_historySumAggregateOutputType | null
    _min: Ib_trade_historyMinAggregateOutputType | null
    _max: Ib_trade_historyMaxAggregateOutputType | null
  }

  export type Ib_trade_historyAvgAggregateOutputType = {
    ib_request_id: number | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
  }

  export type Ib_trade_historySumAggregateOutputType = {
    ib_request_id: number | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
  }

  export type Ib_trade_historyMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    account_id: string | null
    user_id: string | null
    ib_request_id: number | null
    symbol: string | null
    order_type: string | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    synced_at: Date | null
    group_id: string | null
  }

  export type Ib_trade_historyMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    account_id: string | null
    user_id: string | null
    ib_request_id: number | null
    symbol: string | null
    order_type: string | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    synced_at: Date | null
    group_id: string | null
  }

  export type Ib_trade_historyCountAggregateOutputType = {
    id: number
    order_id: number
    account_id: number
    user_id: number
    ib_request_id: number
    symbol: number
    order_type: number
    volume_lots: number
    open_price: number
    close_price: number
    profit: number
    ib_commission: number
    take_profit: number
    stop_loss: number
    created_at: number
    updated_at: number
    synced_at: number
    group_id: number
    _all: number
  }


  export type Ib_trade_historyAvgAggregateInputType = {
    ib_request_id?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
  }

  export type Ib_trade_historySumAggregateInputType = {
    ib_request_id?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
  }

  export type Ib_trade_historyMinAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    user_id?: true
    ib_request_id?: true
    symbol?: true
    order_type?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
    created_at?: true
    updated_at?: true
    synced_at?: true
    group_id?: true
  }

  export type Ib_trade_historyMaxAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    user_id?: true
    ib_request_id?: true
    symbol?: true
    order_type?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
    created_at?: true
    updated_at?: true
    synced_at?: true
    group_id?: true
  }

  export type Ib_trade_historyCountAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    user_id?: true
    ib_request_id?: true
    symbol?: true
    order_type?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
    created_at?: true
    updated_at?: true
    synced_at?: true
    group_id?: true
    _all?: true
  }

  export type Ib_trade_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_trade_history to aggregate.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_trade_histories
    **/
    _count?: true | Ib_trade_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_trade_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_trade_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_trade_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_trade_historyMaxAggregateInputType
  }

  export type GetIb_trade_historyAggregateType<T extends Ib_trade_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_trade_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_trade_history[P]>
      : GetScalarType<T[P], AggregateIb_trade_history[P]>
  }




  export type ib_trade_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_trade_historyWhereInput
    orderBy?: ib_trade_historyOrderByWithAggregationInput | ib_trade_historyOrderByWithAggregationInput[]
    by: Ib_trade_historyScalarFieldEnum[] | Ib_trade_historyScalarFieldEnum
    having?: ib_trade_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_trade_historyCountAggregateInputType | true
    _avg?: Ib_trade_historyAvgAggregateInputType
    _sum?: Ib_trade_historySumAggregateInputType
    _min?: Ib_trade_historyMinAggregateInputType
    _max?: Ib_trade_historyMaxAggregateInputType
  }

  export type Ib_trade_historyGroupByOutputType = {
    id: string
    order_id: string
    account_id: string
    user_id: string | null
    ib_request_id: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    synced_at: Date | null
    group_id: string | null
    _count: Ib_trade_historyCountAggregateOutputType | null
    _avg: Ib_trade_historyAvgAggregateOutputType | null
    _sum: Ib_trade_historySumAggregateOutputType | null
    _min: Ib_trade_historyMinAggregateOutputType | null
    _max: Ib_trade_historyMaxAggregateOutputType | null
  }

  type GetIb_trade_historyGroupByPayload<T extends ib_trade_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_trade_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_trade_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_trade_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_trade_historyGroupByOutputType[P]>
        }
      >
    >


  export type ib_trade_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }, ExtArgs["result"]["ib_trade_history"]>

  export type ib_trade_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }, ExtArgs["result"]["ib_trade_history"]>

  export type ib_trade_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }, ExtArgs["result"]["ib_trade_history"]>

  export type ib_trade_historySelectScalar = {
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }

  export type ib_trade_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order_id" | "account_id" | "user_id" | "ib_request_id" | "symbol" | "order_type" | "volume_lots" | "open_price" | "close_price" | "profit" | "ib_commission" | "take_profit" | "stop_loss" | "created_at" | "updated_at" | "synced_at" | "group_id", ExtArgs["result"]["ib_trade_history"]>

  export type $ib_trade_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_trade_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_id: string
      account_id: string
      user_id: string | null
      ib_request_id: number | null
      symbol: string
      order_type: string
      volume_lots: Prisma.Decimal
      open_price: Prisma.Decimal | null
      close_price: Prisma.Decimal | null
      profit: Prisma.Decimal | null
      ib_commission: Prisma.Decimal | null
      take_profit: Prisma.Decimal | null
      stop_loss: Prisma.Decimal | null
      created_at: Date | null
      updated_at: Date | null
      synced_at: Date | null
      group_id: string | null
    }, ExtArgs["result"]["ib_trade_history"]>
    composites: {}
  }

  type ib_trade_historyGetPayload<S extends boolean | null | undefined | ib_trade_historyDefaultArgs> = $Result.GetResult<Prisma.$ib_trade_historyPayload, S>

  type ib_trade_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_trade_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_trade_historyCountAggregateInputType | true
    }

  export interface ib_trade_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_trade_history'], meta: { name: 'ib_trade_history' } }
    /**
     * Find zero or one Ib_trade_history that matches the filter.
     * @param {ib_trade_historyFindUniqueArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_trade_historyFindUniqueArgs>(args: SelectSubset<T, ib_trade_historyFindUniqueArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_trade_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_trade_historyFindUniqueOrThrowArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_trade_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_trade_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_trade_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyFindFirstArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_trade_historyFindFirstArgs>(args?: SelectSubset<T, ib_trade_historyFindFirstArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_trade_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyFindFirstOrThrowArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_trade_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_trade_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_trade_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_trade_histories
     * const ib_trade_histories = await prisma.ib_trade_history.findMany()
     * 
     * // Get first 10 Ib_trade_histories
     * const ib_trade_histories = await prisma.ib_trade_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_trade_historyWithIdOnly = await prisma.ib_trade_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_trade_historyFindManyArgs>(args?: SelectSubset<T, ib_trade_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_trade_history.
     * @param {ib_trade_historyCreateArgs} args - Arguments to create a Ib_trade_history.
     * @example
     * // Create one Ib_trade_history
     * const Ib_trade_history = await prisma.ib_trade_history.create({
     *   data: {
     *     // ... data to create a Ib_trade_history
     *   }
     * })
     * 
     */
    create<T extends ib_trade_historyCreateArgs>(args: SelectSubset<T, ib_trade_historyCreateArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_trade_histories.
     * @param {ib_trade_historyCreateManyArgs} args - Arguments to create many Ib_trade_histories.
     * @example
     * // Create many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_trade_historyCreateManyArgs>(args?: SelectSubset<T, ib_trade_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_trade_histories and returns the data saved in the database.
     * @param {ib_trade_historyCreateManyAndReturnArgs} args - Arguments to create many Ib_trade_histories.
     * @example
     * // Create many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_trade_histories and only return the `id`
     * const ib_trade_historyWithIdOnly = await prisma.ib_trade_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_trade_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_trade_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_trade_history.
     * @param {ib_trade_historyDeleteArgs} args - Arguments to delete one Ib_trade_history.
     * @example
     * // Delete one Ib_trade_history
     * const Ib_trade_history = await prisma.ib_trade_history.delete({
     *   where: {
     *     // ... filter to delete one Ib_trade_history
     *   }
     * })
     * 
     */
    delete<T extends ib_trade_historyDeleteArgs>(args: SelectSubset<T, ib_trade_historyDeleteArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_trade_history.
     * @param {ib_trade_historyUpdateArgs} args - Arguments to update one Ib_trade_history.
     * @example
     * // Update one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_trade_historyUpdateArgs>(args: SelectSubset<T, ib_trade_historyUpdateArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_trade_histories.
     * @param {ib_trade_historyDeleteManyArgs} args - Arguments to filter Ib_trade_histories to delete.
     * @example
     * // Delete a few Ib_trade_histories
     * const { count } = await prisma.ib_trade_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_trade_historyDeleteManyArgs>(args?: SelectSubset<T, ib_trade_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_trade_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_trade_historyUpdateManyArgs>(args: SelectSubset<T, ib_trade_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_trade_histories and returns the data updated in the database.
     * @param {ib_trade_historyUpdateManyAndReturnArgs} args - Arguments to update many Ib_trade_histories.
     * @example
     * // Update many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_trade_histories and only return the `id`
     * const ib_trade_historyWithIdOnly = await prisma.ib_trade_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_trade_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_trade_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_trade_history.
     * @param {ib_trade_historyUpsertArgs} args - Arguments to update or create a Ib_trade_history.
     * @example
     * // Update or create a Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.upsert({
     *   create: {
     *     // ... data to create a Ib_trade_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_trade_history we want to update
     *   }
     * })
     */
    upsert<T extends ib_trade_historyUpsertArgs>(args: SelectSubset<T, ib_trade_historyUpsertArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_trade_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyCountArgs} args - Arguments to filter Ib_trade_histories to count.
     * @example
     * // Count the number of Ib_trade_histories
     * const count = await prisma.ib_trade_history.count({
     *   where: {
     *     // ... the filter for the Ib_trade_histories we want to count
     *   }
     * })
    **/
    count<T extends ib_trade_historyCountArgs>(
      args?: Subset<T, ib_trade_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_trade_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_trade_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_trade_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_trade_historyAggregateArgs>(args: Subset<T, Ib_trade_historyAggregateArgs>): Prisma.PrismaPromise<GetIb_trade_historyAggregateType<T>>

    /**
     * Group by Ib_trade_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_trade_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_trade_historyGroupByArgs['orderBy'] }
        : { orderBy?: ib_trade_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_trade_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_trade_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_trade_history model
   */
  readonly fields: ib_trade_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_trade_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_trade_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_trade_history model
   */
  interface ib_trade_historyFieldRefs {
    readonly id: FieldRef<"ib_trade_history", 'String'>
    readonly order_id: FieldRef<"ib_trade_history", 'String'>
    readonly account_id: FieldRef<"ib_trade_history", 'String'>
    readonly user_id: FieldRef<"ib_trade_history", 'String'>
    readonly ib_request_id: FieldRef<"ib_trade_history", 'Int'>
    readonly symbol: FieldRef<"ib_trade_history", 'String'>
    readonly order_type: FieldRef<"ib_trade_history", 'String'>
    readonly volume_lots: FieldRef<"ib_trade_history", 'Decimal'>
    readonly open_price: FieldRef<"ib_trade_history", 'Decimal'>
    readonly close_price: FieldRef<"ib_trade_history", 'Decimal'>
    readonly profit: FieldRef<"ib_trade_history", 'Decimal'>
    readonly ib_commission: FieldRef<"ib_trade_history", 'Decimal'>
    readonly take_profit: FieldRef<"ib_trade_history", 'Decimal'>
    readonly stop_loss: FieldRef<"ib_trade_history", 'Decimal'>
    readonly created_at: FieldRef<"ib_trade_history", 'DateTime'>
    readonly updated_at: FieldRef<"ib_trade_history", 'DateTime'>
    readonly synced_at: FieldRef<"ib_trade_history", 'DateTime'>
    readonly group_id: FieldRef<"ib_trade_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ib_trade_history findUnique
   */
  export type ib_trade_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history findUniqueOrThrow
   */
  export type ib_trade_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history findFirst
   */
  export type ib_trade_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_trade_histories.
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_trade_histories.
     */
    distinct?: Ib_trade_historyScalarFieldEnum | Ib_trade_historyScalarFieldEnum[]
  }

  /**
   * ib_trade_history findFirstOrThrow
   */
  export type ib_trade_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_trade_histories.
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_trade_histories.
     */
    distinct?: Ib_trade_historyScalarFieldEnum | Ib_trade_historyScalarFieldEnum[]
  }

  /**
   * ib_trade_history findMany
   */
  export type ib_trade_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_histories to fetch.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_trade_histories.
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    distinct?: Ib_trade_historyScalarFieldEnum | Ib_trade_historyScalarFieldEnum[]
  }

  /**
   * ib_trade_history create
   */
  export type ib_trade_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_trade_history.
     */
    data: XOR<ib_trade_historyCreateInput, ib_trade_historyUncheckedCreateInput>
  }

  /**
   * ib_trade_history createMany
   */
  export type ib_trade_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_trade_histories.
     */
    data: ib_trade_historyCreateManyInput | ib_trade_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_trade_history createManyAndReturn
   */
  export type ib_trade_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data used to create many ib_trade_histories.
     */
    data: ib_trade_historyCreateManyInput | ib_trade_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_trade_history update
   */
  export type ib_trade_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_trade_history.
     */
    data: XOR<ib_trade_historyUpdateInput, ib_trade_historyUncheckedUpdateInput>
    /**
     * Choose, which ib_trade_history to update.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history updateMany
   */
  export type ib_trade_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_trade_histories.
     */
    data: XOR<ib_trade_historyUpdateManyMutationInput, ib_trade_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_trade_histories to update
     */
    where?: ib_trade_historyWhereInput
    /**
     * Limit how many ib_trade_histories to update.
     */
    limit?: number
  }

  /**
   * ib_trade_history updateManyAndReturn
   */
  export type ib_trade_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data used to update ib_trade_histories.
     */
    data: XOR<ib_trade_historyUpdateManyMutationInput, ib_trade_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_trade_histories to update
     */
    where?: ib_trade_historyWhereInput
    /**
     * Limit how many ib_trade_histories to update.
     */
    limit?: number
  }

  /**
   * ib_trade_history upsert
   */
  export type ib_trade_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_trade_history to update in case it exists.
     */
    where: ib_trade_historyWhereUniqueInput
    /**
     * In case the ib_trade_history found by the `where` argument doesn't exist, create a new ib_trade_history with this data.
     */
    create: XOR<ib_trade_historyCreateInput, ib_trade_historyUncheckedCreateInput>
    /**
     * In case the ib_trade_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_trade_historyUpdateInput, ib_trade_historyUncheckedUpdateInput>
  }

  /**
   * ib_trade_history delete
   */
  export type ib_trade_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter which ib_trade_history to delete.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history deleteMany
   */
  export type ib_trade_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_trade_histories to delete
     */
    where?: ib_trade_historyWhereInput
    /**
     * Limit how many ib_trade_histories to delete.
     */
    limit?: number
  }

  /**
   * ib_trade_history without action
   */
  export type ib_trade_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
  }


  /**
   * Model support_tickets
   */

  export type AggregateSupport_tickets = {
    _count: Support_ticketsCountAggregateOutputType | null
    _avg: Support_ticketsAvgAggregateOutputType | null
    _sum: Support_ticketsSumAggregateOutputType | null
    _min: Support_ticketsMinAggregateOutputType | null
    _max: Support_ticketsMaxAggregateOutputType | null
  }

  export type Support_ticketsAvgAggregateOutputType = {
    id: number | null
  }

  export type Support_ticketsSumAggregateOutputType = {
    id: number | null
  }

  export type Support_ticketsMinAggregateOutputType = {
    id: number | null
    ticket_no: string | null
    parent_id: string | null
    title: string | null
    description: string | null
    ticket_type: string | null
    status: string | null
    priority: string | null
    assigned_to: string | null
    account_number: string | null
    created_at: Date | null
    updated_at: Date | null
    last_reply_at: Date | null
    closed_at: Date | null
    closed_by: string | null
  }

  export type Support_ticketsMaxAggregateOutputType = {
    id: number | null
    ticket_no: string | null
    parent_id: string | null
    title: string | null
    description: string | null
    ticket_type: string | null
    status: string | null
    priority: string | null
    assigned_to: string | null
    account_number: string | null
    created_at: Date | null
    updated_at: Date | null
    last_reply_at: Date | null
    closed_at: Date | null
    closed_by: string | null
  }

  export type Support_ticketsCountAggregateOutputType = {
    id: number
    ticket_no: number
    parent_id: number
    title: number
    description: number
    ticket_type: number
    status: number
    priority: number
    assigned_to: number
    account_number: number
    tags: number
    created_at: number
    updated_at: number
    last_reply_at: number
    closed_at: number
    closed_by: number
    _all: number
  }


  export type Support_ticketsAvgAggregateInputType = {
    id?: true
  }

  export type Support_ticketsSumAggregateInputType = {
    id?: true
  }

  export type Support_ticketsMinAggregateInputType = {
    id?: true
    ticket_no?: true
    parent_id?: true
    title?: true
    description?: true
    ticket_type?: true
    status?: true
    priority?: true
    assigned_to?: true
    account_number?: true
    created_at?: true
    updated_at?: true
    last_reply_at?: true
    closed_at?: true
    closed_by?: true
  }

  export type Support_ticketsMaxAggregateInputType = {
    id?: true
    ticket_no?: true
    parent_id?: true
    title?: true
    description?: true
    ticket_type?: true
    status?: true
    priority?: true
    assigned_to?: true
    account_number?: true
    created_at?: true
    updated_at?: true
    last_reply_at?: true
    closed_at?: true
    closed_by?: true
  }

  export type Support_ticketsCountAggregateInputType = {
    id?: true
    ticket_no?: true
    parent_id?: true
    title?: true
    description?: true
    ticket_type?: true
    status?: true
    priority?: true
    assigned_to?: true
    account_number?: true
    tags?: true
    created_at?: true
    updated_at?: true
    last_reply_at?: true
    closed_at?: true
    closed_by?: true
    _all?: true
  }

  export type Support_ticketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_tickets to aggregate.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_tickets
    **/
    _count?: true | Support_ticketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_ticketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_ticketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_ticketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_ticketsMaxAggregateInputType
  }

  export type GetSupport_ticketsAggregateType<T extends Support_ticketsAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_tickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_tickets[P]>
      : GetScalarType<T[P], AggregateSupport_tickets[P]>
  }




  export type support_ticketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_ticketsWhereInput
    orderBy?: support_ticketsOrderByWithAggregationInput | support_ticketsOrderByWithAggregationInput[]
    by: Support_ticketsScalarFieldEnum[] | Support_ticketsScalarFieldEnum
    having?: support_ticketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_ticketsCountAggregateInputType | true
    _avg?: Support_ticketsAvgAggregateInputType
    _sum?: Support_ticketsSumAggregateInputType
    _min?: Support_ticketsMinAggregateInputType
    _max?: Support_ticketsMaxAggregateInputType
  }

  export type Support_ticketsGroupByOutputType = {
    id: number
    ticket_no: string
    parent_id: string
    title: string
    description: string | null
    ticket_type: string | null
    status: string
    priority: string
    assigned_to: string | null
    account_number: string | null
    tags: string[]
    created_at: Date
    updated_at: Date
    last_reply_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    _count: Support_ticketsCountAggregateOutputType | null
    _avg: Support_ticketsAvgAggregateOutputType | null
    _sum: Support_ticketsSumAggregateOutputType | null
    _min: Support_ticketsMinAggregateOutputType | null
    _max: Support_ticketsMaxAggregateOutputType | null
  }

  type GetSupport_ticketsGroupByPayload<T extends support_ticketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_ticketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_ticketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_ticketsGroupByOutputType[P]>
            : GetScalarType<T[P], Support_ticketsGroupByOutputType[P]>
        }
      >
    >


  export type support_ticketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }, ExtArgs["result"]["support_tickets"]>

  export type support_ticketsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }, ExtArgs["result"]["support_tickets"]>

  export type support_ticketsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }, ExtArgs["result"]["support_tickets"]>

  export type support_ticketsSelectScalar = {
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }

  export type support_ticketsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_no" | "parent_id" | "title" | "description" | "ticket_type" | "status" | "priority" | "assigned_to" | "account_number" | "tags" | "created_at" | "updated_at" | "last_reply_at" | "closed_at" | "closed_by", ExtArgs["result"]["support_tickets"]>

  export type $support_ticketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_tickets"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_no: string
      parent_id: string
      title: string
      description: string | null
      ticket_type: string | null
      status: string
      priority: string
      assigned_to: string | null
      account_number: string | null
      tags: string[]
      created_at: Date
      updated_at: Date
      last_reply_at: Date | null
      closed_at: Date | null
      closed_by: string | null
    }, ExtArgs["result"]["support_tickets"]>
    composites: {}
  }

  type support_ticketsGetPayload<S extends boolean | null | undefined | support_ticketsDefaultArgs> = $Result.GetResult<Prisma.$support_ticketsPayload, S>

  type support_ticketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_ticketsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_ticketsCountAggregateInputType | true
    }

  export interface support_ticketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_tickets'], meta: { name: 'support_tickets' } }
    /**
     * Find zero or one Support_tickets that matches the filter.
     * @param {support_ticketsFindUniqueArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_ticketsFindUniqueArgs>(args: SelectSubset<T, support_ticketsFindUniqueArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_tickets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_ticketsFindUniqueOrThrowArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_ticketsFindUniqueOrThrowArgs>(args: SelectSubset<T, support_ticketsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsFindFirstArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_ticketsFindFirstArgs>(args?: SelectSubset<T, support_ticketsFindFirstArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_tickets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsFindFirstOrThrowArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_ticketsFindFirstOrThrowArgs>(args?: SelectSubset<T, support_ticketsFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_tickets
     * const support_tickets = await prisma.support_tickets.findMany()
     * 
     * // Get first 10 Support_tickets
     * const support_tickets = await prisma.support_tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_ticketsWithIdOnly = await prisma.support_tickets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_ticketsFindManyArgs>(args?: SelectSubset<T, support_ticketsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_tickets.
     * @param {support_ticketsCreateArgs} args - Arguments to create a Support_tickets.
     * @example
     * // Create one Support_tickets
     * const Support_tickets = await prisma.support_tickets.create({
     *   data: {
     *     // ... data to create a Support_tickets
     *   }
     * })
     * 
     */
    create<T extends support_ticketsCreateArgs>(args: SelectSubset<T, support_ticketsCreateArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_tickets.
     * @param {support_ticketsCreateManyArgs} args - Arguments to create many Support_tickets.
     * @example
     * // Create many Support_tickets
     * const support_tickets = await prisma.support_tickets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_ticketsCreateManyArgs>(args?: SelectSubset<T, support_ticketsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_tickets and returns the data saved in the database.
     * @param {support_ticketsCreateManyAndReturnArgs} args - Arguments to create many Support_tickets.
     * @example
     * // Create many Support_tickets
     * const support_tickets = await prisma.support_tickets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_tickets and only return the `id`
     * const support_ticketsWithIdOnly = await prisma.support_tickets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_ticketsCreateManyAndReturnArgs>(args?: SelectSubset<T, support_ticketsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_tickets.
     * @param {support_ticketsDeleteArgs} args - Arguments to delete one Support_tickets.
     * @example
     * // Delete one Support_tickets
     * const Support_tickets = await prisma.support_tickets.delete({
     *   where: {
     *     // ... filter to delete one Support_tickets
     *   }
     * })
     * 
     */
    delete<T extends support_ticketsDeleteArgs>(args: SelectSubset<T, support_ticketsDeleteArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_tickets.
     * @param {support_ticketsUpdateArgs} args - Arguments to update one Support_tickets.
     * @example
     * // Update one Support_tickets
     * const support_tickets = await prisma.support_tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_ticketsUpdateArgs>(args: SelectSubset<T, support_ticketsUpdateArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_tickets.
     * @param {support_ticketsDeleteManyArgs} args - Arguments to filter Support_tickets to delete.
     * @example
     * // Delete a few Support_tickets
     * const { count } = await prisma.support_tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_ticketsDeleteManyArgs>(args?: SelectSubset<T, support_ticketsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_tickets
     * const support_tickets = await prisma.support_tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_ticketsUpdateManyArgs>(args: SelectSubset<T, support_ticketsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_tickets and returns the data updated in the database.
     * @param {support_ticketsUpdateManyAndReturnArgs} args - Arguments to update many Support_tickets.
     * @example
     * // Update many Support_tickets
     * const support_tickets = await prisma.support_tickets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_tickets and only return the `id`
     * const support_ticketsWithIdOnly = await prisma.support_tickets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_ticketsUpdateManyAndReturnArgs>(args: SelectSubset<T, support_ticketsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_tickets.
     * @param {support_ticketsUpsertArgs} args - Arguments to update or create a Support_tickets.
     * @example
     * // Update or create a Support_tickets
     * const support_tickets = await prisma.support_tickets.upsert({
     *   create: {
     *     // ... data to create a Support_tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_tickets we want to update
     *   }
     * })
     */
    upsert<T extends support_ticketsUpsertArgs>(args: SelectSubset<T, support_ticketsUpsertArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsCountArgs} args - Arguments to filter Support_tickets to count.
     * @example
     * // Count the number of Support_tickets
     * const count = await prisma.support_tickets.count({
     *   where: {
     *     // ... the filter for the Support_tickets we want to count
     *   }
     * })
    **/
    count<T extends support_ticketsCountArgs>(
      args?: Subset<T, support_ticketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_ticketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_ticketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_ticketsAggregateArgs>(args: Subset<T, Support_ticketsAggregateArgs>): Prisma.PrismaPromise<GetSupport_ticketsAggregateType<T>>

    /**
     * Group by Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_ticketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_ticketsGroupByArgs['orderBy'] }
        : { orderBy?: support_ticketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_ticketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_ticketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_tickets model
   */
  readonly fields: support_ticketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_ticketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_tickets model
   */
  interface support_ticketsFieldRefs {
    readonly id: FieldRef<"support_tickets", 'Int'>
    readonly ticket_no: FieldRef<"support_tickets", 'String'>
    readonly parent_id: FieldRef<"support_tickets", 'String'>
    readonly title: FieldRef<"support_tickets", 'String'>
    readonly description: FieldRef<"support_tickets", 'String'>
    readonly ticket_type: FieldRef<"support_tickets", 'String'>
    readonly status: FieldRef<"support_tickets", 'String'>
    readonly priority: FieldRef<"support_tickets", 'String'>
    readonly assigned_to: FieldRef<"support_tickets", 'String'>
    readonly account_number: FieldRef<"support_tickets", 'String'>
    readonly tags: FieldRef<"support_tickets", 'String[]'>
    readonly created_at: FieldRef<"support_tickets", 'DateTime'>
    readonly updated_at: FieldRef<"support_tickets", 'DateTime'>
    readonly last_reply_at: FieldRef<"support_tickets", 'DateTime'>
    readonly closed_at: FieldRef<"support_tickets", 'DateTime'>
    readonly closed_by: FieldRef<"support_tickets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * support_tickets findUnique
   */
  export type support_ticketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets findUniqueOrThrow
   */
  export type support_ticketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets findFirst
   */
  export type support_ticketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_tickets.
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_tickets.
     */
    distinct?: Support_ticketsScalarFieldEnum | Support_ticketsScalarFieldEnum[]
  }

  /**
   * support_tickets findFirstOrThrow
   */
  export type support_ticketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_tickets.
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_tickets.
     */
    distinct?: Support_ticketsScalarFieldEnum | Support_ticketsScalarFieldEnum[]
  }

  /**
   * support_tickets findMany
   */
  export type support_ticketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_tickets.
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    distinct?: Support_ticketsScalarFieldEnum | Support_ticketsScalarFieldEnum[]
  }

  /**
   * support_tickets create
   */
  export type support_ticketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data needed to create a support_tickets.
     */
    data: XOR<support_ticketsCreateInput, support_ticketsUncheckedCreateInput>
  }

  /**
   * support_tickets createMany
   */
  export type support_ticketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_tickets.
     */
    data: support_ticketsCreateManyInput | support_ticketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_tickets createManyAndReturn
   */
  export type support_ticketsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data used to create many support_tickets.
     */
    data: support_ticketsCreateManyInput | support_ticketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_tickets update
   */
  export type support_ticketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data needed to update a support_tickets.
     */
    data: XOR<support_ticketsUpdateInput, support_ticketsUncheckedUpdateInput>
    /**
     * Choose, which support_tickets to update.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets updateMany
   */
  export type support_ticketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_tickets.
     */
    data: XOR<support_ticketsUpdateManyMutationInput, support_ticketsUncheckedUpdateManyInput>
    /**
     * Filter which support_tickets to update
     */
    where?: support_ticketsWhereInput
    /**
     * Limit how many support_tickets to update.
     */
    limit?: number
  }

  /**
   * support_tickets updateManyAndReturn
   */
  export type support_ticketsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data used to update support_tickets.
     */
    data: XOR<support_ticketsUpdateManyMutationInput, support_ticketsUncheckedUpdateManyInput>
    /**
     * Filter which support_tickets to update
     */
    where?: support_ticketsWhereInput
    /**
     * Limit how many support_tickets to update.
     */
    limit?: number
  }

  /**
   * support_tickets upsert
   */
  export type support_ticketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The filter to search for the support_tickets to update in case it exists.
     */
    where: support_ticketsWhereUniqueInput
    /**
     * In case the support_tickets found by the `where` argument doesn't exist, create a new support_tickets with this data.
     */
    create: XOR<support_ticketsCreateInput, support_ticketsUncheckedCreateInput>
    /**
     * In case the support_tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_ticketsUpdateInput, support_ticketsUncheckedUpdateInput>
  }

  /**
   * support_tickets delete
   */
  export type support_ticketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter which support_tickets to delete.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets deleteMany
   */
  export type support_ticketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_tickets to delete
     */
    where?: support_ticketsWhereInput
    /**
     * Limit how many support_tickets to delete.
     */
    limit?: number
  }

  /**
   * support_tickets without action
   */
  export type support_ticketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
  }


  /**
   * Model support_ticket_replies
   */

  export type AggregateSupport_ticket_replies = {
    _count: Support_ticket_repliesCountAggregateOutputType | null
    _avg: Support_ticket_repliesAvgAggregateOutputType | null
    _sum: Support_ticket_repliesSumAggregateOutputType | null
    _min: Support_ticket_repliesMinAggregateOutputType | null
    _max: Support_ticket_repliesMaxAggregateOutputType | null
  }

  export type Support_ticket_repliesAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
  }

  export type Support_ticket_repliesSumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
  }

  export type Support_ticket_repliesMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_read: boolean | null
  }

  export type Support_ticket_repliesMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_read: boolean | null
  }

  export type Support_ticket_repliesCountAggregateOutputType = {
    id: number
    ticket_id: number
    reply_id: number
    sender_id: number
    sender_name: number
    sender_type: number
    content: number
    is_internal: number
    attachments: number
    created_at: number
    updated_at: number
    is_read: number
    _all: number
  }


  export type Support_ticket_repliesAvgAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
  }

  export type Support_ticket_repliesSumAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
  }

  export type Support_ticket_repliesMinAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
    updated_at?: true
    is_read?: true
  }

  export type Support_ticket_repliesMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
    updated_at?: true
    is_read?: true
  }

  export type Support_ticket_repliesCountAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    attachments?: true
    created_at?: true
    updated_at?: true
    is_read?: true
    _all?: true
  }

  export type Support_ticket_repliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_ticket_replies to aggregate.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_ticket_replies
    **/
    _count?: true | Support_ticket_repliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_ticket_repliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_ticket_repliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_ticket_repliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_ticket_repliesMaxAggregateInputType
  }

  export type GetSupport_ticket_repliesAggregateType<T extends Support_ticket_repliesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_ticket_replies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_ticket_replies[P]>
      : GetScalarType<T[P], AggregateSupport_ticket_replies[P]>
  }




  export type support_ticket_repliesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_ticket_repliesWhereInput
    orderBy?: support_ticket_repliesOrderByWithAggregationInput | support_ticket_repliesOrderByWithAggregationInput[]
    by: Support_ticket_repliesScalarFieldEnum[] | Support_ticket_repliesScalarFieldEnum
    having?: support_ticket_repliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_ticket_repliesCountAggregateInputType | true
    _avg?: Support_ticket_repliesAvgAggregateInputType
    _sum?: Support_ticket_repliesSumAggregateInputType
    _min?: Support_ticket_repliesMinAggregateInputType
    _max?: Support_ticket_repliesMaxAggregateInputType
  }

  export type Support_ticket_repliesGroupByOutputType = {
    id: number
    ticket_id: number
    reply_id: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal: boolean
    attachments: string[]
    created_at: Date
    updated_at: Date
    is_read: boolean
    _count: Support_ticket_repliesCountAggregateOutputType | null
    _avg: Support_ticket_repliesAvgAggregateOutputType | null
    _sum: Support_ticket_repliesSumAggregateOutputType | null
    _min: Support_ticket_repliesMinAggregateOutputType | null
    _max: Support_ticket_repliesMaxAggregateOutputType | null
  }

  type GetSupport_ticket_repliesGroupByPayload<T extends support_ticket_repliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_ticket_repliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_ticket_repliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_ticket_repliesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_ticket_repliesGroupByOutputType[P]>
        }
      >
    >


  export type support_ticket_repliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }, ExtArgs["result"]["support_ticket_replies"]>

  export type support_ticket_repliesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }, ExtArgs["result"]["support_ticket_replies"]>

  export type support_ticket_repliesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }, ExtArgs["result"]["support_ticket_replies"]>

  export type support_ticket_repliesSelectScalar = {
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }

  export type support_ticket_repliesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "reply_id" | "sender_id" | "sender_name" | "sender_type" | "content" | "is_internal" | "attachments" | "created_at" | "updated_at" | "is_read", ExtArgs["result"]["support_ticket_replies"]>

  export type $support_ticket_repliesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_ticket_replies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      reply_id: number | null
      sender_id: string
      sender_name: string
      sender_type: string
      content: string
      is_internal: boolean
      attachments: string[]
      created_at: Date
      updated_at: Date
      is_read: boolean
    }, ExtArgs["result"]["support_ticket_replies"]>
    composites: {}
  }

  type support_ticket_repliesGetPayload<S extends boolean | null | undefined | support_ticket_repliesDefaultArgs> = $Result.GetResult<Prisma.$support_ticket_repliesPayload, S>

  type support_ticket_repliesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_ticket_repliesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_ticket_repliesCountAggregateInputType | true
    }

  export interface support_ticket_repliesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_ticket_replies'], meta: { name: 'support_ticket_replies' } }
    /**
     * Find zero or one Support_ticket_replies that matches the filter.
     * @param {support_ticket_repliesFindUniqueArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_ticket_repliesFindUniqueArgs>(args: SelectSubset<T, support_ticket_repliesFindUniqueArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_ticket_replies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_ticket_repliesFindUniqueOrThrowArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_ticket_repliesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_ticket_repliesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_ticket_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesFindFirstArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_ticket_repliesFindFirstArgs>(args?: SelectSubset<T, support_ticket_repliesFindFirstArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_ticket_replies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesFindFirstOrThrowArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_ticket_repliesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_ticket_repliesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_ticket_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findMany()
     * 
     * // Get first 10 Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_ticket_repliesWithIdOnly = await prisma.support_ticket_replies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_ticket_repliesFindManyArgs>(args?: SelectSubset<T, support_ticket_repliesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_ticket_replies.
     * @param {support_ticket_repliesCreateArgs} args - Arguments to create a Support_ticket_replies.
     * @example
     * // Create one Support_ticket_replies
     * const Support_ticket_replies = await prisma.support_ticket_replies.create({
     *   data: {
     *     // ... data to create a Support_ticket_replies
     *   }
     * })
     * 
     */
    create<T extends support_ticket_repliesCreateArgs>(args: SelectSubset<T, support_ticket_repliesCreateArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_ticket_replies.
     * @param {support_ticket_repliesCreateManyArgs} args - Arguments to create many Support_ticket_replies.
     * @example
     * // Create many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_ticket_repliesCreateManyArgs>(args?: SelectSubset<T, support_ticket_repliesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_ticket_replies and returns the data saved in the database.
     * @param {support_ticket_repliesCreateManyAndReturnArgs} args - Arguments to create many Support_ticket_replies.
     * @example
     * // Create many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_ticket_replies and only return the `id`
     * const support_ticket_repliesWithIdOnly = await prisma.support_ticket_replies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_ticket_repliesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_ticket_repliesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_ticket_replies.
     * @param {support_ticket_repliesDeleteArgs} args - Arguments to delete one Support_ticket_replies.
     * @example
     * // Delete one Support_ticket_replies
     * const Support_ticket_replies = await prisma.support_ticket_replies.delete({
     *   where: {
     *     // ... filter to delete one Support_ticket_replies
     *   }
     * })
     * 
     */
    delete<T extends support_ticket_repliesDeleteArgs>(args: SelectSubset<T, support_ticket_repliesDeleteArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_ticket_replies.
     * @param {support_ticket_repliesUpdateArgs} args - Arguments to update one Support_ticket_replies.
     * @example
     * // Update one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_ticket_repliesUpdateArgs>(args: SelectSubset<T, support_ticket_repliesUpdateArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_ticket_replies.
     * @param {support_ticket_repliesDeleteManyArgs} args - Arguments to filter Support_ticket_replies to delete.
     * @example
     * // Delete a few Support_ticket_replies
     * const { count } = await prisma.support_ticket_replies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_ticket_repliesDeleteManyArgs>(args?: SelectSubset<T, support_ticket_repliesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_ticket_repliesUpdateManyArgs>(args: SelectSubset<T, support_ticket_repliesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_ticket_replies and returns the data updated in the database.
     * @param {support_ticket_repliesUpdateManyAndReturnArgs} args - Arguments to update many Support_ticket_replies.
     * @example
     * // Update many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_ticket_replies and only return the `id`
     * const support_ticket_repliesWithIdOnly = await prisma.support_ticket_replies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_ticket_repliesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_ticket_repliesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_ticket_replies.
     * @param {support_ticket_repliesUpsertArgs} args - Arguments to update or create a Support_ticket_replies.
     * @example
     * // Update or create a Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.upsert({
     *   create: {
     *     // ... data to create a Support_ticket_replies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_ticket_replies we want to update
     *   }
     * })
     */
    upsert<T extends support_ticket_repliesUpsertArgs>(args: SelectSubset<T, support_ticket_repliesUpsertArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesCountArgs} args - Arguments to filter Support_ticket_replies to count.
     * @example
     * // Count the number of Support_ticket_replies
     * const count = await prisma.support_ticket_replies.count({
     *   where: {
     *     // ... the filter for the Support_ticket_replies we want to count
     *   }
     * })
    **/
    count<T extends support_ticket_repliesCountArgs>(
      args?: Subset<T, support_ticket_repliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_ticket_repliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_ticket_repliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_ticket_repliesAggregateArgs>(args: Subset<T, Support_ticket_repliesAggregateArgs>): Prisma.PrismaPromise<GetSupport_ticket_repliesAggregateType<T>>

    /**
     * Group by Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_ticket_repliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_ticket_repliesGroupByArgs['orderBy'] }
        : { orderBy?: support_ticket_repliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_ticket_repliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_ticket_repliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_ticket_replies model
   */
  readonly fields: support_ticket_repliesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_ticket_replies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_ticket_repliesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_ticket_replies model
   */
  interface support_ticket_repliesFieldRefs {
    readonly id: FieldRef<"support_ticket_replies", 'Int'>
    readonly ticket_id: FieldRef<"support_ticket_replies", 'Int'>
    readonly reply_id: FieldRef<"support_ticket_replies", 'Int'>
    readonly sender_id: FieldRef<"support_ticket_replies", 'String'>
    readonly sender_name: FieldRef<"support_ticket_replies", 'String'>
    readonly sender_type: FieldRef<"support_ticket_replies", 'String'>
    readonly content: FieldRef<"support_ticket_replies", 'String'>
    readonly is_internal: FieldRef<"support_ticket_replies", 'Boolean'>
    readonly attachments: FieldRef<"support_ticket_replies", 'String[]'>
    readonly created_at: FieldRef<"support_ticket_replies", 'DateTime'>
    readonly updated_at: FieldRef<"support_ticket_replies", 'DateTime'>
    readonly is_read: FieldRef<"support_ticket_replies", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * support_ticket_replies findUnique
   */
  export type support_ticket_repliesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies findUniqueOrThrow
   */
  export type support_ticket_repliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies findFirst
   */
  export type support_ticket_repliesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_ticket_replies.
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_ticket_replies.
     */
    distinct?: Support_ticket_repliesScalarFieldEnum | Support_ticket_repliesScalarFieldEnum[]
  }

  /**
   * support_ticket_replies findFirstOrThrow
   */
  export type support_ticket_repliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_ticket_replies.
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_ticket_replies.
     */
    distinct?: Support_ticket_repliesScalarFieldEnum | Support_ticket_repliesScalarFieldEnum[]
  }

  /**
   * support_ticket_replies findMany
   */
  export type support_ticket_repliesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_ticket_replies.
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    distinct?: Support_ticket_repliesScalarFieldEnum | Support_ticket_repliesScalarFieldEnum[]
  }

  /**
   * support_ticket_replies create
   */
  export type support_ticket_repliesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_ticket_replies.
     */
    data: XOR<support_ticket_repliesCreateInput, support_ticket_repliesUncheckedCreateInput>
  }

  /**
   * support_ticket_replies createMany
   */
  export type support_ticket_repliesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_ticket_replies.
     */
    data: support_ticket_repliesCreateManyInput | support_ticket_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_ticket_replies createManyAndReturn
   */
  export type support_ticket_repliesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data used to create many support_ticket_replies.
     */
    data: support_ticket_repliesCreateManyInput | support_ticket_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_ticket_replies update
   */
  export type support_ticket_repliesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_ticket_replies.
     */
    data: XOR<support_ticket_repliesUpdateInput, support_ticket_repliesUncheckedUpdateInput>
    /**
     * Choose, which support_ticket_replies to update.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies updateMany
   */
  export type support_ticket_repliesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_ticket_replies.
     */
    data: XOR<support_ticket_repliesUpdateManyMutationInput, support_ticket_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_ticket_replies to update
     */
    where?: support_ticket_repliesWhereInput
    /**
     * Limit how many support_ticket_replies to update.
     */
    limit?: number
  }

  /**
   * support_ticket_replies updateManyAndReturn
   */
  export type support_ticket_repliesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data used to update support_ticket_replies.
     */
    data: XOR<support_ticket_repliesUpdateManyMutationInput, support_ticket_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_ticket_replies to update
     */
    where?: support_ticket_repliesWhereInput
    /**
     * Limit how many support_ticket_replies to update.
     */
    limit?: number
  }

  /**
   * support_ticket_replies upsert
   */
  export type support_ticket_repliesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_ticket_replies to update in case it exists.
     */
    where: support_ticket_repliesWhereUniqueInput
    /**
     * In case the support_ticket_replies found by the `where` argument doesn't exist, create a new support_ticket_replies with this data.
     */
    create: XOR<support_ticket_repliesCreateInput, support_ticket_repliesUncheckedCreateInput>
    /**
     * In case the support_ticket_replies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_ticket_repliesUpdateInput, support_ticket_repliesUncheckedUpdateInput>
  }

  /**
   * support_ticket_replies delete
   */
  export type support_ticket_repliesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter which support_ticket_replies to delete.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies deleteMany
   */
  export type support_ticket_repliesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_ticket_replies to delete
     */
    where?: support_ticket_repliesWhereInput
    /**
     * Limit how many support_ticket_replies to delete.
     */
    limit?: number
  }

  /**
   * support_ticket_replies without action
   */
  export type support_ticket_repliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
  }


  /**
   * Model support_articles
   */

  export type AggregateSupport_articles = {
    _count: Support_articlesCountAggregateOutputType | null
    _avg: Support_articlesAvgAggregateOutputType | null
    _sum: Support_articlesSumAggregateOutputType | null
    _min: Support_articlesMinAggregateOutputType | null
    _max: Support_articlesMaxAggregateOutputType | null
  }

  export type Support_articlesAvgAggregateOutputType = {
    id: number | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
  }

  export type Support_articlesSumAggregateOutputType = {
    id: number | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
  }

  export type Support_articlesMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    category: string | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    is_published: boolean | null
    author_id: string | null
    created_at: Date | null
    updated_at: Date | null
    published_at: Date | null
  }

  export type Support_articlesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    category: string | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    is_published: boolean | null
    author_id: string | null
    created_at: Date | null
    updated_at: Date | null
    published_at: Date | null
  }

  export type Support_articlesCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    excerpt: number
    category: number
    tags: number
    views: number
    helpful_count: number
    not_helpful_count: number
    is_published: number
    author_id: number
    created_at: number
    updated_at: number
    published_at: number
    _all: number
  }


  export type Support_articlesAvgAggregateInputType = {
    id?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
  }

  export type Support_articlesSumAggregateInputType = {
    id?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
  }

  export type Support_articlesMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    category?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
    is_published?: true
    author_id?: true
    created_at?: true
    updated_at?: true
    published_at?: true
  }

  export type Support_articlesMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    category?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
    is_published?: true
    author_id?: true
    created_at?: true
    updated_at?: true
    published_at?: true
  }

  export type Support_articlesCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    category?: true
    tags?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
    is_published?: true
    author_id?: true
    created_at?: true
    updated_at?: true
    published_at?: true
    _all?: true
  }

  export type Support_articlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_articles to aggregate.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_articles
    **/
    _count?: true | Support_articlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_articlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_articlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_articlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_articlesMaxAggregateInputType
  }

  export type GetSupport_articlesAggregateType<T extends Support_articlesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_articles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_articles[P]>
      : GetScalarType<T[P], AggregateSupport_articles[P]>
  }




  export type support_articlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_articlesWhereInput
    orderBy?: support_articlesOrderByWithAggregationInput | support_articlesOrderByWithAggregationInput[]
    by: Support_articlesScalarFieldEnum[] | Support_articlesScalarFieldEnum
    having?: support_articlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_articlesCountAggregateInputType | true
    _avg?: Support_articlesAvgAggregateInputType
    _sum?: Support_articlesSumAggregateInputType
    _min?: Support_articlesMinAggregateInputType
    _max?: Support_articlesMaxAggregateInputType
  }

  export type Support_articlesGroupByOutputType = {
    id: number
    title: string
    slug: string
    content: string
    excerpt: string | null
    category: string
    tags: string[]
    views: number
    helpful_count: number
    not_helpful_count: number
    is_published: boolean
    author_id: string
    created_at: Date
    updated_at: Date
    published_at: Date | null
    _count: Support_articlesCountAggregateOutputType | null
    _avg: Support_articlesAvgAggregateOutputType | null
    _sum: Support_articlesSumAggregateOutputType | null
    _min: Support_articlesMinAggregateOutputType | null
    _max: Support_articlesMaxAggregateOutputType | null
  }

  type GetSupport_articlesGroupByPayload<T extends support_articlesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_articlesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_articlesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_articlesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_articlesGroupByOutputType[P]>
        }
      >
    >


  export type support_articlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }, ExtArgs["result"]["support_articles"]>

  export type support_articlesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }, ExtArgs["result"]["support_articles"]>

  export type support_articlesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }, ExtArgs["result"]["support_articles"]>

  export type support_articlesSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }

  export type support_articlesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "excerpt" | "category" | "tags" | "views" | "helpful_count" | "not_helpful_count" | "is_published" | "author_id" | "created_at" | "updated_at" | "published_at", ExtArgs["result"]["support_articles"]>

  export type $support_articlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_articles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      content: string
      excerpt: string | null
      category: string
      tags: string[]
      views: number
      helpful_count: number
      not_helpful_count: number
      is_published: boolean
      author_id: string
      created_at: Date
      updated_at: Date
      published_at: Date | null
    }, ExtArgs["result"]["support_articles"]>
    composites: {}
  }

  type support_articlesGetPayload<S extends boolean | null | undefined | support_articlesDefaultArgs> = $Result.GetResult<Prisma.$support_articlesPayload, S>

  type support_articlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_articlesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_articlesCountAggregateInputType | true
    }

  export interface support_articlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_articles'], meta: { name: 'support_articles' } }
    /**
     * Find zero or one Support_articles that matches the filter.
     * @param {support_articlesFindUniqueArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_articlesFindUniqueArgs>(args: SelectSubset<T, support_articlesFindUniqueArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_articles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_articlesFindUniqueOrThrowArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_articlesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_articlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesFindFirstArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_articlesFindFirstArgs>(args?: SelectSubset<T, support_articlesFindFirstArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_articles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesFindFirstOrThrowArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_articlesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_articlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_articles
     * const support_articles = await prisma.support_articles.findMany()
     * 
     * // Get first 10 Support_articles
     * const support_articles = await prisma.support_articles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_articlesWithIdOnly = await prisma.support_articles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_articlesFindManyArgs>(args?: SelectSubset<T, support_articlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_articles.
     * @param {support_articlesCreateArgs} args - Arguments to create a Support_articles.
     * @example
     * // Create one Support_articles
     * const Support_articles = await prisma.support_articles.create({
     *   data: {
     *     // ... data to create a Support_articles
     *   }
     * })
     * 
     */
    create<T extends support_articlesCreateArgs>(args: SelectSubset<T, support_articlesCreateArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_articles.
     * @param {support_articlesCreateManyArgs} args - Arguments to create many Support_articles.
     * @example
     * // Create many Support_articles
     * const support_articles = await prisma.support_articles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_articlesCreateManyArgs>(args?: SelectSubset<T, support_articlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_articles and returns the data saved in the database.
     * @param {support_articlesCreateManyAndReturnArgs} args - Arguments to create many Support_articles.
     * @example
     * // Create many Support_articles
     * const support_articles = await prisma.support_articles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_articles and only return the `id`
     * const support_articlesWithIdOnly = await prisma.support_articles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_articlesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_articlesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_articles.
     * @param {support_articlesDeleteArgs} args - Arguments to delete one Support_articles.
     * @example
     * // Delete one Support_articles
     * const Support_articles = await prisma.support_articles.delete({
     *   where: {
     *     // ... filter to delete one Support_articles
     *   }
     * })
     * 
     */
    delete<T extends support_articlesDeleteArgs>(args: SelectSubset<T, support_articlesDeleteArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_articles.
     * @param {support_articlesUpdateArgs} args - Arguments to update one Support_articles.
     * @example
     * // Update one Support_articles
     * const support_articles = await prisma.support_articles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_articlesUpdateArgs>(args: SelectSubset<T, support_articlesUpdateArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_articles.
     * @param {support_articlesDeleteManyArgs} args - Arguments to filter Support_articles to delete.
     * @example
     * // Delete a few Support_articles
     * const { count } = await prisma.support_articles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_articlesDeleteManyArgs>(args?: SelectSubset<T, support_articlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_articles
     * const support_articles = await prisma.support_articles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_articlesUpdateManyArgs>(args: SelectSubset<T, support_articlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_articles and returns the data updated in the database.
     * @param {support_articlesUpdateManyAndReturnArgs} args - Arguments to update many Support_articles.
     * @example
     * // Update many Support_articles
     * const support_articles = await prisma.support_articles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_articles and only return the `id`
     * const support_articlesWithIdOnly = await prisma.support_articles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_articlesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_articlesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_articles.
     * @param {support_articlesUpsertArgs} args - Arguments to update or create a Support_articles.
     * @example
     * // Update or create a Support_articles
     * const support_articles = await prisma.support_articles.upsert({
     *   create: {
     *     // ... data to create a Support_articles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_articles we want to update
     *   }
     * })
     */
    upsert<T extends support_articlesUpsertArgs>(args: SelectSubset<T, support_articlesUpsertArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesCountArgs} args - Arguments to filter Support_articles to count.
     * @example
     * // Count the number of Support_articles
     * const count = await prisma.support_articles.count({
     *   where: {
     *     // ... the filter for the Support_articles we want to count
     *   }
     * })
    **/
    count<T extends support_articlesCountArgs>(
      args?: Subset<T, support_articlesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_articlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_articlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_articlesAggregateArgs>(args: Subset<T, Support_articlesAggregateArgs>): Prisma.PrismaPromise<GetSupport_articlesAggregateType<T>>

    /**
     * Group by Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_articlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_articlesGroupByArgs['orderBy'] }
        : { orderBy?: support_articlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_articlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_articlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_articles model
   */
  readonly fields: support_articlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_articles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_articlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_articles model
   */
  interface support_articlesFieldRefs {
    readonly id: FieldRef<"support_articles", 'Int'>
    readonly title: FieldRef<"support_articles", 'String'>
    readonly slug: FieldRef<"support_articles", 'String'>
    readonly content: FieldRef<"support_articles", 'String'>
    readonly excerpt: FieldRef<"support_articles", 'String'>
    readonly category: FieldRef<"support_articles", 'String'>
    readonly tags: FieldRef<"support_articles", 'String[]'>
    readonly views: FieldRef<"support_articles", 'Int'>
    readonly helpful_count: FieldRef<"support_articles", 'Int'>
    readonly not_helpful_count: FieldRef<"support_articles", 'Int'>
    readonly is_published: FieldRef<"support_articles", 'Boolean'>
    readonly author_id: FieldRef<"support_articles", 'String'>
    readonly created_at: FieldRef<"support_articles", 'DateTime'>
    readonly updated_at: FieldRef<"support_articles", 'DateTime'>
    readonly published_at: FieldRef<"support_articles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_articles findUnique
   */
  export type support_articlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles findUniqueOrThrow
   */
  export type support_articlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles findFirst
   */
  export type support_articlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_articles.
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_articles.
     */
    distinct?: Support_articlesScalarFieldEnum | Support_articlesScalarFieldEnum[]
  }

  /**
   * support_articles findFirstOrThrow
   */
  export type support_articlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_articles.
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_articles.
     */
    distinct?: Support_articlesScalarFieldEnum | Support_articlesScalarFieldEnum[]
  }

  /**
   * support_articles findMany
   */
  export type support_articlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_articles.
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    distinct?: Support_articlesScalarFieldEnum | Support_articlesScalarFieldEnum[]
  }

  /**
   * support_articles create
   */
  export type support_articlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_articles.
     */
    data: XOR<support_articlesCreateInput, support_articlesUncheckedCreateInput>
  }

  /**
   * support_articles createMany
   */
  export type support_articlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_articles.
     */
    data: support_articlesCreateManyInput | support_articlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_articles createManyAndReturn
   */
  export type support_articlesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data used to create many support_articles.
     */
    data: support_articlesCreateManyInput | support_articlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_articles update
   */
  export type support_articlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_articles.
     */
    data: XOR<support_articlesUpdateInput, support_articlesUncheckedUpdateInput>
    /**
     * Choose, which support_articles to update.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles updateMany
   */
  export type support_articlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_articles.
     */
    data: XOR<support_articlesUpdateManyMutationInput, support_articlesUncheckedUpdateManyInput>
    /**
     * Filter which support_articles to update
     */
    where?: support_articlesWhereInput
    /**
     * Limit how many support_articles to update.
     */
    limit?: number
  }

  /**
   * support_articles updateManyAndReturn
   */
  export type support_articlesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data used to update support_articles.
     */
    data: XOR<support_articlesUpdateManyMutationInput, support_articlesUncheckedUpdateManyInput>
    /**
     * Filter which support_articles to update
     */
    where?: support_articlesWhereInput
    /**
     * Limit how many support_articles to update.
     */
    limit?: number
  }

  /**
   * support_articles upsert
   */
  export type support_articlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_articles to update in case it exists.
     */
    where: support_articlesWhereUniqueInput
    /**
     * In case the support_articles found by the `where` argument doesn't exist, create a new support_articles with this data.
     */
    create: XOR<support_articlesCreateInput, support_articlesUncheckedCreateInput>
    /**
     * In case the support_articles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_articlesUpdateInput, support_articlesUncheckedUpdateInput>
  }

  /**
   * support_articles delete
   */
  export type support_articlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter which support_articles to delete.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles deleteMany
   */
  export type support_articlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_articles to delete
     */
    where?: support_articlesWhereInput
    /**
     * Limit how many support_articles to delete.
     */
    limit?: number
  }

  /**
   * support_articles without action
   */
  export type support_articlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
  }


  /**
   * Model support_faq
   */

  export type AggregateSupport_faq = {
    _count: Support_faqCountAggregateOutputType | null
    _avg: Support_faqAvgAggregateOutputType | null
    _sum: Support_faqSumAggregateOutputType | null
    _min: Support_faqMinAggregateOutputType | null
    _max: Support_faqMaxAggregateOutputType | null
  }

  export type Support_faqAvgAggregateOutputType = {
    id: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
  }

  export type Support_faqSumAggregateOutputType = {
    id: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
  }

  export type Support_faqMinAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    category: string | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_faqMaxAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    category: string | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_faqCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    tags: number
    helpful_count: number
    not_helpful_count: number
    display_order: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Support_faqAvgAggregateInputType = {
    id?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
  }

  export type Support_faqSumAggregateInputType = {
    id?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
  }

  export type Support_faqMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_faqMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_faqCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    tags?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Support_faqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_faq to aggregate.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_faqs
    **/
    _count?: true | Support_faqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_faqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_faqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_faqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_faqMaxAggregateInputType
  }

  export type GetSupport_faqAggregateType<T extends Support_faqAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_faq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_faq[P]>
      : GetScalarType<T[P], AggregateSupport_faq[P]>
  }




  export type support_faqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_faqWhereInput
    orderBy?: support_faqOrderByWithAggregationInput | support_faqOrderByWithAggregationInput[]
    by: Support_faqScalarFieldEnum[] | Support_faqScalarFieldEnum
    having?: support_faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_faqCountAggregateInputType | true
    _avg?: Support_faqAvgAggregateInputType
    _sum?: Support_faqSumAggregateInputType
    _min?: Support_faqMinAggregateInputType
    _max?: Support_faqMaxAggregateInputType
  }

  export type Support_faqGroupByOutputType = {
    id: number
    question: string
    answer: string
    category: string
    tags: string[]
    helpful_count: number
    not_helpful_count: number
    display_order: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Support_faqCountAggregateOutputType | null
    _avg: Support_faqAvgAggregateOutputType | null
    _sum: Support_faqSumAggregateOutputType | null
    _min: Support_faqMinAggregateOutputType | null
    _max: Support_faqMaxAggregateOutputType | null
  }

  type GetSupport_faqGroupByPayload<T extends support_faqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_faqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_faqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_faqGroupByOutputType[P]>
            : GetScalarType<T[P], Support_faqGroupByOutputType[P]>
        }
      >
    >


  export type support_faqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_faq"]>

  export type support_faqSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_faq"]>

  export type support_faqSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_faq"]>

  export type support_faqSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type support_faqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "category" | "tags" | "helpful_count" | "not_helpful_count" | "display_order" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["support_faq"]>

  export type $support_faqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_faq"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
      answer: string
      category: string
      tags: string[]
      helpful_count: number
      not_helpful_count: number
      display_order: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["support_faq"]>
    composites: {}
  }

  type support_faqGetPayload<S extends boolean | null | undefined | support_faqDefaultArgs> = $Result.GetResult<Prisma.$support_faqPayload, S>

  type support_faqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_faqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_faqCountAggregateInputType | true
    }

  export interface support_faqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_faq'], meta: { name: 'support_faq' } }
    /**
     * Find zero or one Support_faq that matches the filter.
     * @param {support_faqFindUniqueArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_faqFindUniqueArgs>(args: SelectSubset<T, support_faqFindUniqueArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_faqFindUniqueOrThrowArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_faqFindUniqueOrThrowArgs>(args: SelectSubset<T, support_faqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqFindFirstArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_faqFindFirstArgs>(args?: SelectSubset<T, support_faqFindFirstArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqFindFirstOrThrowArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_faqFindFirstOrThrowArgs>(args?: SelectSubset<T, support_faqFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_faqs
     * const support_faqs = await prisma.support_faq.findMany()
     * 
     * // Get first 10 Support_faqs
     * const support_faqs = await prisma.support_faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_faqWithIdOnly = await prisma.support_faq.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_faqFindManyArgs>(args?: SelectSubset<T, support_faqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_faq.
     * @param {support_faqCreateArgs} args - Arguments to create a Support_faq.
     * @example
     * // Create one Support_faq
     * const Support_faq = await prisma.support_faq.create({
     *   data: {
     *     // ... data to create a Support_faq
     *   }
     * })
     * 
     */
    create<T extends support_faqCreateArgs>(args: SelectSubset<T, support_faqCreateArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_faqs.
     * @param {support_faqCreateManyArgs} args - Arguments to create many Support_faqs.
     * @example
     * // Create many Support_faqs
     * const support_faq = await prisma.support_faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_faqCreateManyArgs>(args?: SelectSubset<T, support_faqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_faqs and returns the data saved in the database.
     * @param {support_faqCreateManyAndReturnArgs} args - Arguments to create many Support_faqs.
     * @example
     * // Create many Support_faqs
     * const support_faq = await prisma.support_faq.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_faqs and only return the `id`
     * const support_faqWithIdOnly = await prisma.support_faq.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_faqCreateManyAndReturnArgs>(args?: SelectSubset<T, support_faqCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_faq.
     * @param {support_faqDeleteArgs} args - Arguments to delete one Support_faq.
     * @example
     * // Delete one Support_faq
     * const Support_faq = await prisma.support_faq.delete({
     *   where: {
     *     // ... filter to delete one Support_faq
     *   }
     * })
     * 
     */
    delete<T extends support_faqDeleteArgs>(args: SelectSubset<T, support_faqDeleteArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_faq.
     * @param {support_faqUpdateArgs} args - Arguments to update one Support_faq.
     * @example
     * // Update one Support_faq
     * const support_faq = await prisma.support_faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_faqUpdateArgs>(args: SelectSubset<T, support_faqUpdateArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_faqs.
     * @param {support_faqDeleteManyArgs} args - Arguments to filter Support_faqs to delete.
     * @example
     * // Delete a few Support_faqs
     * const { count } = await prisma.support_faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_faqDeleteManyArgs>(args?: SelectSubset<T, support_faqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_faqs
     * const support_faq = await prisma.support_faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_faqUpdateManyArgs>(args: SelectSubset<T, support_faqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_faqs and returns the data updated in the database.
     * @param {support_faqUpdateManyAndReturnArgs} args - Arguments to update many Support_faqs.
     * @example
     * // Update many Support_faqs
     * const support_faq = await prisma.support_faq.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_faqs and only return the `id`
     * const support_faqWithIdOnly = await prisma.support_faq.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_faqUpdateManyAndReturnArgs>(args: SelectSubset<T, support_faqUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_faq.
     * @param {support_faqUpsertArgs} args - Arguments to update or create a Support_faq.
     * @example
     * // Update or create a Support_faq
     * const support_faq = await prisma.support_faq.upsert({
     *   create: {
     *     // ... data to create a Support_faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_faq we want to update
     *   }
     * })
     */
    upsert<T extends support_faqUpsertArgs>(args: SelectSubset<T, support_faqUpsertArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqCountArgs} args - Arguments to filter Support_faqs to count.
     * @example
     * // Count the number of Support_faqs
     * const count = await prisma.support_faq.count({
     *   where: {
     *     // ... the filter for the Support_faqs we want to count
     *   }
     * })
    **/
    count<T extends support_faqCountArgs>(
      args?: Subset<T, support_faqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_faqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_faqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_faqAggregateArgs>(args: Subset<T, Support_faqAggregateArgs>): Prisma.PrismaPromise<GetSupport_faqAggregateType<T>>

    /**
     * Group by Support_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_faqGroupByArgs['orderBy'] }
        : { orderBy?: support_faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_faqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_faq model
   */
  readonly fields: support_faqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_faqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_faq model
   */
  interface support_faqFieldRefs {
    readonly id: FieldRef<"support_faq", 'Int'>
    readonly question: FieldRef<"support_faq", 'String'>
    readonly answer: FieldRef<"support_faq", 'String'>
    readonly category: FieldRef<"support_faq", 'String'>
    readonly tags: FieldRef<"support_faq", 'String[]'>
    readonly helpful_count: FieldRef<"support_faq", 'Int'>
    readonly not_helpful_count: FieldRef<"support_faq", 'Int'>
    readonly display_order: FieldRef<"support_faq", 'Int'>
    readonly is_active: FieldRef<"support_faq", 'Boolean'>
    readonly created_at: FieldRef<"support_faq", 'DateTime'>
    readonly updated_at: FieldRef<"support_faq", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_faq findUnique
   */
  export type support_faqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq findUniqueOrThrow
   */
  export type support_faqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq findFirst
   */
  export type support_faqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_faqs.
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_faqs.
     */
    distinct?: Support_faqScalarFieldEnum | Support_faqScalarFieldEnum[]
  }

  /**
   * support_faq findFirstOrThrow
   */
  export type support_faqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_faqs.
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_faqs.
     */
    distinct?: Support_faqScalarFieldEnum | Support_faqScalarFieldEnum[]
  }

  /**
   * support_faq findMany
   */
  export type support_faqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faqs to fetch.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_faqs.
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    distinct?: Support_faqScalarFieldEnum | Support_faqScalarFieldEnum[]
  }

  /**
   * support_faq create
   */
  export type support_faqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data needed to create a support_faq.
     */
    data: XOR<support_faqCreateInput, support_faqUncheckedCreateInput>
  }

  /**
   * support_faq createMany
   */
  export type support_faqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_faqs.
     */
    data: support_faqCreateManyInput | support_faqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_faq createManyAndReturn
   */
  export type support_faqCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data used to create many support_faqs.
     */
    data: support_faqCreateManyInput | support_faqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_faq update
   */
  export type support_faqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data needed to update a support_faq.
     */
    data: XOR<support_faqUpdateInput, support_faqUncheckedUpdateInput>
    /**
     * Choose, which support_faq to update.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq updateMany
   */
  export type support_faqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_faqs.
     */
    data: XOR<support_faqUpdateManyMutationInput, support_faqUncheckedUpdateManyInput>
    /**
     * Filter which support_faqs to update
     */
    where?: support_faqWhereInput
    /**
     * Limit how many support_faqs to update.
     */
    limit?: number
  }

  /**
   * support_faq updateManyAndReturn
   */
  export type support_faqUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data used to update support_faqs.
     */
    data: XOR<support_faqUpdateManyMutationInput, support_faqUncheckedUpdateManyInput>
    /**
     * Filter which support_faqs to update
     */
    where?: support_faqWhereInput
    /**
     * Limit how many support_faqs to update.
     */
    limit?: number
  }

  /**
   * support_faq upsert
   */
  export type support_faqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The filter to search for the support_faq to update in case it exists.
     */
    where: support_faqWhereUniqueInput
    /**
     * In case the support_faq found by the `where` argument doesn't exist, create a new support_faq with this data.
     */
    create: XOR<support_faqCreateInput, support_faqUncheckedCreateInput>
    /**
     * In case the support_faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_faqUpdateInput, support_faqUncheckedUpdateInput>
  }

  /**
   * support_faq delete
   */
  export type support_faqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter which support_faq to delete.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq deleteMany
   */
  export type support_faqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_faqs to delete
     */
    where?: support_faqWhereInput
    /**
     * Limit how many support_faqs to delete.
     */
    limit?: number
  }

  /**
   * support_faq without action
   */
  export type support_faqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
  }


  /**
   * Model support_categories
   */

  export type AggregateSupport_categories = {
    _count: Support_categoriesCountAggregateOutputType | null
    _avg: Support_categoriesAvgAggregateOutputType | null
    _sum: Support_categoriesSumAggregateOutputType | null
    _min: Support_categoriesMinAggregateOutputType | null
    _max: Support_categoriesMaxAggregateOutputType | null
  }

  export type Support_categoriesAvgAggregateOutputType = {
    id: number | null
    display_order: number | null
  }

  export type Support_categoriesSumAggregateOutputType = {
    id: number | null
    display_order: number | null
  }

  export type Support_categoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_categoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_categoriesCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    display_order: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Support_categoriesAvgAggregateInputType = {
    id?: true
    display_order?: true
  }

  export type Support_categoriesSumAggregateInputType = {
    id?: true
    display_order?: true
  }

  export type Support_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Support_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_categories to aggregate.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_categories
    **/
    _count?: true | Support_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_categoriesMaxAggregateInputType
  }

  export type GetSupport_categoriesAggregateType<T extends Support_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_categories[P]>
      : GetScalarType<T[P], AggregateSupport_categories[P]>
  }




  export type support_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_categoriesWhereInput
    orderBy?: support_categoriesOrderByWithAggregationInput | support_categoriesOrderByWithAggregationInput[]
    by: Support_categoriesScalarFieldEnum[] | Support_categoriesScalarFieldEnum
    having?: support_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_categoriesCountAggregateInputType | true
    _avg?: Support_categoriesAvgAggregateInputType
    _sum?: Support_categoriesSumAggregateInputType
    _min?: Support_categoriesMinAggregateInputType
    _max?: Support_categoriesMaxAggregateInputType
  }

  export type Support_categoriesGroupByOutputType = {
    id: number
    name: string
    slug: string
    description: string | null
    icon: string | null
    display_order: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Support_categoriesCountAggregateOutputType | null
    _avg: Support_categoriesAvgAggregateOutputType | null
    _sum: Support_categoriesSumAggregateOutputType | null
    _min: Support_categoriesMinAggregateOutputType | null
    _max: Support_categoriesMaxAggregateOutputType | null
  }

  type GetSupport_categoriesGroupByPayload<T extends support_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type support_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_categories"]>

  export type support_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_categories"]>

  export type support_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_categories"]>

  export type support_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type support_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "icon" | "display_order" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["support_categories"]>

  export type $support_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      description: string | null
      icon: string | null
      display_order: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["support_categories"]>
    composites: {}
  }

  type support_categoriesGetPayload<S extends boolean | null | undefined | support_categoriesDefaultArgs> = $Result.GetResult<Prisma.$support_categoriesPayload, S>

  type support_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_categoriesCountAggregateInputType | true
    }

  export interface support_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_categories'], meta: { name: 'support_categories' } }
    /**
     * Find zero or one Support_categories that matches the filter.
     * @param {support_categoriesFindUniqueArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_categoriesFindUniqueArgs>(args: SelectSubset<T, support_categoriesFindUniqueArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesFindFirstArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_categoriesFindFirstArgs>(args?: SelectSubset<T, support_categoriesFindFirstArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesFindFirstOrThrowArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_categories
     * const support_categories = await prisma.support_categories.findMany()
     * 
     * // Get first 10 Support_categories
     * const support_categories = await prisma.support_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_categoriesWithIdOnly = await prisma.support_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_categoriesFindManyArgs>(args?: SelectSubset<T, support_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_categories.
     * @param {support_categoriesCreateArgs} args - Arguments to create a Support_categories.
     * @example
     * // Create one Support_categories
     * const Support_categories = await prisma.support_categories.create({
     *   data: {
     *     // ... data to create a Support_categories
     *   }
     * })
     * 
     */
    create<T extends support_categoriesCreateArgs>(args: SelectSubset<T, support_categoriesCreateArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_categories.
     * @param {support_categoriesCreateManyArgs} args - Arguments to create many Support_categories.
     * @example
     * // Create many Support_categories
     * const support_categories = await prisma.support_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_categoriesCreateManyArgs>(args?: SelectSubset<T, support_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_categories and returns the data saved in the database.
     * @param {support_categoriesCreateManyAndReturnArgs} args - Arguments to create many Support_categories.
     * @example
     * // Create many Support_categories
     * const support_categories = await prisma.support_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_categories and only return the `id`
     * const support_categoriesWithIdOnly = await prisma.support_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_categories.
     * @param {support_categoriesDeleteArgs} args - Arguments to delete one Support_categories.
     * @example
     * // Delete one Support_categories
     * const Support_categories = await prisma.support_categories.delete({
     *   where: {
     *     // ... filter to delete one Support_categories
     *   }
     * })
     * 
     */
    delete<T extends support_categoriesDeleteArgs>(args: SelectSubset<T, support_categoriesDeleteArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_categories.
     * @param {support_categoriesUpdateArgs} args - Arguments to update one Support_categories.
     * @example
     * // Update one Support_categories
     * const support_categories = await prisma.support_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_categoriesUpdateArgs>(args: SelectSubset<T, support_categoriesUpdateArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_categories.
     * @param {support_categoriesDeleteManyArgs} args - Arguments to filter Support_categories to delete.
     * @example
     * // Delete a few Support_categories
     * const { count } = await prisma.support_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_categoriesDeleteManyArgs>(args?: SelectSubset<T, support_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_categories
     * const support_categories = await prisma.support_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_categoriesUpdateManyArgs>(args: SelectSubset<T, support_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_categories and returns the data updated in the database.
     * @param {support_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Support_categories.
     * @example
     * // Update many Support_categories
     * const support_categories = await prisma.support_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_categories and only return the `id`
     * const support_categoriesWithIdOnly = await prisma.support_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_categories.
     * @param {support_categoriesUpsertArgs} args - Arguments to update or create a Support_categories.
     * @example
     * // Update or create a Support_categories
     * const support_categories = await prisma.support_categories.upsert({
     *   create: {
     *     // ... data to create a Support_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_categories we want to update
     *   }
     * })
     */
    upsert<T extends support_categoriesUpsertArgs>(args: SelectSubset<T, support_categoriesUpsertArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesCountArgs} args - Arguments to filter Support_categories to count.
     * @example
     * // Count the number of Support_categories
     * const count = await prisma.support_categories.count({
     *   where: {
     *     // ... the filter for the Support_categories we want to count
     *   }
     * })
    **/
    count<T extends support_categoriesCountArgs>(
      args?: Subset<T, support_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_categoriesAggregateArgs>(args: Subset<T, Support_categoriesAggregateArgs>): Prisma.PrismaPromise<GetSupport_categoriesAggregateType<T>>

    /**
     * Group by Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: support_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_categories model
   */
  readonly fields: support_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_categories model
   */
  interface support_categoriesFieldRefs {
    readonly id: FieldRef<"support_categories", 'Int'>
    readonly name: FieldRef<"support_categories", 'String'>
    readonly slug: FieldRef<"support_categories", 'String'>
    readonly description: FieldRef<"support_categories", 'String'>
    readonly icon: FieldRef<"support_categories", 'String'>
    readonly display_order: FieldRef<"support_categories", 'Int'>
    readonly is_active: FieldRef<"support_categories", 'Boolean'>
    readonly created_at: FieldRef<"support_categories", 'DateTime'>
    readonly updated_at: FieldRef<"support_categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_categories findUnique
   */
  export type support_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories findUniqueOrThrow
   */
  export type support_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories findFirst
   */
  export type support_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_categories.
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_categories.
     */
    distinct?: Support_categoriesScalarFieldEnum | Support_categoriesScalarFieldEnum[]
  }

  /**
   * support_categories findFirstOrThrow
   */
  export type support_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_categories.
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_categories.
     */
    distinct?: Support_categoriesScalarFieldEnum | Support_categoriesScalarFieldEnum[]
  }

  /**
   * support_categories findMany
   */
  export type support_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_categories.
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    distinct?: Support_categoriesScalarFieldEnum | Support_categoriesScalarFieldEnum[]
  }

  /**
   * support_categories create
   */
  export type support_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_categories.
     */
    data: XOR<support_categoriesCreateInput, support_categoriesUncheckedCreateInput>
  }

  /**
   * support_categories createMany
   */
  export type support_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_categories.
     */
    data: support_categoriesCreateManyInput | support_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_categories createManyAndReturn
   */
  export type support_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many support_categories.
     */
    data: support_categoriesCreateManyInput | support_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_categories update
   */
  export type support_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_categories.
     */
    data: XOR<support_categoriesUpdateInput, support_categoriesUncheckedUpdateInput>
    /**
     * Choose, which support_categories to update.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories updateMany
   */
  export type support_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_categories.
     */
    data: XOR<support_categoriesUpdateManyMutationInput, support_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which support_categories to update
     */
    where?: support_categoriesWhereInput
    /**
     * Limit how many support_categories to update.
     */
    limit?: number
  }

  /**
   * support_categories updateManyAndReturn
   */
  export type support_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update support_categories.
     */
    data: XOR<support_categoriesUpdateManyMutationInput, support_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which support_categories to update
     */
    where?: support_categoriesWhereInput
    /**
     * Limit how many support_categories to update.
     */
    limit?: number
  }

  /**
   * support_categories upsert
   */
  export type support_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_categories to update in case it exists.
     */
    where: support_categoriesWhereUniqueInput
    /**
     * In case the support_categories found by the `where` argument doesn't exist, create a new support_categories with this data.
     */
    create: XOR<support_categoriesCreateInput, support_categoriesUncheckedCreateInput>
    /**
     * In case the support_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_categoriesUpdateInput, support_categoriesUncheckedUpdateInput>
  }

  /**
   * support_categories delete
   */
  export type support_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter which support_categories to delete.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories deleteMany
   */
  export type support_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_categories to delete
     */
    where?: support_categoriesWhereInput
    /**
     * Limit how many support_categories to delete.
     */
    limit?: number
  }

  /**
   * support_categories without action
   */
  export type support_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
  }


  /**
   * Model support_replies
   */

  export type AggregateSupport_replies = {
    _count: Support_repliesCountAggregateOutputType | null
    _avg: Support_repliesAvgAggregateOutputType | null
    _sum: Support_repliesSumAggregateOutputType | null
    _min: Support_repliesMinAggregateOutputType | null
    _max: Support_repliesMaxAggregateOutputType | null
  }

  export type Support_repliesAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
  }

  export type Support_repliesSumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
  }

  export type Support_repliesMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
  }

  export type Support_repliesMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
  }

  export type Support_repliesCountAggregateOutputType = {
    id: number
    ticket_id: number
    sender_id: number
    sender_name: number
    sender_type: number
    content: number
    is_internal: number
    created_at: number
    _all: number
  }


  export type Support_repliesAvgAggregateInputType = {
    id?: true
    ticket_id?: true
  }

  export type Support_repliesSumAggregateInputType = {
    id?: true
    ticket_id?: true
  }

  export type Support_repliesMinAggregateInputType = {
    id?: true
    ticket_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
  }

  export type Support_repliesMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
  }

  export type Support_repliesCountAggregateInputType = {
    id?: true
    ticket_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
    _all?: true
  }

  export type Support_repliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_replies to aggregate.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_replies
    **/
    _count?: true | Support_repliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_repliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_repliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_repliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_repliesMaxAggregateInputType
  }

  export type GetSupport_repliesAggregateType<T extends Support_repliesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_replies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_replies[P]>
      : GetScalarType<T[P], AggregateSupport_replies[P]>
  }




  export type support_repliesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_repliesWhereInput
    orderBy?: support_repliesOrderByWithAggregationInput | support_repliesOrderByWithAggregationInput[]
    by: Support_repliesScalarFieldEnum[] | Support_repliesScalarFieldEnum
    having?: support_repliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_repliesCountAggregateInputType | true
    _avg?: Support_repliesAvgAggregateInputType
    _sum?: Support_repliesSumAggregateInputType
    _min?: Support_repliesMinAggregateInputType
    _max?: Support_repliesMaxAggregateInputType
  }

  export type Support_repliesGroupByOutputType = {
    id: number
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal: boolean
    created_at: Date
    _count: Support_repliesCountAggregateOutputType | null
    _avg: Support_repliesAvgAggregateOutputType | null
    _sum: Support_repliesSumAggregateOutputType | null
    _min: Support_repliesMinAggregateOutputType | null
    _max: Support_repliesMaxAggregateOutputType | null
  }

  type GetSupport_repliesGroupByPayload<T extends support_repliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_repliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_repliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_repliesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_repliesGroupByOutputType[P]>
        }
      >
    >


  export type support_repliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["support_replies"]>

  export type support_repliesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["support_replies"]>

  export type support_repliesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["support_replies"]>

  export type support_repliesSelectScalar = {
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }

  export type support_repliesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "sender_id" | "sender_name" | "sender_type" | "content" | "is_internal" | "created_at", ExtArgs["result"]["support_replies"]>

  export type $support_repliesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_replies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      sender_id: string
      sender_name: string
      sender_type: string
      content: string
      is_internal: boolean
      created_at: Date
    }, ExtArgs["result"]["support_replies"]>
    composites: {}
  }

  type support_repliesGetPayload<S extends boolean | null | undefined | support_repliesDefaultArgs> = $Result.GetResult<Prisma.$support_repliesPayload, S>

  type support_repliesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_repliesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_repliesCountAggregateInputType | true
    }

  export interface support_repliesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_replies'], meta: { name: 'support_replies' } }
    /**
     * Find zero or one Support_replies that matches the filter.
     * @param {support_repliesFindUniqueArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_repliesFindUniqueArgs>(args: SelectSubset<T, support_repliesFindUniqueArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_replies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_repliesFindUniqueOrThrowArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_repliesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_repliesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesFindFirstArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_repliesFindFirstArgs>(args?: SelectSubset<T, support_repliesFindFirstArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_replies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesFindFirstOrThrowArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_repliesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_repliesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_replies
     * const support_replies = await prisma.support_replies.findMany()
     * 
     * // Get first 10 Support_replies
     * const support_replies = await prisma.support_replies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_repliesWithIdOnly = await prisma.support_replies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_repliesFindManyArgs>(args?: SelectSubset<T, support_repliesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_replies.
     * @param {support_repliesCreateArgs} args - Arguments to create a Support_replies.
     * @example
     * // Create one Support_replies
     * const Support_replies = await prisma.support_replies.create({
     *   data: {
     *     // ... data to create a Support_replies
     *   }
     * })
     * 
     */
    create<T extends support_repliesCreateArgs>(args: SelectSubset<T, support_repliesCreateArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_replies.
     * @param {support_repliesCreateManyArgs} args - Arguments to create many Support_replies.
     * @example
     * // Create many Support_replies
     * const support_replies = await prisma.support_replies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_repliesCreateManyArgs>(args?: SelectSubset<T, support_repliesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_replies and returns the data saved in the database.
     * @param {support_repliesCreateManyAndReturnArgs} args - Arguments to create many Support_replies.
     * @example
     * // Create many Support_replies
     * const support_replies = await prisma.support_replies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_replies and only return the `id`
     * const support_repliesWithIdOnly = await prisma.support_replies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_repliesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_repliesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_replies.
     * @param {support_repliesDeleteArgs} args - Arguments to delete one Support_replies.
     * @example
     * // Delete one Support_replies
     * const Support_replies = await prisma.support_replies.delete({
     *   where: {
     *     // ... filter to delete one Support_replies
     *   }
     * })
     * 
     */
    delete<T extends support_repliesDeleteArgs>(args: SelectSubset<T, support_repliesDeleteArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_replies.
     * @param {support_repliesUpdateArgs} args - Arguments to update one Support_replies.
     * @example
     * // Update one Support_replies
     * const support_replies = await prisma.support_replies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_repliesUpdateArgs>(args: SelectSubset<T, support_repliesUpdateArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_replies.
     * @param {support_repliesDeleteManyArgs} args - Arguments to filter Support_replies to delete.
     * @example
     * // Delete a few Support_replies
     * const { count } = await prisma.support_replies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_repliesDeleteManyArgs>(args?: SelectSubset<T, support_repliesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_replies
     * const support_replies = await prisma.support_replies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_repliesUpdateManyArgs>(args: SelectSubset<T, support_repliesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_replies and returns the data updated in the database.
     * @param {support_repliesUpdateManyAndReturnArgs} args - Arguments to update many Support_replies.
     * @example
     * // Update many Support_replies
     * const support_replies = await prisma.support_replies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_replies and only return the `id`
     * const support_repliesWithIdOnly = await prisma.support_replies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_repliesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_repliesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_replies.
     * @param {support_repliesUpsertArgs} args - Arguments to update or create a Support_replies.
     * @example
     * // Update or create a Support_replies
     * const support_replies = await prisma.support_replies.upsert({
     *   create: {
     *     // ... data to create a Support_replies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_replies we want to update
     *   }
     * })
     */
    upsert<T extends support_repliesUpsertArgs>(args: SelectSubset<T, support_repliesUpsertArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesCountArgs} args - Arguments to filter Support_replies to count.
     * @example
     * // Count the number of Support_replies
     * const count = await prisma.support_replies.count({
     *   where: {
     *     // ... the filter for the Support_replies we want to count
     *   }
     * })
    **/
    count<T extends support_repliesCountArgs>(
      args?: Subset<T, support_repliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_repliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_repliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_repliesAggregateArgs>(args: Subset<T, Support_repliesAggregateArgs>): Prisma.PrismaPromise<GetSupport_repliesAggregateType<T>>

    /**
     * Group by Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_repliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_repliesGroupByArgs['orderBy'] }
        : { orderBy?: support_repliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_repliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_repliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_replies model
   */
  readonly fields: support_repliesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_replies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_repliesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_replies model
   */
  interface support_repliesFieldRefs {
    readonly id: FieldRef<"support_replies", 'Int'>
    readonly ticket_id: FieldRef<"support_replies", 'Int'>
    readonly sender_id: FieldRef<"support_replies", 'String'>
    readonly sender_name: FieldRef<"support_replies", 'String'>
    readonly sender_type: FieldRef<"support_replies", 'String'>
    readonly content: FieldRef<"support_replies", 'String'>
    readonly is_internal: FieldRef<"support_replies", 'Boolean'>
    readonly created_at: FieldRef<"support_replies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_replies findUnique
   */
  export type support_repliesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies findUniqueOrThrow
   */
  export type support_repliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies findFirst
   */
  export type support_repliesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_replies.
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_replies.
     */
    distinct?: Support_repliesScalarFieldEnum | Support_repliesScalarFieldEnum[]
  }

  /**
   * support_replies findFirstOrThrow
   */
  export type support_repliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_replies.
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_replies.
     */
    distinct?: Support_repliesScalarFieldEnum | Support_repliesScalarFieldEnum[]
  }

  /**
   * support_replies findMany
   */
  export type support_repliesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_replies.
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    distinct?: Support_repliesScalarFieldEnum | Support_repliesScalarFieldEnum[]
  }

  /**
   * support_replies create
   */
  export type support_repliesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_replies.
     */
    data: XOR<support_repliesCreateInput, support_repliesUncheckedCreateInput>
  }

  /**
   * support_replies createMany
   */
  export type support_repliesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_replies.
     */
    data: support_repliesCreateManyInput | support_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_replies createManyAndReturn
   */
  export type support_repliesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data used to create many support_replies.
     */
    data: support_repliesCreateManyInput | support_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_replies update
   */
  export type support_repliesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_replies.
     */
    data: XOR<support_repliesUpdateInput, support_repliesUncheckedUpdateInput>
    /**
     * Choose, which support_replies to update.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies updateMany
   */
  export type support_repliesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_replies.
     */
    data: XOR<support_repliesUpdateManyMutationInput, support_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_replies to update
     */
    where?: support_repliesWhereInput
    /**
     * Limit how many support_replies to update.
     */
    limit?: number
  }

  /**
   * support_replies updateManyAndReturn
   */
  export type support_repliesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data used to update support_replies.
     */
    data: XOR<support_repliesUpdateManyMutationInput, support_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_replies to update
     */
    where?: support_repliesWhereInput
    /**
     * Limit how many support_replies to update.
     */
    limit?: number
  }

  /**
   * support_replies upsert
   */
  export type support_repliesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_replies to update in case it exists.
     */
    where: support_repliesWhereUniqueInput
    /**
     * In case the support_replies found by the `where` argument doesn't exist, create a new support_replies with this data.
     */
    create: XOR<support_repliesCreateInput, support_repliesUncheckedCreateInput>
    /**
     * In case the support_replies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_repliesUpdateInput, support_repliesUncheckedUpdateInput>
  }

  /**
   * support_replies delete
   */
  export type support_repliesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter which support_replies to delete.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies deleteMany
   */
  export type support_repliesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_replies to delete
     */
    where?: support_repliesWhereInput
    /**
     * Limit how many support_replies to delete.
     */
    limit?: number
  }

  /**
   * support_replies without action
   */
  export type support_repliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    country: 'country',
    createdAt: 'createdAt',
    emailVerified: 'emailVerified',
    lastLoginAt: 'lastLoginAt',
    role: 'role',
    status: 'status'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const KYCScalarFieldEnum: {
    id: 'id',
    isDocumentVerified: 'isDocumentVerified',
    isAddressVerified: 'isAddressVerified',
    verificationStatus: 'verificationStatus',
    documentReference: 'documentReference',
    addressReference: 'addressReference',
    amlReference: 'amlReference',
    documentSubmittedAt: 'documentSubmittedAt',
    addressSubmittedAt: 'addressSubmittedAt',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type KYCScalarFieldEnum = (typeof KYCScalarFieldEnum)[keyof typeof KYCScalarFieldEnum]


  export const MT5AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    userId: 'userId',
    accountType: 'accountType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    password: 'password',
    leverage: 'leverage'
  };

  export type MT5AccountScalarFieldEnum = (typeof MT5AccountScalarFieldEnum)[keyof typeof MT5AccountScalarFieldEnum]


  export const MT5TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    comment: 'comment',
    mt5AccountId: 'mt5AccountId',
    createdAt: 'createdAt',
    currency: 'currency',
    depositId: 'depositId',
    withdrawalId: 'withdrawalId',
    userId: 'userId',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    updatedAt: 'updatedAt'
  };

  export type MT5TransactionScalarFieldEnum = (typeof MT5TransactionScalarFieldEnum)[keyof typeof MT5TransactionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountType: 'accountType',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    status: 'status',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    description: 'description',
    metadata: 'metadata',
    depositId: 'depositId',
    withdrawalId: 'withdrawalId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const DepositScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mt5AccountId: 'mt5AccountId',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    paymentMethod: 'paymentMethod',
    transactionHash: 'transactionHash',
    proofFileUrl: 'proofFileUrl',
    bankDetails: 'bankDetails',
    cryptoAddress: 'cryptoAddress',
    depositAddress: 'depositAddress',
    externalTransactionId: 'externalTransactionId',
    status: 'status',
    rejectionReason: 'rejectionReason',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepositScalarFieldEnum = (typeof DepositScalarFieldEnum)[keyof typeof DepositScalarFieldEnum]


  export const WithdrawalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mt5AccountId: 'mt5AccountId',
    amount: 'amount',
    method: 'method',
    bankDetails: 'bankDetails',
    cryptoAddress: 'cryptoAddress',
    status: 'status',
    rejectionReason: 'rejectionReason',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    externalTransactionId: 'externalTransactionId',
    paymentMethod: 'paymentMethod',
    processedAt: 'processedAt',
    walletAddress: 'walletAddress'
  };

  export type WithdrawalScalarFieldEnum = (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminId: 'adminId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    oldValues: 'oldValues',
    newValues: 'newValues',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    permissions: 'permissions',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    address: 'address',
    currency: 'currency',
    network: 'network',
    status: 'status',
    submittedAt: 'submittedAt',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const DefaultMT5AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mt5AccountId: 'mt5AccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DefaultMT5AccountScalarFieldEnum = (typeof DefaultMT5AccountScalarFieldEnum)[keyof typeof DefaultMT5AccountScalarFieldEnum]


  export const InstrumentScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    name: 'name',
    description: 'description',
    category: 'category',
    group: 'group',
    digits: 'digits',
    contractSize: 'contractSize',
    minVolume: 'minVolume',
    maxVolume: 'maxVolume',
    volumeStep: 'volumeStep',
    spread: 'spread',
    isActive: 'isActive',
    tradingHours: 'tradingHours',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstrumentScalarFieldEnum = (typeof InstrumentScalarFieldEnum)[keyof typeof InstrumentScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revoked: 'revoked'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const UserFavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    instrumentId: 'instrumentId',
    sortOrder: 'sortOrder',
    addedAt: 'addedAt'
  };

  export type UserFavoriteScalarFieldEnum = (typeof UserFavoriteScalarFieldEnum)[keyof typeof UserFavoriteScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password_hash: 'password_hash',
    admin_role: 'admin_role',
    is_active: 'is_active',
    last_login: 'last_login',
    login_attempts: 'login_attempts',
    locked_until: 'locked_until',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const Admin_login_logScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    location: 'location',
    device: 'device',
    browser: 'browser',
    os: 'os',
    success: 'success',
    failure_reason: 'failure_reason',
    created_at: 'created_at'
  };

  export type Admin_login_logScalarFieldEnum = (typeof Admin_login_logScalarFieldEnum)[keyof typeof Admin_login_logScalarFieldEnum]


  export const Balance_operation_historyScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    mt5_login: 'mt5_login',
    operation_type: 'operation_type',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    status: 'status',
    error_message: 'error_message',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    created_at: 'created_at'
  };

  export type Balance_operation_historyScalarFieldEnum = (typeof Balance_operation_historyScalarFieldEnum)[keyof typeof Balance_operation_historyScalarFieldEnum]


  export const Chat_conversationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    user_name: 'user_name',
    user_email: 'user_email',
    admin_id: 'admin_id',
    status: 'status',
    priority: 'priority',
    subject: 'subject',
    last_message_at: 'last_message_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    closed_at: 'closed_at',
    closed_by: 'closed_by',
    tags: 'tags',
    unread_count_admin: 'unread_count_admin',
    unread_count_user: 'unread_count_user'
  };

  export type Chat_conversationsScalarFieldEnum = (typeof Chat_conversationsScalarFieldEnum)[keyof typeof Chat_conversationsScalarFieldEnum]


  export const Chat_messagesScalarFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    sender_id: 'sender_id',
    sender_name: 'sender_name',
    sender_type: 'sender_type',
    message_type: 'message_type',
    content: 'content',
    metadata: 'metadata',
    is_read: 'is_read',
    read_at: 'read_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Chat_messagesScalarFieldEnum = (typeof Chat_messagesScalarFieldEnum)[keyof typeof Chat_messagesScalarFieldEnum]


  export const Chat_participantsScalarFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    user_id: 'user_id',
    user_name: 'user_name',
    user_type: 'user_type',
    role: 'role',
    joined_at: 'joined_at',
    left_at: 'left_at',
    is_active: 'is_active'
  };

  export type Chat_participantsScalarFieldEnum = (typeof Chat_participantsScalarFieldEnum)[keyof typeof Chat_participantsScalarFieldEnum]


  export const Group_commission_structuresScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    structure_name: 'structure_name',
    usd_per_lot: 'usd_per_lot',
    spread_share_percentage: 'spread_share_percentage',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Group_commission_structuresScalarFieldEnum = (typeof Group_commission_structuresScalarFieldEnum)[keyof typeof Group_commission_structuresScalarFieldEnum]


  export const Ib_adminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    is_active: 'is_active',
    last_login: 'last_login',
    login_attempts: 'login_attempts',
    locked_until: 'locked_until',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ib_adminScalarFieldEnum = (typeof Ib_adminScalarFieldEnum)[keyof typeof Ib_adminScalarFieldEnum]


  export const Ib_requestsScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    password_hash: 'password_hash',
    status: 'status',
    ib_type: 'ib_type',
    submitted_at: 'submitted_at',
    approved_at: 'approved_at',
    usd_per_lot: 'usd_per_lot',
    spread_percentage_per_lot: 'spread_percentage_per_lot',
    admin_comments: 'admin_comments',
    group_id: 'group_id',
    structure_id: 'structure_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ib_requestsScalarFieldEnum = (typeof Ib_requestsScalarFieldEnum)[keyof typeof Ib_requestsScalarFieldEnum]


  export const Manual_gatewayScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    details: 'details',
    icon_url: 'icon_url',
    qr_code_url: 'qr_code_url',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Manual_gatewayScalarFieldEnum = (typeof Manual_gatewayScalarFieldEnum)[keyof typeof Manual_gatewayScalarFieldEnum]


  export const Mt5_groupsScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    name: 'name',
    description: 'description',
    synced_at: 'synced_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Mt5_groupsScalarFieldEnum = (typeof Mt5_groupsScalarFieldEnum)[keyof typeof Mt5_groupsScalarFieldEnum]


  export const Payment_gatewayScalarFieldEnum: {
    id: 'id',
    wallet_name: 'wallet_name',
    deposit_wallet_address: 'deposit_wallet_address',
    api_key: 'api_key',
    secret_key: 'secret_key',
    gateway_type: 'gateway_type',
    is_active: 'is_active',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Payment_gatewayScalarFieldEnum = (typeof Payment_gatewayScalarFieldEnum)[keyof typeof Payment_gatewayScalarFieldEnum]


  export const SymbolsScalarFieldEnum: {
    id: 'id',
    symbol_name: 'symbol_name',
    description: 'description',
    symbol_type: 'symbol_type',
    group_name: 'group_name',
    digits: 'digits',
    spread: 'spread',
    contract_size: 'contract_size',
    profit_mode: 'profit_mode',
    enable: 'enable',
    swap_mode: 'swap_mode',
    swap_long: 'swap_long',
    swap_short: 'swap_short',
    swap3_day: 'swap3_day',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SymbolsScalarFieldEnum = (typeof SymbolsScalarFieldEnum)[keyof typeof SymbolsScalarFieldEnum]


  export const Ib_group_assignmentsScalarFieldEnum: {
    id: 'id',
    ib_request_id: 'ib_request_id',
    group_id: 'group_id',
    group_name: 'group_name',
    structure_id: 'structure_id',
    structure_name: 'structure_name',
    usd_per_lot: 'usd_per_lot',
    spread_share_percentage: 'spread_share_percentage',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ib_group_assignmentsScalarFieldEnum = (typeof Ib_group_assignmentsScalarFieldEnum)[keyof typeof Ib_group_assignmentsScalarFieldEnum]


  export const Ib_trade_historyScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    account_id: 'account_id',
    user_id: 'user_id',
    ib_request_id: 'ib_request_id',
    symbol: 'symbol',
    order_type: 'order_type',
    volume_lots: 'volume_lots',
    open_price: 'open_price',
    close_price: 'close_price',
    profit: 'profit',
    ib_commission: 'ib_commission',
    take_profit: 'take_profit',
    stop_loss: 'stop_loss',
    created_at: 'created_at',
    updated_at: 'updated_at',
    synced_at: 'synced_at',
    group_id: 'group_id'
  };

  export type Ib_trade_historyScalarFieldEnum = (typeof Ib_trade_historyScalarFieldEnum)[keyof typeof Ib_trade_historyScalarFieldEnum]


  export const Support_ticketsScalarFieldEnum: {
    id: 'id',
    ticket_no: 'ticket_no',
    parent_id: 'parent_id',
    title: 'title',
    description: 'description',
    ticket_type: 'ticket_type',
    status: 'status',
    priority: 'priority',
    assigned_to: 'assigned_to',
    account_number: 'account_number',
    tags: 'tags',
    created_at: 'created_at',
    updated_at: 'updated_at',
    last_reply_at: 'last_reply_at',
    closed_at: 'closed_at',
    closed_by: 'closed_by'
  };

  export type Support_ticketsScalarFieldEnum = (typeof Support_ticketsScalarFieldEnum)[keyof typeof Support_ticketsScalarFieldEnum]


  export const Support_ticket_repliesScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    reply_id: 'reply_id',
    sender_id: 'sender_id',
    sender_name: 'sender_name',
    sender_type: 'sender_type',
    content: 'content',
    is_internal: 'is_internal',
    attachments: 'attachments',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_read: 'is_read'
  };

  export type Support_ticket_repliesScalarFieldEnum = (typeof Support_ticket_repliesScalarFieldEnum)[keyof typeof Support_ticket_repliesScalarFieldEnum]


  export const Support_articlesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    category: 'category',
    tags: 'tags',
    views: 'views',
    helpful_count: 'helpful_count',
    not_helpful_count: 'not_helpful_count',
    is_published: 'is_published',
    author_id: 'author_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    published_at: 'published_at'
  };

  export type Support_articlesScalarFieldEnum = (typeof Support_articlesScalarFieldEnum)[keyof typeof Support_articlesScalarFieldEnum]


  export const Support_faqScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    tags: 'tags',
    helpful_count: 'helpful_count',
    not_helpful_count: 'not_helpful_count',
    display_order: 'display_order',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Support_faqScalarFieldEnum = (typeof Support_faqScalarFieldEnum)[keyof typeof Support_faqScalarFieldEnum]


  export const Support_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    display_order: 'display_order',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Support_categoriesScalarFieldEnum = (typeof Support_categoriesScalarFieldEnum)[keyof typeof Support_categoriesScalarFieldEnum]


  export const Support_repliesScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    sender_id: 'sender_id',
    sender_name: 'sender_name',
    sender_type: 'sender_type',
    content: 'content',
    is_internal: 'is_internal',
    created_at: 'created_at'
  };

  export type Support_repliesScalarFieldEnum = (typeof Support_repliesScalarFieldEnum)[keyof typeof Support_repliesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    clientId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    accounts?: AccountListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    DefaultMT5Account?: XOR<DefaultMT5AccountNullableScalarRelationFilter, DefaultMT5AccountWhereInput> | null
    deposits?: DepositListRelationFilter
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    mt5Accounts?: MT5AccountListRelationFilter
    RefreshToken?: RefreshTokenListRelationFilter
    transactions?: TransactionListRelationFilter
    UserFavorite?: UserFavoriteListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    DefaultMT5Account?: DefaultMT5AccountOrderByWithRelationInput
    deposits?: DepositOrderByRelationAggregateInput
    kyc?: KYCOrderByWithRelationInput
    mt5Accounts?: MT5AccountOrderByRelationAggregateInput
    RefreshToken?: RefreshTokenOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    UserFavorite?: UserFavoriteOrderByRelationAggregateInput
    withdrawals?: WithdrawalOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    accounts?: AccountListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    DefaultMT5Account?: XOR<DefaultMT5AccountNullableScalarRelationFilter, DefaultMT5AccountWhereInput> | null
    deposits?: DepositListRelationFilter
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    mt5Accounts?: MT5AccountListRelationFilter
    RefreshToken?: RefreshTokenListRelationFilter
    transactions?: TransactionListRelationFilter
    UserFavorite?: UserFavoriteListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
  }, "id" | "clientId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    clientId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
  }

  export type KYCWhereInput = {
    AND?: KYCWhereInput | KYCWhereInput[]
    OR?: KYCWhereInput[]
    NOT?: KYCWhereInput | KYCWhereInput[]
    id?: StringFilter<"KYC"> | string
    isDocumentVerified?: BoolFilter<"KYC"> | boolean
    isAddressVerified?: BoolFilter<"KYC"> | boolean
    verificationStatus?: StringFilter<"KYC"> | string
    documentReference?: StringNullableFilter<"KYC"> | string | null
    addressReference?: StringNullableFilter<"KYC"> | string | null
    amlReference?: StringNullableFilter<"KYC"> | string | null
    documentSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    addressSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    rejectionReason?: StringNullableFilter<"KYC"> | string | null
    createdAt?: DateTimeFilter<"KYC"> | Date | string
    updatedAt?: DateTimeFilter<"KYC"> | Date | string
    userId?: StringFilter<"KYC"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type KYCOrderByWithRelationInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrderInput | SortOrder
    addressReference?: SortOrderInput | SortOrder
    amlReference?: SortOrderInput | SortOrder
    documentSubmittedAt?: SortOrderInput | SortOrder
    addressSubmittedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type KYCWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: KYCWhereInput | KYCWhereInput[]
    OR?: KYCWhereInput[]
    NOT?: KYCWhereInput | KYCWhereInput[]
    isDocumentVerified?: BoolFilter<"KYC"> | boolean
    isAddressVerified?: BoolFilter<"KYC"> | boolean
    verificationStatus?: StringFilter<"KYC"> | string
    documentReference?: StringNullableFilter<"KYC"> | string | null
    addressReference?: StringNullableFilter<"KYC"> | string | null
    amlReference?: StringNullableFilter<"KYC"> | string | null
    documentSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    addressSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    rejectionReason?: StringNullableFilter<"KYC"> | string | null
    createdAt?: DateTimeFilter<"KYC"> | Date | string
    updatedAt?: DateTimeFilter<"KYC"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type KYCOrderByWithAggregationInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrderInput | SortOrder
    addressReference?: SortOrderInput | SortOrder
    amlReference?: SortOrderInput | SortOrder
    documentSubmittedAt?: SortOrderInput | SortOrder
    addressSubmittedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: KYCCountOrderByAggregateInput
    _max?: KYCMaxOrderByAggregateInput
    _min?: KYCMinOrderByAggregateInput
  }

  export type KYCScalarWhereWithAggregatesInput = {
    AND?: KYCScalarWhereWithAggregatesInput | KYCScalarWhereWithAggregatesInput[]
    OR?: KYCScalarWhereWithAggregatesInput[]
    NOT?: KYCScalarWhereWithAggregatesInput | KYCScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KYC"> | string
    isDocumentVerified?: BoolWithAggregatesFilter<"KYC"> | boolean
    isAddressVerified?: BoolWithAggregatesFilter<"KYC"> | boolean
    verificationStatus?: StringWithAggregatesFilter<"KYC"> | string
    documentReference?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    addressReference?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    amlReference?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    documentSubmittedAt?: DateTimeNullableWithAggregatesFilter<"KYC"> | Date | string | null
    addressSubmittedAt?: DateTimeNullableWithAggregatesFilter<"KYC"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KYC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KYC"> | Date | string
    userId?: StringWithAggregatesFilter<"KYC"> | string
  }

  export type MT5AccountWhereInput = {
    AND?: MT5AccountWhereInput | MT5AccountWhereInput[]
    OR?: MT5AccountWhereInput[]
    NOT?: MT5AccountWhereInput | MT5AccountWhereInput[]
    id?: StringFilter<"MT5Account"> | string
    accountId?: StringFilter<"MT5Account"> | string
    userId?: StringNullableFilter<"MT5Account"> | string | null
    accountType?: StringFilter<"MT5Account"> | string
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    leverage?: IntNullableFilter<"MT5Account"> | number | null
    DefaultMT5Account?: DefaultMT5AccountListRelationFilter
    deposits?: DepositListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mt5Transactions?: MT5TransactionListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
  }

  export type MT5AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrderInput | SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    leverage?: SortOrderInput | SortOrder
    DefaultMT5Account?: DefaultMT5AccountOrderByRelationAggregateInput
    deposits?: DepositOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    mt5Transactions?: MT5TransactionOrderByRelationAggregateInput
    withdrawals?: WithdrawalOrderByRelationAggregateInput
  }

  export type MT5AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: MT5AccountWhereInput | MT5AccountWhereInput[]
    OR?: MT5AccountWhereInput[]
    NOT?: MT5AccountWhereInput | MT5AccountWhereInput[]
    userId?: StringNullableFilter<"MT5Account"> | string | null
    accountType?: StringFilter<"MT5Account"> | string
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    leverage?: IntNullableFilter<"MT5Account"> | number | null
    DefaultMT5Account?: DefaultMT5AccountListRelationFilter
    deposits?: DepositListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mt5Transactions?: MT5TransactionListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
  }, "id" | "accountId">

  export type MT5AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrderInput | SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    leverage?: SortOrderInput | SortOrder
    _count?: MT5AccountCountOrderByAggregateInput
    _avg?: MT5AccountAvgOrderByAggregateInput
    _max?: MT5AccountMaxOrderByAggregateInput
    _min?: MT5AccountMinOrderByAggregateInput
    _sum?: MT5AccountSumOrderByAggregateInput
  }

  export type MT5AccountScalarWhereWithAggregatesInput = {
    AND?: MT5AccountScalarWhereWithAggregatesInput | MT5AccountScalarWhereWithAggregatesInput[]
    OR?: MT5AccountScalarWhereWithAggregatesInput[]
    NOT?: MT5AccountScalarWhereWithAggregatesInput | MT5AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MT5Account"> | string
    accountId?: StringWithAggregatesFilter<"MT5Account"> | string
    userId?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    accountType?: StringWithAggregatesFilter<"MT5Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MT5Account"> | Date | string
    password?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    leverage?: IntNullableWithAggregatesFilter<"MT5Account"> | number | null
  }

  export type MT5TransactionWhereInput = {
    AND?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    OR?: MT5TransactionWhereInput[]
    NOT?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    id?: StringFilter<"MT5Transaction"> | string
    type?: StringFilter<"MT5Transaction"> | string
    amount?: FloatFilter<"MT5Transaction"> | number
    status?: StringNullableFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableFilter<"MT5Transaction"> | string | null
    comment?: StringNullableFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"MT5Transaction"> | string | null
    userId?: StringNullableFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
  }

  export type MT5TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    mt5Account?: MT5AccountOrderByWithRelationInput
  }

  export type MT5TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    OR?: MT5TransactionWhereInput[]
    NOT?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    type?: StringFilter<"MT5Transaction"> | string
    amount?: FloatFilter<"MT5Transaction"> | number
    status?: StringNullableFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableFilter<"MT5Transaction"> | string | null
    comment?: StringNullableFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"MT5Transaction"> | string | null
    userId?: StringNullableFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
  }, "id">

  export type MT5TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MT5TransactionCountOrderByAggregateInput
    _avg?: MT5TransactionAvgOrderByAggregateInput
    _max?: MT5TransactionMaxOrderByAggregateInput
    _min?: MT5TransactionMinOrderByAggregateInput
    _sum?: MT5TransactionSumOrderByAggregateInput
  }

  export type MT5TransactionScalarWhereWithAggregatesInput = {
    AND?: MT5TransactionScalarWhereWithAggregatesInput | MT5TransactionScalarWhereWithAggregatesInput[]
    OR?: MT5TransactionScalarWhereWithAggregatesInput[]
    NOT?: MT5TransactionScalarWhereWithAggregatesInput | MT5TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MT5Transaction"> | string
    type?: StringWithAggregatesFilter<"MT5Transaction"> | string
    amount?: FloatWithAggregatesFilter<"MT5Transaction"> | number
    status?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    comment?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringWithAggregatesFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    userId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MT5Transaction"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountType?: StringFilter<"Account"> | string
    balance?: FloatFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountType?: StringFilter<"Account"> | string
    balance?: FloatFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountType?: StringWithAggregatesFilter<"Account"> | string
    balance?: FloatWithAggregatesFilter<"Account"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    currency?: StringFilter<"Transaction"> | string
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    depositId?: StringNullableFilter<"Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"Transaction"> | string | null
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    deposit?: XOR<DepositNullableScalarRelationFilter, DepositWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    withdrawal?: XOR<WithdrawalNullableScalarRelationFilter, WithdrawalWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deposit?: DepositOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    withdrawal?: WithdrawalOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    currency?: StringFilter<"Transaction"> | string
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    depositId?: StringNullableFilter<"Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"Transaction"> | string | null
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    deposit?: XOR<DepositNullableScalarRelationFilter, DepositWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    withdrawal?: XOR<WithdrawalNullableScalarRelationFilter, WithdrawalWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    status?: StringWithAggregatesFilter<"Transaction"> | string
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    depositId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    withdrawalId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type DepositWhereInput = {
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    id?: StringFilter<"Deposit"> | string
    userId?: StringFilter<"Deposit"> | string
    mt5AccountId?: StringFilter<"Deposit"> | string
    amount?: FloatFilter<"Deposit"> | number
    currency?: StringFilter<"Deposit"> | string
    method?: StringFilter<"Deposit"> | string
    paymentMethod?: StringNullableFilter<"Deposit"> | string | null
    transactionHash?: StringNullableFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableFilter<"Deposit"> | string | null
    bankDetails?: StringNullableFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableFilter<"Deposit"> | string | null
    depositAddress?: StringNullableFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    rejectionReason?: StringNullableFilter<"Deposit"> | string | null
    approvedBy?: StringNullableFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type DepositOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    proofFileUrl?: SortOrderInput | SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    depositAddress?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mt5Account?: MT5AccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type DepositWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    userId?: StringFilter<"Deposit"> | string
    mt5AccountId?: StringFilter<"Deposit"> | string
    amount?: FloatFilter<"Deposit"> | number
    currency?: StringFilter<"Deposit"> | string
    method?: StringFilter<"Deposit"> | string
    paymentMethod?: StringNullableFilter<"Deposit"> | string | null
    transactionHash?: StringNullableFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableFilter<"Deposit"> | string | null
    bankDetails?: StringNullableFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableFilter<"Deposit"> | string | null
    depositAddress?: StringNullableFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    rejectionReason?: StringNullableFilter<"Deposit"> | string | null
    approvedBy?: StringNullableFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id">

  export type DepositOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    proofFileUrl?: SortOrderInput | SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    depositAddress?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepositCountOrderByAggregateInput
    _avg?: DepositAvgOrderByAggregateInput
    _max?: DepositMaxOrderByAggregateInput
    _min?: DepositMinOrderByAggregateInput
    _sum?: DepositSumOrderByAggregateInput
  }

  export type DepositScalarWhereWithAggregatesInput = {
    AND?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    OR?: DepositScalarWhereWithAggregatesInput[]
    NOT?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deposit"> | string
    userId?: StringWithAggregatesFilter<"Deposit"> | string
    mt5AccountId?: StringWithAggregatesFilter<"Deposit"> | string
    amount?: FloatWithAggregatesFilter<"Deposit"> | number
    currency?: StringWithAggregatesFilter<"Deposit"> | string
    method?: StringWithAggregatesFilter<"Deposit"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    transactionHash?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    bankDetails?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    depositAddress?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    status?: StringWithAggregatesFilter<"Deposit"> | string
    rejectionReason?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
  }

  export type WithdrawalWhereInput = {
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    id?: StringFilter<"Withdrawal"> | string
    userId?: StringFilter<"Withdrawal"> | string
    mt5AccountId?: StringFilter<"Withdrawal"> | string
    amount?: FloatFilter<"Withdrawal"> | number
    method?: StringFilter<"Withdrawal"> | string
    bankDetails?: StringNullableFilter<"Withdrawal"> | string | null
    cryptoAddress?: StringNullableFilter<"Withdrawal"> | string | null
    status?: StringFilter<"Withdrawal"> | string
    rejectionReason?: StringNullableFilter<"Withdrawal"> | string | null
    approvedBy?: StringNullableFilter<"Withdrawal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    currency?: StringFilter<"Withdrawal"> | string
    externalTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    paymentMethod?: StringNullableFilter<"Withdrawal"> | string | null
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    walletAddress?: StringNullableFilter<"Withdrawal"> | string | null
    transactions?: TransactionListRelationFilter
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WithdrawalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    mt5Account?: MT5AccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WithdrawalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    userId?: StringFilter<"Withdrawal"> | string
    mt5AccountId?: StringFilter<"Withdrawal"> | string
    amount?: FloatFilter<"Withdrawal"> | number
    method?: StringFilter<"Withdrawal"> | string
    bankDetails?: StringNullableFilter<"Withdrawal"> | string | null
    cryptoAddress?: StringNullableFilter<"Withdrawal"> | string | null
    status?: StringFilter<"Withdrawal"> | string
    rejectionReason?: StringNullableFilter<"Withdrawal"> | string | null
    approvedBy?: StringNullableFilter<"Withdrawal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    currency?: StringFilter<"Withdrawal"> | string
    externalTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    paymentMethod?: StringNullableFilter<"Withdrawal"> | string | null
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    walletAddress?: StringNullableFilter<"Withdrawal"> | string | null
    transactions?: TransactionListRelationFilter
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WithdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    _count?: WithdrawalCountOrderByAggregateInput
    _avg?: WithdrawalAvgOrderByAggregateInput
    _max?: WithdrawalMaxOrderByAggregateInput
    _min?: WithdrawalMinOrderByAggregateInput
    _sum?: WithdrawalSumOrderByAggregateInput
  }

  export type WithdrawalScalarWhereWithAggregatesInput = {
    AND?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    OR?: WithdrawalScalarWhereWithAggregatesInput[]
    NOT?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Withdrawal"> | string
    userId?: StringWithAggregatesFilter<"Withdrawal"> | string
    mt5AccountId?: StringWithAggregatesFilter<"Withdrawal"> | string
    amount?: FloatWithAggregatesFilter<"Withdrawal"> | number
    method?: StringWithAggregatesFilter<"Withdrawal"> | string
    bankDetails?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    cryptoAddress?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    status?: StringWithAggregatesFilter<"Withdrawal"> | string
    rejectionReason?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Withdrawal"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    currency?: StringWithAggregatesFilter<"Withdrawal"> | string
    externalTransactionId?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Withdrawal"> | Date | string | null
    walletAddress?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableFilter<"ActivityLog"> | string | null
    newValues?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableFilter<"ActivityLog"> | string | null
    newValues?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    adminId?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    entity?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    newValues?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    category?: StringWithAggregatesFilter<"SystemSetting"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    permissions?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    permissions?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    permissions?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    address?: StringFilter<"PaymentMethod"> | string
    currency?: StringFilter<"PaymentMethod"> | string
    network?: StringFilter<"PaymentMethod"> | string
    status?: StringFilter<"PaymentMethod"> | string
    submittedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    approvedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    approvedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    rejectionReason?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    userId?: StringFilter<"PaymentMethod"> | string
    address?: StringFilter<"PaymentMethod"> | string
    currency?: StringFilter<"PaymentMethod"> | string
    network?: StringFilter<"PaymentMethod"> | string
    status?: StringFilter<"PaymentMethod"> | string
    submittedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    approvedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    approvedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    rejectionReason?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    userId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    address?: StringWithAggregatesFilter<"PaymentMethod"> | string
    currency?: StringWithAggregatesFilter<"PaymentMethod"> | string
    network?: StringWithAggregatesFilter<"PaymentMethod"> | string
    status?: StringWithAggregatesFilter<"PaymentMethod"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PaymentMethod"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: StringFilter<"UserRole"> | string
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: StringFilter<"UserRole"> | string
  }, "id">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    assignedBy?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type DefaultMT5AccountWhereInput = {
    AND?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    OR?: DefaultMT5AccountWhereInput[]
    NOT?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    id?: StringFilter<"DefaultMT5Account"> | string
    userId?: StringFilter<"DefaultMT5Account"> | string
    mt5AccountId?: StringFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    MT5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DefaultMT5AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    MT5Account?: MT5AccountOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type DefaultMT5AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    OR?: DefaultMT5AccountWhereInput[]
    NOT?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    mt5AccountId?: StringFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    MT5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DefaultMT5AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DefaultMT5AccountCountOrderByAggregateInput
    _max?: DefaultMT5AccountMaxOrderByAggregateInput
    _min?: DefaultMT5AccountMinOrderByAggregateInput
  }

  export type DefaultMT5AccountScalarWhereWithAggregatesInput = {
    AND?: DefaultMT5AccountScalarWhereWithAggregatesInput | DefaultMT5AccountScalarWhereWithAggregatesInput[]
    OR?: DefaultMT5AccountScalarWhereWithAggregatesInput[]
    NOT?: DefaultMT5AccountScalarWhereWithAggregatesInput | DefaultMT5AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefaultMT5Account"> | string
    userId?: StringWithAggregatesFilter<"DefaultMT5Account"> | string
    mt5AccountId?: StringWithAggregatesFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DefaultMT5Account"> | Date | string
  }

  export type InstrumentWhereInput = {
    AND?: InstrumentWhereInput | InstrumentWhereInput[]
    OR?: InstrumentWhereInput[]
    NOT?: InstrumentWhereInput | InstrumentWhereInput[]
    id?: StringFilter<"Instrument"> | string
    symbol?: StringFilter<"Instrument"> | string
    name?: StringNullableFilter<"Instrument"> | string | null
    description?: StringNullableFilter<"Instrument"> | string | null
    category?: StringFilter<"Instrument"> | string
    group?: StringNullableFilter<"Instrument"> | string | null
    digits?: IntFilter<"Instrument"> | number
    contractSize?: FloatFilter<"Instrument"> | number
    minVolume?: FloatFilter<"Instrument"> | number
    maxVolume?: FloatFilter<"Instrument"> | number
    volumeStep?: FloatFilter<"Instrument"> | number
    spread?: FloatFilter<"Instrument"> | number
    isActive?: BoolFilter<"Instrument"> | boolean
    tradingHours?: StringNullableFilter<"Instrument"> | string | null
    lastUpdated?: DateTimeFilter<"Instrument"> | Date | string
    createdAt?: DateTimeFilter<"Instrument"> | Date | string
    updatedAt?: DateTimeFilter<"Instrument"> | Date | string
    UserFavorite?: UserFavoriteListRelationFilter
  }

  export type InstrumentOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    group?: SortOrderInput | SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    UserFavorite?: UserFavoriteOrderByRelationAggregateInput
  }

  export type InstrumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbol?: string
    AND?: InstrumentWhereInput | InstrumentWhereInput[]
    OR?: InstrumentWhereInput[]
    NOT?: InstrumentWhereInput | InstrumentWhereInput[]
    name?: StringNullableFilter<"Instrument"> | string | null
    description?: StringNullableFilter<"Instrument"> | string | null
    category?: StringFilter<"Instrument"> | string
    group?: StringNullableFilter<"Instrument"> | string | null
    digits?: IntFilter<"Instrument"> | number
    contractSize?: FloatFilter<"Instrument"> | number
    minVolume?: FloatFilter<"Instrument"> | number
    maxVolume?: FloatFilter<"Instrument"> | number
    volumeStep?: FloatFilter<"Instrument"> | number
    spread?: FloatFilter<"Instrument"> | number
    isActive?: BoolFilter<"Instrument"> | boolean
    tradingHours?: StringNullableFilter<"Instrument"> | string | null
    lastUpdated?: DateTimeFilter<"Instrument"> | Date | string
    createdAt?: DateTimeFilter<"Instrument"> | Date | string
    updatedAt?: DateTimeFilter<"Instrument"> | Date | string
    UserFavorite?: UserFavoriteListRelationFilter
  }, "id" | "symbol">

  export type InstrumentOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    group?: SortOrderInput | SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstrumentCountOrderByAggregateInput
    _avg?: InstrumentAvgOrderByAggregateInput
    _max?: InstrumentMaxOrderByAggregateInput
    _min?: InstrumentMinOrderByAggregateInput
    _sum?: InstrumentSumOrderByAggregateInput
  }

  export type InstrumentScalarWhereWithAggregatesInput = {
    AND?: InstrumentScalarWhereWithAggregatesInput | InstrumentScalarWhereWithAggregatesInput[]
    OR?: InstrumentScalarWhereWithAggregatesInput[]
    NOT?: InstrumentScalarWhereWithAggregatesInput | InstrumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Instrument"> | string
    symbol?: StringWithAggregatesFilter<"Instrument"> | string
    name?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    description?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    category?: StringWithAggregatesFilter<"Instrument"> | string
    group?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    digits?: IntWithAggregatesFilter<"Instrument"> | number
    contractSize?: FloatWithAggregatesFilter<"Instrument"> | number
    minVolume?: FloatWithAggregatesFilter<"Instrument"> | number
    maxVolume?: FloatWithAggregatesFilter<"Instrument"> | number
    volumeStep?: FloatWithAggregatesFilter<"Instrument"> | number
    spread?: FloatWithAggregatesFilter<"Instrument"> | number
    isActive?: BoolWithAggregatesFilter<"Instrument"> | boolean
    tradingHours?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"Instrument"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Instrument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instrument"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableFilter<"RefreshToken"> | boolean | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    revoked?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableFilter<"RefreshToken"> | boolean | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    revoked?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableWithAggregatesFilter<"RefreshToken"> | boolean | null
  }

  export type UserFavoriteWhereInput = {
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    id?: StringFilter<"UserFavorite"> | string
    userId?: StringFilter<"UserFavorite"> | string
    instrumentId?: StringFilter<"UserFavorite"> | string
    sortOrder?: IntFilter<"UserFavorite"> | number
    addedAt?: DateTimeFilter<"UserFavorite"> | Date | string
    Instrument?: XOR<InstrumentScalarRelationFilter, InstrumentWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
    Instrument?: InstrumentOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type UserFavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_instrumentId?: UserFavoriteUserIdInstrumentIdCompoundUniqueInput
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    userId?: StringFilter<"UserFavorite"> | string
    instrumentId?: StringFilter<"UserFavorite"> | string
    sortOrder?: IntFilter<"UserFavorite"> | number
    addedAt?: DateTimeFilter<"UserFavorite"> | Date | string
    Instrument?: XOR<InstrumentScalarRelationFilter, InstrumentWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_instrumentId">

  export type UserFavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
    _count?: UserFavoriteCountOrderByAggregateInput
    _avg?: UserFavoriteAvgOrderByAggregateInput
    _max?: UserFavoriteMaxOrderByAggregateInput
    _min?: UserFavoriteMinOrderByAggregateInput
    _sum?: UserFavoriteSumOrderByAggregateInput
  }

  export type UserFavoriteScalarWhereWithAggregatesInput = {
    AND?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    OR?: UserFavoriteScalarWhereWithAggregatesInput[]
    NOT?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFavorite"> | string
    userId?: StringWithAggregatesFilter<"UserFavorite"> | string
    instrumentId?: StringWithAggregatesFilter<"UserFavorite"> | string
    sortOrder?: IntWithAggregatesFilter<"UserFavorite"> | number
    addedAt?: DateTimeWithAggregatesFilter<"UserFavorite"> | Date | string
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: IntFilter<"admin"> | number
    username?: StringFilter<"admin"> | string
    email?: StringFilter<"admin"> | string
    password_hash?: StringFilter<"admin"> | string
    admin_role?: StringNullableFilter<"admin"> | string | null
    is_active?: BoolNullableFilter<"admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"admin"> | number | null
    locked_until?: DateTimeNullableFilter<"admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    admin_login_log?: Admin_login_logListRelationFilter
    balance_operation_history?: Balance_operation_historyListRelationFilter
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    admin_login_log?: admin_login_logOrderByRelationAggregateInput
    balance_operation_history?: balance_operation_historyOrderByRelationAggregateInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    password_hash?: StringFilter<"admin"> | string
    admin_role?: StringNullableFilter<"admin"> | string | null
    is_active?: BoolNullableFilter<"admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"admin"> | number | null
    locked_until?: DateTimeNullableFilter<"admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    admin_login_log?: Admin_login_logListRelationFilter
    balance_operation_history?: Balance_operation_historyListRelationFilter
  }, "id" | "username" | "email">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin"> | number
    username?: StringWithAggregatesFilter<"admin"> | string
    email?: StringWithAggregatesFilter<"admin"> | string
    password_hash?: StringWithAggregatesFilter<"admin"> | string
    admin_role?: StringNullableWithAggregatesFilter<"admin"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"admin"> | boolean | null
    last_login?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    login_attempts?: IntNullableWithAggregatesFilter<"admin"> | number | null
    locked_until?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
  }

  export type admin_login_logWhereInput = {
    AND?: admin_login_logWhereInput | admin_login_logWhereInput[]
    OR?: admin_login_logWhereInput[]
    NOT?: admin_login_logWhereInput | admin_login_logWhereInput[]
    id?: IntFilter<"admin_login_log"> | number
    admin_id?: IntFilter<"admin_login_log"> | number
    ip_address?: StringFilter<"admin_login_log"> | string
    user_agent?: StringNullableFilter<"admin_login_log"> | string | null
    location?: StringNullableFilter<"admin_login_log"> | string | null
    device?: StringNullableFilter<"admin_login_log"> | string | null
    browser?: StringNullableFilter<"admin_login_log"> | string | null
    os?: StringNullableFilter<"admin_login_log"> | string | null
    success?: BoolFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableFilter<"admin_login_log"> | string | null
    created_at?: DateTimeFilter<"admin_login_log"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }

  export type admin_login_logOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    success?: SortOrder
    failure_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    admin?: adminOrderByWithRelationInput
  }

  export type admin_login_logWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: admin_login_logWhereInput | admin_login_logWhereInput[]
    OR?: admin_login_logWhereInput[]
    NOT?: admin_login_logWhereInput | admin_login_logWhereInput[]
    admin_id?: IntFilter<"admin_login_log"> | number
    ip_address?: StringFilter<"admin_login_log"> | string
    user_agent?: StringNullableFilter<"admin_login_log"> | string | null
    location?: StringNullableFilter<"admin_login_log"> | string | null
    device?: StringNullableFilter<"admin_login_log"> | string | null
    browser?: StringNullableFilter<"admin_login_log"> | string | null
    os?: StringNullableFilter<"admin_login_log"> | string | null
    success?: BoolFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableFilter<"admin_login_log"> | string | null
    created_at?: DateTimeFilter<"admin_login_log"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }, "id">

  export type admin_login_logOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    success?: SortOrder
    failure_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: admin_login_logCountOrderByAggregateInput
    _avg?: admin_login_logAvgOrderByAggregateInput
    _max?: admin_login_logMaxOrderByAggregateInput
    _min?: admin_login_logMinOrderByAggregateInput
    _sum?: admin_login_logSumOrderByAggregateInput
  }

  export type admin_login_logScalarWhereWithAggregatesInput = {
    AND?: admin_login_logScalarWhereWithAggregatesInput | admin_login_logScalarWhereWithAggregatesInput[]
    OR?: admin_login_logScalarWhereWithAggregatesInput[]
    NOT?: admin_login_logScalarWhereWithAggregatesInput | admin_login_logScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin_login_log"> | number
    admin_id?: IntWithAggregatesFilter<"admin_login_log"> | number
    ip_address?: StringWithAggregatesFilter<"admin_login_log"> | string
    user_agent?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    location?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    device?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    browser?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    os?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    success?: BoolWithAggregatesFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"admin_login_log"> | Date | string
  }

  export type balance_operation_historyWhereInput = {
    AND?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    OR?: balance_operation_historyWhereInput[]
    NOT?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    id?: IntFilter<"balance_operation_history"> | number
    admin_id?: IntFilter<"balance_operation_history"> | number
    mt5_login?: StringFilter<"balance_operation_history"> | string
    operation_type?: StringFilter<"balance_operation_history"> | string
    amount?: FloatFilter<"balance_operation_history"> | number
    currency?: StringFilter<"balance_operation_history"> | string
    description?: StringNullableFilter<"balance_operation_history"> | string | null
    status?: StringFilter<"balance_operation_history"> | string
    error_message?: StringNullableFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeFilter<"balance_operation_history"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }

  export type balance_operation_historyOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    admin?: adminOrderByWithRelationInput
  }

  export type balance_operation_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    OR?: balance_operation_historyWhereInput[]
    NOT?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    admin_id?: IntFilter<"balance_operation_history"> | number
    mt5_login?: StringFilter<"balance_operation_history"> | string
    operation_type?: StringFilter<"balance_operation_history"> | string
    amount?: FloatFilter<"balance_operation_history"> | number
    currency?: StringFilter<"balance_operation_history"> | string
    description?: StringNullableFilter<"balance_operation_history"> | string | null
    status?: StringFilter<"balance_operation_history"> | string
    error_message?: StringNullableFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeFilter<"balance_operation_history"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }, "id">

  export type balance_operation_historyOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: balance_operation_historyCountOrderByAggregateInput
    _avg?: balance_operation_historyAvgOrderByAggregateInput
    _max?: balance_operation_historyMaxOrderByAggregateInput
    _min?: balance_operation_historyMinOrderByAggregateInput
    _sum?: balance_operation_historySumOrderByAggregateInput
  }

  export type balance_operation_historyScalarWhereWithAggregatesInput = {
    AND?: balance_operation_historyScalarWhereWithAggregatesInput | balance_operation_historyScalarWhereWithAggregatesInput[]
    OR?: balance_operation_historyScalarWhereWithAggregatesInput[]
    NOT?: balance_operation_historyScalarWhereWithAggregatesInput | balance_operation_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"balance_operation_history"> | number
    admin_id?: IntWithAggregatesFilter<"balance_operation_history"> | number
    mt5_login?: StringWithAggregatesFilter<"balance_operation_history"> | string
    operation_type?: StringWithAggregatesFilter<"balance_operation_history"> | string
    amount?: FloatWithAggregatesFilter<"balance_operation_history"> | number
    currency?: StringWithAggregatesFilter<"balance_operation_history"> | string
    description?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    status?: StringWithAggregatesFilter<"balance_operation_history"> | string
    error_message?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"balance_operation_history"> | Date | string
  }

  export type chat_conversationsWhereInput = {
    AND?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    OR?: chat_conversationsWhereInput[]
    NOT?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    id?: IntFilter<"chat_conversations"> | number
    user_id?: StringFilter<"chat_conversations"> | string
    user_name?: StringFilter<"chat_conversations"> | string
    user_email?: StringFilter<"chat_conversations"> | string
    admin_id?: StringNullableFilter<"chat_conversations"> | string | null
    status?: StringNullableFilter<"chat_conversations"> | string | null
    priority?: StringNullableFilter<"chat_conversations"> | string | null
    subject?: StringNullableFilter<"chat_conversations"> | string | null
    last_message_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_by?: StringNullableFilter<"chat_conversations"> | string | null
    tags?: StringNullableListFilter<"chat_conversations">
    unread_count_admin?: IntNullableFilter<"chat_conversations"> | number | null
    unread_count_user?: IntNullableFilter<"chat_conversations"> | number | null
    chat_messages?: Chat_messagesListRelationFilter
    chat_participants?: Chat_participantsListRelationFilter
  }

  export type chat_conversationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    last_message_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
    tags?: SortOrder
    unread_count_admin?: SortOrderInput | SortOrder
    unread_count_user?: SortOrderInput | SortOrder
    chat_messages?: chat_messagesOrderByRelationAggregateInput
    chat_participants?: chat_participantsOrderByRelationAggregateInput
  }

  export type chat_conversationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    OR?: chat_conversationsWhereInput[]
    NOT?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    user_id?: StringFilter<"chat_conversations"> | string
    user_name?: StringFilter<"chat_conversations"> | string
    user_email?: StringFilter<"chat_conversations"> | string
    admin_id?: StringNullableFilter<"chat_conversations"> | string | null
    status?: StringNullableFilter<"chat_conversations"> | string | null
    priority?: StringNullableFilter<"chat_conversations"> | string | null
    subject?: StringNullableFilter<"chat_conversations"> | string | null
    last_message_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_by?: StringNullableFilter<"chat_conversations"> | string | null
    tags?: StringNullableListFilter<"chat_conversations">
    unread_count_admin?: IntNullableFilter<"chat_conversations"> | number | null
    unread_count_user?: IntNullableFilter<"chat_conversations"> | number | null
    chat_messages?: Chat_messagesListRelationFilter
    chat_participants?: Chat_participantsListRelationFilter
  }, "id">

  export type chat_conversationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    last_message_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
    tags?: SortOrder
    unread_count_admin?: SortOrderInput | SortOrder
    unread_count_user?: SortOrderInput | SortOrder
    _count?: chat_conversationsCountOrderByAggregateInput
    _avg?: chat_conversationsAvgOrderByAggregateInput
    _max?: chat_conversationsMaxOrderByAggregateInput
    _min?: chat_conversationsMinOrderByAggregateInput
    _sum?: chat_conversationsSumOrderByAggregateInput
  }

  export type chat_conversationsScalarWhereWithAggregatesInput = {
    AND?: chat_conversationsScalarWhereWithAggregatesInput | chat_conversationsScalarWhereWithAggregatesInput[]
    OR?: chat_conversationsScalarWhereWithAggregatesInput[]
    NOT?: chat_conversationsScalarWhereWithAggregatesInput | chat_conversationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat_conversations"> | number
    user_id?: StringWithAggregatesFilter<"chat_conversations"> | string
    user_name?: StringWithAggregatesFilter<"chat_conversations"> | string
    user_email?: StringWithAggregatesFilter<"chat_conversations"> | string
    admin_id?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    status?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    priority?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    subject?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    last_message_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    closed_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    closed_by?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    tags?: StringNullableListFilter<"chat_conversations">
    unread_count_admin?: IntNullableWithAggregatesFilter<"chat_conversations"> | number | null
    unread_count_user?: IntNullableWithAggregatesFilter<"chat_conversations"> | number | null
  }

  export type chat_messagesWhereInput = {
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    id?: IntFilter<"chat_messages"> | number
    conversation_id?: IntNullableFilter<"chat_messages"> | number | null
    sender_id?: StringFilter<"chat_messages"> | string
    sender_name?: StringFilter<"chat_messages"> | string
    sender_type?: StringFilter<"chat_messages"> | string
    message_type?: StringNullableFilter<"chat_messages"> | string | null
    content?: StringFilter<"chat_messages"> | string
    metadata?: JsonNullableFilter<"chat_messages">
    is_read?: BoolNullableFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }

  export type chat_messagesOrderByWithRelationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    chat_conversations?: chat_conversationsOrderByWithRelationInput
  }

  export type chat_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    conversation_id?: IntNullableFilter<"chat_messages"> | number | null
    sender_id?: StringFilter<"chat_messages"> | string
    sender_name?: StringFilter<"chat_messages"> | string
    sender_type?: StringFilter<"chat_messages"> | string
    message_type?: StringNullableFilter<"chat_messages"> | string | null
    content?: StringFilter<"chat_messages"> | string
    metadata?: JsonNullableFilter<"chat_messages">
    is_read?: BoolNullableFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }, "id">

  export type chat_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: chat_messagesCountOrderByAggregateInput
    _avg?: chat_messagesAvgOrderByAggregateInput
    _max?: chat_messagesMaxOrderByAggregateInput
    _min?: chat_messagesMinOrderByAggregateInput
    _sum?: chat_messagesSumOrderByAggregateInput
  }

  export type chat_messagesScalarWhereWithAggregatesInput = {
    AND?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    OR?: chat_messagesScalarWhereWithAggregatesInput[]
    NOT?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat_messages"> | number
    conversation_id?: IntNullableWithAggregatesFilter<"chat_messages"> | number | null
    sender_id?: StringWithAggregatesFilter<"chat_messages"> | string
    sender_name?: StringWithAggregatesFilter<"chat_messages"> | string
    sender_type?: StringWithAggregatesFilter<"chat_messages"> | string
    message_type?: StringNullableWithAggregatesFilter<"chat_messages"> | string | null
    content?: StringWithAggregatesFilter<"chat_messages"> | string
    metadata?: JsonNullableWithAggregatesFilter<"chat_messages">
    is_read?: BoolNullableWithAggregatesFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableWithAggregatesFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"chat_messages"> | Date | string | null
  }

  export type chat_participantsWhereInput = {
    AND?: chat_participantsWhereInput | chat_participantsWhereInput[]
    OR?: chat_participantsWhereInput[]
    NOT?: chat_participantsWhereInput | chat_participantsWhereInput[]
    id?: IntFilter<"chat_participants"> | number
    conversation_id?: IntNullableFilter<"chat_participants"> | number | null
    user_id?: StringFilter<"chat_participants"> | string
    user_name?: StringFilter<"chat_participants"> | string
    user_type?: StringFilter<"chat_participants"> | string
    role?: StringNullableFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableFilter<"chat_participants"> | boolean | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }

  export type chat_participantsOrderByWithRelationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrderInput | SortOrder
    joined_at?: SortOrderInput | SortOrder
    left_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    chat_conversations?: chat_conversationsOrderByWithRelationInput
  }

  export type chat_participantsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    conversation_id_user_id?: chat_participantsConversation_idUser_idCompoundUniqueInput
    AND?: chat_participantsWhereInput | chat_participantsWhereInput[]
    OR?: chat_participantsWhereInput[]
    NOT?: chat_participantsWhereInput | chat_participantsWhereInput[]
    conversation_id?: IntNullableFilter<"chat_participants"> | number | null
    user_id?: StringFilter<"chat_participants"> | string
    user_name?: StringFilter<"chat_participants"> | string
    user_type?: StringFilter<"chat_participants"> | string
    role?: StringNullableFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableFilter<"chat_participants"> | boolean | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }, "id" | "conversation_id_user_id">

  export type chat_participantsOrderByWithAggregationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrderInput | SortOrder
    joined_at?: SortOrderInput | SortOrder
    left_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: chat_participantsCountOrderByAggregateInput
    _avg?: chat_participantsAvgOrderByAggregateInput
    _max?: chat_participantsMaxOrderByAggregateInput
    _min?: chat_participantsMinOrderByAggregateInput
    _sum?: chat_participantsSumOrderByAggregateInput
  }

  export type chat_participantsScalarWhereWithAggregatesInput = {
    AND?: chat_participantsScalarWhereWithAggregatesInput | chat_participantsScalarWhereWithAggregatesInput[]
    OR?: chat_participantsScalarWhereWithAggregatesInput[]
    NOT?: chat_participantsScalarWhereWithAggregatesInput | chat_participantsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat_participants"> | number
    conversation_id?: IntNullableWithAggregatesFilter<"chat_participants"> | number | null
    user_id?: StringWithAggregatesFilter<"chat_participants"> | string
    user_name?: StringWithAggregatesFilter<"chat_participants"> | string
    user_type?: StringWithAggregatesFilter<"chat_participants"> | string
    role?: StringNullableWithAggregatesFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableWithAggregatesFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableWithAggregatesFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"chat_participants"> | boolean | null
  }

  export type group_commission_structuresWhereInput = {
    AND?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    OR?: group_commission_structuresWhereInput[]
    NOT?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    id?: IntFilter<"group_commission_structures"> | number
    group_id?: StringFilter<"group_commission_structures"> | string
    structure_name?: StringFilter<"group_commission_structures"> | string
    usd_per_lot?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"group_commission_structures"> | boolean
    created_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
  }

  export type group_commission_structuresOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type group_commission_structuresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    group_id_structure_name?: group_commission_structuresGroup_idStructure_nameCompoundUniqueInput
    AND?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    OR?: group_commission_structuresWhereInput[]
    NOT?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    group_id?: StringFilter<"group_commission_structures"> | string
    structure_name?: StringFilter<"group_commission_structures"> | string
    usd_per_lot?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"group_commission_structures"> | boolean
    created_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
  }, "id" | "group_id_structure_name">

  export type group_commission_structuresOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: group_commission_structuresCountOrderByAggregateInput
    _avg?: group_commission_structuresAvgOrderByAggregateInput
    _max?: group_commission_structuresMaxOrderByAggregateInput
    _min?: group_commission_structuresMinOrderByAggregateInput
    _sum?: group_commission_structuresSumOrderByAggregateInput
  }

  export type group_commission_structuresScalarWhereWithAggregatesInput = {
    AND?: group_commission_structuresScalarWhereWithAggregatesInput | group_commission_structuresScalarWhereWithAggregatesInput[]
    OR?: group_commission_structuresScalarWhereWithAggregatesInput[]
    NOT?: group_commission_structuresScalarWhereWithAggregatesInput | group_commission_structuresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"group_commission_structures"> | number
    group_id?: StringWithAggregatesFilter<"group_commission_structures"> | string
    structure_name?: StringWithAggregatesFilter<"group_commission_structures"> | string
    usd_per_lot?: DecimalWithAggregatesFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalWithAggregatesFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolWithAggregatesFilter<"group_commission_structures"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"group_commission_structures"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"group_commission_structures"> | Date | string | null
  }

  export type ib_adminWhereInput = {
    AND?: ib_adminWhereInput | ib_adminWhereInput[]
    OR?: ib_adminWhereInput[]
    NOT?: ib_adminWhereInput | ib_adminWhereInput[]
    id?: IntFilter<"ib_admin"> | number
    email?: StringFilter<"ib_admin"> | string
    password_hash?: StringFilter<"ib_admin"> | string
    role?: StringNullableFilter<"ib_admin"> | string | null
    is_active?: BoolNullableFilter<"ib_admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"ib_admin"> | number | null
    locked_until?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
  }

  export type ib_adminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type ib_adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ib_adminWhereInput | ib_adminWhereInput[]
    OR?: ib_adminWhereInput[]
    NOT?: ib_adminWhereInput | ib_adminWhereInput[]
    password_hash?: StringFilter<"ib_admin"> | string
    role?: StringNullableFilter<"ib_admin"> | string | null
    is_active?: BoolNullableFilter<"ib_admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"ib_admin"> | number | null
    locked_until?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
  }, "id" | "email">

  export type ib_adminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ib_adminCountOrderByAggregateInput
    _avg?: ib_adminAvgOrderByAggregateInput
    _max?: ib_adminMaxOrderByAggregateInput
    _min?: ib_adminMinOrderByAggregateInput
    _sum?: ib_adminSumOrderByAggregateInput
  }

  export type ib_adminScalarWhereWithAggregatesInput = {
    AND?: ib_adminScalarWhereWithAggregatesInput | ib_adminScalarWhereWithAggregatesInput[]
    OR?: ib_adminScalarWhereWithAggregatesInput[]
    NOT?: ib_adminScalarWhereWithAggregatesInput | ib_adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_admin"> | number
    email?: StringWithAggregatesFilter<"ib_admin"> | string
    password_hash?: StringWithAggregatesFilter<"ib_admin"> | string
    role?: StringNullableWithAggregatesFilter<"ib_admin"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"ib_admin"> | boolean | null
    last_login?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
    login_attempts?: IntNullableWithAggregatesFilter<"ib_admin"> | number | null
    locked_until?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
  }

  export type ib_requestsWhereInput = {
    AND?: ib_requestsWhereInput | ib_requestsWhereInput[]
    OR?: ib_requestsWhereInput[]
    NOT?: ib_requestsWhereInput | ib_requestsWhereInput[]
    id?: IntFilter<"ib_requests"> | number
    full_name?: StringFilter<"ib_requests"> | string
    email?: StringFilter<"ib_requests"> | string
    password_hash?: StringFilter<"ib_requests"> | string
    status?: StringFilter<"ib_requests"> | string
    ib_type?: StringFilter<"ib_requests"> | string
    submitted_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    approved_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    usd_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    admin_comments?: StringNullableFilter<"ib_requests"> | string | null
    group_id?: StringNullableFilter<"ib_requests"> | string | null
    structure_id?: IntNullableFilter<"ib_requests"> | number | null
    created_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    ib_group_assignments?: Ib_group_assignmentsListRelationFilter
  }

  export type ib_requestsOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrderInput | SortOrder
    spread_percentage_per_lot?: SortOrderInput | SortOrder
    admin_comments?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    ib_group_assignments?: ib_group_assignmentsOrderByRelationAggregateInput
  }

  export type ib_requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ib_requestsWhereInput | ib_requestsWhereInput[]
    OR?: ib_requestsWhereInput[]
    NOT?: ib_requestsWhereInput | ib_requestsWhereInput[]
    full_name?: StringFilter<"ib_requests"> | string
    password_hash?: StringFilter<"ib_requests"> | string
    status?: StringFilter<"ib_requests"> | string
    ib_type?: StringFilter<"ib_requests"> | string
    submitted_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    approved_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    usd_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    admin_comments?: StringNullableFilter<"ib_requests"> | string | null
    group_id?: StringNullableFilter<"ib_requests"> | string | null
    structure_id?: IntNullableFilter<"ib_requests"> | number | null
    created_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    ib_group_assignments?: Ib_group_assignmentsListRelationFilter
  }, "id" | "email">

  export type ib_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrderInput | SortOrder
    spread_percentage_per_lot?: SortOrderInput | SortOrder
    admin_comments?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ib_requestsCountOrderByAggregateInput
    _avg?: ib_requestsAvgOrderByAggregateInput
    _max?: ib_requestsMaxOrderByAggregateInput
    _min?: ib_requestsMinOrderByAggregateInput
    _sum?: ib_requestsSumOrderByAggregateInput
  }

  export type ib_requestsScalarWhereWithAggregatesInput = {
    AND?: ib_requestsScalarWhereWithAggregatesInput | ib_requestsScalarWhereWithAggregatesInput[]
    OR?: ib_requestsScalarWhereWithAggregatesInput[]
    NOT?: ib_requestsScalarWhereWithAggregatesInput | ib_requestsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_requests"> | number
    full_name?: StringWithAggregatesFilter<"ib_requests"> | string
    email?: StringWithAggregatesFilter<"ib_requests"> | string
    password_hash?: StringWithAggregatesFilter<"ib_requests"> | string
    status?: StringWithAggregatesFilter<"ib_requests"> | string
    ib_type?: StringWithAggregatesFilter<"ib_requests"> | string
    submitted_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
    approved_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
    usd_per_lot?: DecimalNullableWithAggregatesFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: DecimalNullableWithAggregatesFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    admin_comments?: StringNullableWithAggregatesFilter<"ib_requests"> | string | null
    group_id?: StringNullableWithAggregatesFilter<"ib_requests"> | string | null
    structure_id?: IntNullableWithAggregatesFilter<"ib_requests"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
  }

  export type manual_gatewayWhereInput = {
    AND?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    OR?: manual_gatewayWhereInput[]
    NOT?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    id?: IntFilter<"manual_gateway"> | number
    type?: StringFilter<"manual_gateway"> | string
    name?: StringFilter<"manual_gateway"> | string
    details?: StringFilter<"manual_gateway"> | string
    icon_url?: StringNullableFilter<"manual_gateway"> | string | null
    qr_code_url?: StringNullableFilter<"manual_gateway"> | string | null
    is_active?: BoolFilter<"manual_gateway"> | boolean
    created_at?: DateTimeFilter<"manual_gateway"> | Date | string
    updated_at?: DateTimeFilter<"manual_gateway"> | Date | string
  }

  export type manual_gatewayOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrderInput | SortOrder
    qr_code_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_gatewayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    OR?: manual_gatewayWhereInput[]
    NOT?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    type?: StringFilter<"manual_gateway"> | string
    name?: StringFilter<"manual_gateway"> | string
    details?: StringFilter<"manual_gateway"> | string
    icon_url?: StringNullableFilter<"manual_gateway"> | string | null
    qr_code_url?: StringNullableFilter<"manual_gateway"> | string | null
    is_active?: BoolFilter<"manual_gateway"> | boolean
    created_at?: DateTimeFilter<"manual_gateway"> | Date | string
    updated_at?: DateTimeFilter<"manual_gateway"> | Date | string
  }, "id">

  export type manual_gatewayOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrderInput | SortOrder
    qr_code_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: manual_gatewayCountOrderByAggregateInput
    _avg?: manual_gatewayAvgOrderByAggregateInput
    _max?: manual_gatewayMaxOrderByAggregateInput
    _min?: manual_gatewayMinOrderByAggregateInput
    _sum?: manual_gatewaySumOrderByAggregateInput
  }

  export type manual_gatewayScalarWhereWithAggregatesInput = {
    AND?: manual_gatewayScalarWhereWithAggregatesInput | manual_gatewayScalarWhereWithAggregatesInput[]
    OR?: manual_gatewayScalarWhereWithAggregatesInput[]
    NOT?: manual_gatewayScalarWhereWithAggregatesInput | manual_gatewayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"manual_gateway"> | number
    type?: StringWithAggregatesFilter<"manual_gateway"> | string
    name?: StringWithAggregatesFilter<"manual_gateway"> | string
    details?: StringWithAggregatesFilter<"manual_gateway"> | string
    icon_url?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    qr_code_url?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    is_active?: BoolWithAggregatesFilter<"manual_gateway"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"manual_gateway"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"manual_gateway"> | Date | string
  }

  export type mt5_groupsWhereInput = {
    AND?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    OR?: mt5_groupsWhereInput[]
    NOT?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    id?: IntFilter<"mt5_groups"> | number
    group_id?: StringFilter<"mt5_groups"> | string
    name?: StringFilter<"mt5_groups"> | string
    description?: StringNullableFilter<"mt5_groups"> | string | null
    synced_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    created_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
  }

  export type mt5_groupsOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type mt5_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    group_id?: string
    AND?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    OR?: mt5_groupsWhereInput[]
    NOT?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    name?: StringFilter<"mt5_groups"> | string
    description?: StringNullableFilter<"mt5_groups"> | string | null
    synced_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    created_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
  }, "id" | "group_id">

  export type mt5_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: mt5_groupsCountOrderByAggregateInput
    _avg?: mt5_groupsAvgOrderByAggregateInput
    _max?: mt5_groupsMaxOrderByAggregateInput
    _min?: mt5_groupsMinOrderByAggregateInput
    _sum?: mt5_groupsSumOrderByAggregateInput
  }

  export type mt5_groupsScalarWhereWithAggregatesInput = {
    AND?: mt5_groupsScalarWhereWithAggregatesInput | mt5_groupsScalarWhereWithAggregatesInput[]
    OR?: mt5_groupsScalarWhereWithAggregatesInput[]
    NOT?: mt5_groupsScalarWhereWithAggregatesInput | mt5_groupsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"mt5_groups"> | number
    group_id?: StringWithAggregatesFilter<"mt5_groups"> | string
    name?: StringWithAggregatesFilter<"mt5_groups"> | string
    description?: StringNullableWithAggregatesFilter<"mt5_groups"> | string | null
    synced_at?: DateTimeNullableWithAggregatesFilter<"mt5_groups"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"mt5_groups"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"mt5_groups"> | Date | string | null
  }

  export type payment_gatewayWhereInput = {
    AND?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    OR?: payment_gatewayWhereInput[]
    NOT?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    id?: IntFilter<"payment_gateway"> | number
    wallet_name?: StringFilter<"payment_gateway"> | string
    deposit_wallet_address?: StringFilter<"payment_gateway"> | string
    api_key?: StringFilter<"payment_gateway"> | string
    secret_key?: StringFilter<"payment_gateway"> | string
    gateway_type?: StringFilter<"payment_gateway"> | string
    is_active?: BoolFilter<"payment_gateway"> | boolean
    description?: StringNullableFilter<"payment_gateway"> | string | null
    created_at?: DateTimeFilter<"payment_gateway"> | Date | string
    updated_at?: DateTimeFilter<"payment_gateway"> | Date | string
  }

  export type payment_gatewayOrderByWithRelationInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    OR?: payment_gatewayWhereInput[]
    NOT?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    wallet_name?: StringFilter<"payment_gateway"> | string
    deposit_wallet_address?: StringFilter<"payment_gateway"> | string
    api_key?: StringFilter<"payment_gateway"> | string
    secret_key?: StringFilter<"payment_gateway"> | string
    gateway_type?: StringFilter<"payment_gateway"> | string
    is_active?: BoolFilter<"payment_gateway"> | boolean
    description?: StringNullableFilter<"payment_gateway"> | string | null
    created_at?: DateTimeFilter<"payment_gateway"> | Date | string
    updated_at?: DateTimeFilter<"payment_gateway"> | Date | string
  }, "id">

  export type payment_gatewayOrderByWithAggregationInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: payment_gatewayCountOrderByAggregateInput
    _avg?: payment_gatewayAvgOrderByAggregateInput
    _max?: payment_gatewayMaxOrderByAggregateInput
    _min?: payment_gatewayMinOrderByAggregateInput
    _sum?: payment_gatewaySumOrderByAggregateInput
  }

  export type payment_gatewayScalarWhereWithAggregatesInput = {
    AND?: payment_gatewayScalarWhereWithAggregatesInput | payment_gatewayScalarWhereWithAggregatesInput[]
    OR?: payment_gatewayScalarWhereWithAggregatesInput[]
    NOT?: payment_gatewayScalarWhereWithAggregatesInput | payment_gatewayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment_gateway"> | number
    wallet_name?: StringWithAggregatesFilter<"payment_gateway"> | string
    deposit_wallet_address?: StringWithAggregatesFilter<"payment_gateway"> | string
    api_key?: StringWithAggregatesFilter<"payment_gateway"> | string
    secret_key?: StringWithAggregatesFilter<"payment_gateway"> | string
    gateway_type?: StringWithAggregatesFilter<"payment_gateway"> | string
    is_active?: BoolWithAggregatesFilter<"payment_gateway"> | boolean
    description?: StringNullableWithAggregatesFilter<"payment_gateway"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"payment_gateway"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"payment_gateway"> | Date | string
  }

  export type symbolsWhereInput = {
    AND?: symbolsWhereInput | symbolsWhereInput[]
    OR?: symbolsWhereInput[]
    NOT?: symbolsWhereInput | symbolsWhereInput[]
    id?: IntFilter<"symbols"> | number
    symbol_name?: StringFilter<"symbols"> | string
    description?: StringNullableFilter<"symbols"> | string | null
    symbol_type?: StringNullableFilter<"symbols"> | string | null
    group_name?: StringNullableFilter<"symbols"> | string | null
    digits?: IntNullableFilter<"symbols"> | number | null
    spread?: FloatNullableFilter<"symbols"> | number | null
    contract_size?: IntNullableFilter<"symbols"> | number | null
    profit_mode?: StringNullableFilter<"symbols"> | string | null
    enable?: BoolNullableFilter<"symbols"> | boolean | null
    swap_mode?: StringNullableFilter<"symbols"> | string | null
    swap_long?: FloatNullableFilter<"symbols"> | number | null
    swap_short?: FloatNullableFilter<"symbols"> | number | null
    swap3_day?: StringNullableFilter<"symbols"> | string | null
    created_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
  }

  export type symbolsOrderByWithRelationInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrderInput | SortOrder
    symbol_type?: SortOrderInput | SortOrder
    group_name?: SortOrderInput | SortOrder
    digits?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    contract_size?: SortOrderInput | SortOrder
    profit_mode?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    swap_mode?: SortOrderInput | SortOrder
    swap_long?: SortOrderInput | SortOrder
    swap_short?: SortOrderInput | SortOrder
    swap3_day?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type symbolsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol_name?: string
    AND?: symbolsWhereInput | symbolsWhereInput[]
    OR?: symbolsWhereInput[]
    NOT?: symbolsWhereInput | symbolsWhereInput[]
    description?: StringNullableFilter<"symbols"> | string | null
    symbol_type?: StringNullableFilter<"symbols"> | string | null
    group_name?: StringNullableFilter<"symbols"> | string | null
    digits?: IntNullableFilter<"symbols"> | number | null
    spread?: FloatNullableFilter<"symbols"> | number | null
    contract_size?: IntNullableFilter<"symbols"> | number | null
    profit_mode?: StringNullableFilter<"symbols"> | string | null
    enable?: BoolNullableFilter<"symbols"> | boolean | null
    swap_mode?: StringNullableFilter<"symbols"> | string | null
    swap_long?: FloatNullableFilter<"symbols"> | number | null
    swap_short?: FloatNullableFilter<"symbols"> | number | null
    swap3_day?: StringNullableFilter<"symbols"> | string | null
    created_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
  }, "id" | "symbol_name">

  export type symbolsOrderByWithAggregationInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrderInput | SortOrder
    symbol_type?: SortOrderInput | SortOrder
    group_name?: SortOrderInput | SortOrder
    digits?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    contract_size?: SortOrderInput | SortOrder
    profit_mode?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    swap_mode?: SortOrderInput | SortOrder
    swap_long?: SortOrderInput | SortOrder
    swap_short?: SortOrderInput | SortOrder
    swap3_day?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: symbolsCountOrderByAggregateInput
    _avg?: symbolsAvgOrderByAggregateInput
    _max?: symbolsMaxOrderByAggregateInput
    _min?: symbolsMinOrderByAggregateInput
    _sum?: symbolsSumOrderByAggregateInput
  }

  export type symbolsScalarWhereWithAggregatesInput = {
    AND?: symbolsScalarWhereWithAggregatesInput | symbolsScalarWhereWithAggregatesInput[]
    OR?: symbolsScalarWhereWithAggregatesInput[]
    NOT?: symbolsScalarWhereWithAggregatesInput | symbolsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"symbols"> | number
    symbol_name?: StringWithAggregatesFilter<"symbols"> | string
    description?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    symbol_type?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    group_name?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    digits?: IntNullableWithAggregatesFilter<"symbols"> | number | null
    spread?: FloatNullableWithAggregatesFilter<"symbols"> | number | null
    contract_size?: IntNullableWithAggregatesFilter<"symbols"> | number | null
    profit_mode?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    enable?: BoolNullableWithAggregatesFilter<"symbols"> | boolean | null
    swap_mode?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    swap_long?: FloatNullableWithAggregatesFilter<"symbols"> | number | null
    swap_short?: FloatNullableWithAggregatesFilter<"symbols"> | number | null
    swap3_day?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"symbols"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"symbols"> | Date | string | null
  }

  export type ib_group_assignmentsWhereInput = {
    AND?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    OR?: ib_group_assignmentsWhereInput[]
    NOT?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    id?: IntFilter<"ib_group_assignments"> | number
    ib_request_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    group_id?: StringFilter<"ib_group_assignments"> | string
    group_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    ib_requests?: XOR<Ib_requestsNullableScalarRelationFilter, ib_requestsWhereInput> | null
  }

  export type ib_group_assignmentsOrderByWithRelationInput = {
    id?: SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    group_id?: SortOrder
    group_name?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    structure_name?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    ib_requests?: ib_requestsOrderByWithRelationInput
  }

  export type ib_group_assignmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    OR?: ib_group_assignmentsWhereInput[]
    NOT?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    ib_request_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    group_id?: StringFilter<"ib_group_assignments"> | string
    group_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    ib_requests?: XOR<Ib_requestsNullableScalarRelationFilter, ib_requestsWhereInput> | null
  }, "id">

  export type ib_group_assignmentsOrderByWithAggregationInput = {
    id?: SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    group_id?: SortOrder
    group_name?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    structure_name?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ib_group_assignmentsCountOrderByAggregateInput
    _avg?: ib_group_assignmentsAvgOrderByAggregateInput
    _max?: ib_group_assignmentsMaxOrderByAggregateInput
    _min?: ib_group_assignmentsMinOrderByAggregateInput
    _sum?: ib_group_assignmentsSumOrderByAggregateInput
  }

  export type ib_group_assignmentsScalarWhereWithAggregatesInput = {
    AND?: ib_group_assignmentsScalarWhereWithAggregatesInput | ib_group_assignmentsScalarWhereWithAggregatesInput[]
    OR?: ib_group_assignmentsScalarWhereWithAggregatesInput[]
    NOT?: ib_group_assignmentsScalarWhereWithAggregatesInput | ib_group_assignmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_group_assignments"> | number
    ib_request_id?: IntNullableWithAggregatesFilter<"ib_group_assignments"> | number | null
    group_id?: StringWithAggregatesFilter<"ib_group_assignments"> | string
    group_name?: StringNullableWithAggregatesFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableWithAggregatesFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableWithAggregatesFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalWithAggregatesFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalWithAggregatesFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_group_assignments"> | Date | string | null
  }

  export type ib_trade_historyWhereInput = {
    AND?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    OR?: ib_trade_historyWhereInput[]
    NOT?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    id?: StringFilter<"ib_trade_history"> | string
    order_id?: StringFilter<"ib_trade_history"> | string
    account_id?: StringFilter<"ib_trade_history"> | string
    user_id?: StringNullableFilter<"ib_trade_history"> | string | null
    ib_request_id?: IntNullableFilter<"ib_trade_history"> | number | null
    symbol?: StringFilter<"ib_trade_history"> | string
    order_type?: StringFilter<"ib_trade_history"> | string
    volume_lots?: DecimalFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string
    open_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    ib_commission?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    take_profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    stop_loss?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    synced_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    group_id?: StringNullableFilter<"ib_trade_history"> | string | null
  }

  export type ib_trade_historyOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrderInput | SortOrder
    close_price?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    ib_commission?: SortOrderInput | SortOrder
    take_profit?: SortOrderInput | SortOrder
    stop_loss?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
  }

  export type ib_trade_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    order_id?: string
    AND?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    OR?: ib_trade_historyWhereInput[]
    NOT?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    account_id?: StringFilter<"ib_trade_history"> | string
    user_id?: StringNullableFilter<"ib_trade_history"> | string | null
    ib_request_id?: IntNullableFilter<"ib_trade_history"> | number | null
    symbol?: StringFilter<"ib_trade_history"> | string
    order_type?: StringFilter<"ib_trade_history"> | string
    volume_lots?: DecimalFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string
    open_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    ib_commission?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    take_profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    stop_loss?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    synced_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    group_id?: StringNullableFilter<"ib_trade_history"> | string | null
  }, "id" | "order_id">

  export type ib_trade_historyOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrderInput | SortOrder
    close_price?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    ib_commission?: SortOrderInput | SortOrder
    take_profit?: SortOrderInput | SortOrder
    stop_loss?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
    _count?: ib_trade_historyCountOrderByAggregateInput
    _avg?: ib_trade_historyAvgOrderByAggregateInput
    _max?: ib_trade_historyMaxOrderByAggregateInput
    _min?: ib_trade_historyMinOrderByAggregateInput
    _sum?: ib_trade_historySumOrderByAggregateInput
  }

  export type ib_trade_historyScalarWhereWithAggregatesInput = {
    AND?: ib_trade_historyScalarWhereWithAggregatesInput | ib_trade_historyScalarWhereWithAggregatesInput[]
    OR?: ib_trade_historyScalarWhereWithAggregatesInput[]
    NOT?: ib_trade_historyScalarWhereWithAggregatesInput | ib_trade_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ib_trade_history"> | string
    order_id?: StringWithAggregatesFilter<"ib_trade_history"> | string
    account_id?: StringWithAggregatesFilter<"ib_trade_history"> | string
    user_id?: StringNullableWithAggregatesFilter<"ib_trade_history"> | string | null
    ib_request_id?: IntNullableWithAggregatesFilter<"ib_trade_history"> | number | null
    symbol?: StringWithAggregatesFilter<"ib_trade_history"> | string
    order_type?: StringWithAggregatesFilter<"ib_trade_history"> | string
    volume_lots?: DecimalWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string
    open_price?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    ib_commission?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    take_profit?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    stop_loss?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_trade_history"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_trade_history"> | Date | string | null
    synced_at?: DateTimeNullableWithAggregatesFilter<"ib_trade_history"> | Date | string | null
    group_id?: StringNullableWithAggregatesFilter<"ib_trade_history"> | string | null
  }

  export type support_ticketsWhereInput = {
    AND?: support_ticketsWhereInput | support_ticketsWhereInput[]
    OR?: support_ticketsWhereInput[]
    NOT?: support_ticketsWhereInput | support_ticketsWhereInput[]
    id?: IntFilter<"support_tickets"> | number
    ticket_no?: StringFilter<"support_tickets"> | string
    parent_id?: StringFilter<"support_tickets"> | string
    title?: StringFilter<"support_tickets"> | string
    description?: StringNullableFilter<"support_tickets"> | string | null
    ticket_type?: StringNullableFilter<"support_tickets"> | string | null
    status?: StringFilter<"support_tickets"> | string
    priority?: StringFilter<"support_tickets"> | string
    assigned_to?: StringNullableFilter<"support_tickets"> | string | null
    account_number?: StringNullableFilter<"support_tickets"> | string | null
    tags?: StringNullableListFilter<"support_tickets">
    created_at?: DateTimeFilter<"support_tickets"> | Date | string
    updated_at?: DateTimeFilter<"support_tickets"> | Date | string
    last_reply_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_by?: StringNullableFilter<"support_tickets"> | string | null
  }

  export type support_ticketsOrderByWithRelationInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    ticket_type?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    tags?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
  }

  export type support_ticketsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ticket_no?: string
    AND?: support_ticketsWhereInput | support_ticketsWhereInput[]
    OR?: support_ticketsWhereInput[]
    NOT?: support_ticketsWhereInput | support_ticketsWhereInput[]
    parent_id?: StringFilter<"support_tickets"> | string
    title?: StringFilter<"support_tickets"> | string
    description?: StringNullableFilter<"support_tickets"> | string | null
    ticket_type?: StringNullableFilter<"support_tickets"> | string | null
    status?: StringFilter<"support_tickets"> | string
    priority?: StringFilter<"support_tickets"> | string
    assigned_to?: StringNullableFilter<"support_tickets"> | string | null
    account_number?: StringNullableFilter<"support_tickets"> | string | null
    tags?: StringNullableListFilter<"support_tickets">
    created_at?: DateTimeFilter<"support_tickets"> | Date | string
    updated_at?: DateTimeFilter<"support_tickets"> | Date | string
    last_reply_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_by?: StringNullableFilter<"support_tickets"> | string | null
  }, "id" | "ticket_no">

  export type support_ticketsOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    ticket_type?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    tags?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
    _count?: support_ticketsCountOrderByAggregateInput
    _avg?: support_ticketsAvgOrderByAggregateInput
    _max?: support_ticketsMaxOrderByAggregateInput
    _min?: support_ticketsMinOrderByAggregateInput
    _sum?: support_ticketsSumOrderByAggregateInput
  }

  export type support_ticketsScalarWhereWithAggregatesInput = {
    AND?: support_ticketsScalarWhereWithAggregatesInput | support_ticketsScalarWhereWithAggregatesInput[]
    OR?: support_ticketsScalarWhereWithAggregatesInput[]
    NOT?: support_ticketsScalarWhereWithAggregatesInput | support_ticketsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_tickets"> | number
    ticket_no?: StringWithAggregatesFilter<"support_tickets"> | string
    parent_id?: StringWithAggregatesFilter<"support_tickets"> | string
    title?: StringWithAggregatesFilter<"support_tickets"> | string
    description?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    ticket_type?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    status?: StringWithAggregatesFilter<"support_tickets"> | string
    priority?: StringWithAggregatesFilter<"support_tickets"> | string
    assigned_to?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    account_number?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    tags?: StringNullableListFilter<"support_tickets">
    created_at?: DateTimeWithAggregatesFilter<"support_tickets"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_tickets"> | Date | string
    last_reply_at?: DateTimeNullableWithAggregatesFilter<"support_tickets"> | Date | string | null
    closed_at?: DateTimeNullableWithAggregatesFilter<"support_tickets"> | Date | string | null
    closed_by?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
  }

  export type support_ticket_repliesWhereInput = {
    AND?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    OR?: support_ticket_repliesWhereInput[]
    NOT?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    id?: IntFilter<"support_ticket_replies"> | number
    ticket_id?: IntFilter<"support_ticket_replies"> | number
    reply_id?: IntNullableFilter<"support_ticket_replies"> | number | null
    sender_id?: StringFilter<"support_ticket_replies"> | string
    sender_name?: StringFilter<"support_ticket_replies"> | string
    sender_type?: StringFilter<"support_ticket_replies"> | string
    content?: StringFilter<"support_ticket_replies"> | string
    is_internal?: BoolFilter<"support_ticket_replies"> | boolean
    attachments?: StringNullableListFilter<"support_ticket_replies">
    created_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    updated_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    is_read?: BoolFilter<"support_ticket_replies"> | boolean
  }

  export type support_ticket_repliesOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    OR?: support_ticket_repliesWhereInput[]
    NOT?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    ticket_id?: IntFilter<"support_ticket_replies"> | number
    reply_id?: IntNullableFilter<"support_ticket_replies"> | number | null
    sender_id?: StringFilter<"support_ticket_replies"> | string
    sender_name?: StringFilter<"support_ticket_replies"> | string
    sender_type?: StringFilter<"support_ticket_replies"> | string
    content?: StringFilter<"support_ticket_replies"> | string
    is_internal?: BoolFilter<"support_ticket_replies"> | boolean
    attachments?: StringNullableListFilter<"support_ticket_replies">
    created_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    updated_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    is_read?: BoolFilter<"support_ticket_replies"> | boolean
  }, "id">

  export type support_ticket_repliesOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
    _count?: support_ticket_repliesCountOrderByAggregateInput
    _avg?: support_ticket_repliesAvgOrderByAggregateInput
    _max?: support_ticket_repliesMaxOrderByAggregateInput
    _min?: support_ticket_repliesMinOrderByAggregateInput
    _sum?: support_ticket_repliesSumOrderByAggregateInput
  }

  export type support_ticket_repliesScalarWhereWithAggregatesInput = {
    AND?: support_ticket_repliesScalarWhereWithAggregatesInput | support_ticket_repliesScalarWhereWithAggregatesInput[]
    OR?: support_ticket_repliesScalarWhereWithAggregatesInput[]
    NOT?: support_ticket_repliesScalarWhereWithAggregatesInput | support_ticket_repliesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_ticket_replies"> | number
    ticket_id?: IntWithAggregatesFilter<"support_ticket_replies"> | number
    reply_id?: IntNullableWithAggregatesFilter<"support_ticket_replies"> | number | null
    sender_id?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    sender_name?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    sender_type?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    content?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    is_internal?: BoolWithAggregatesFilter<"support_ticket_replies"> | boolean
    attachments?: StringNullableListFilter<"support_ticket_replies">
    created_at?: DateTimeWithAggregatesFilter<"support_ticket_replies"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_ticket_replies"> | Date | string
    is_read?: BoolWithAggregatesFilter<"support_ticket_replies"> | boolean
  }

  export type support_articlesWhereInput = {
    AND?: support_articlesWhereInput | support_articlesWhereInput[]
    OR?: support_articlesWhereInput[]
    NOT?: support_articlesWhereInput | support_articlesWhereInput[]
    id?: IntFilter<"support_articles"> | number
    title?: StringFilter<"support_articles"> | string
    slug?: StringFilter<"support_articles"> | string
    content?: StringFilter<"support_articles"> | string
    excerpt?: StringNullableFilter<"support_articles"> | string | null
    category?: StringFilter<"support_articles"> | string
    tags?: StringNullableListFilter<"support_articles">
    views?: IntFilter<"support_articles"> | number
    helpful_count?: IntFilter<"support_articles"> | number
    not_helpful_count?: IntFilter<"support_articles"> | number
    is_published?: BoolFilter<"support_articles"> | boolean
    author_id?: StringFilter<"support_articles"> | string
    created_at?: DateTimeFilter<"support_articles"> | Date | string
    updated_at?: DateTimeFilter<"support_articles"> | Date | string
    published_at?: DateTimeNullableFilter<"support_articles"> | Date | string | null
  }

  export type support_articlesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrderInput | SortOrder
  }

  export type support_articlesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: support_articlesWhereInput | support_articlesWhereInput[]
    OR?: support_articlesWhereInput[]
    NOT?: support_articlesWhereInput | support_articlesWhereInput[]
    title?: StringFilter<"support_articles"> | string
    content?: StringFilter<"support_articles"> | string
    excerpt?: StringNullableFilter<"support_articles"> | string | null
    category?: StringFilter<"support_articles"> | string
    tags?: StringNullableListFilter<"support_articles">
    views?: IntFilter<"support_articles"> | number
    helpful_count?: IntFilter<"support_articles"> | number
    not_helpful_count?: IntFilter<"support_articles"> | number
    is_published?: BoolFilter<"support_articles"> | boolean
    author_id?: StringFilter<"support_articles"> | string
    created_at?: DateTimeFilter<"support_articles"> | Date | string
    updated_at?: DateTimeFilter<"support_articles"> | Date | string
    published_at?: DateTimeNullableFilter<"support_articles"> | Date | string | null
  }, "id" | "slug">

  export type support_articlesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrderInput | SortOrder
    _count?: support_articlesCountOrderByAggregateInput
    _avg?: support_articlesAvgOrderByAggregateInput
    _max?: support_articlesMaxOrderByAggregateInput
    _min?: support_articlesMinOrderByAggregateInput
    _sum?: support_articlesSumOrderByAggregateInput
  }

  export type support_articlesScalarWhereWithAggregatesInput = {
    AND?: support_articlesScalarWhereWithAggregatesInput | support_articlesScalarWhereWithAggregatesInput[]
    OR?: support_articlesScalarWhereWithAggregatesInput[]
    NOT?: support_articlesScalarWhereWithAggregatesInput | support_articlesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_articles"> | number
    title?: StringWithAggregatesFilter<"support_articles"> | string
    slug?: StringWithAggregatesFilter<"support_articles"> | string
    content?: StringWithAggregatesFilter<"support_articles"> | string
    excerpt?: StringNullableWithAggregatesFilter<"support_articles"> | string | null
    category?: StringWithAggregatesFilter<"support_articles"> | string
    tags?: StringNullableListFilter<"support_articles">
    views?: IntWithAggregatesFilter<"support_articles"> | number
    helpful_count?: IntWithAggregatesFilter<"support_articles"> | number
    not_helpful_count?: IntWithAggregatesFilter<"support_articles"> | number
    is_published?: BoolWithAggregatesFilter<"support_articles"> | boolean
    author_id?: StringWithAggregatesFilter<"support_articles"> | string
    created_at?: DateTimeWithAggregatesFilter<"support_articles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_articles"> | Date | string
    published_at?: DateTimeNullableWithAggregatesFilter<"support_articles"> | Date | string | null
  }

  export type support_faqWhereInput = {
    AND?: support_faqWhereInput | support_faqWhereInput[]
    OR?: support_faqWhereInput[]
    NOT?: support_faqWhereInput | support_faqWhereInput[]
    id?: IntFilter<"support_faq"> | number
    question?: StringFilter<"support_faq"> | string
    answer?: StringFilter<"support_faq"> | string
    category?: StringFilter<"support_faq"> | string
    tags?: StringNullableListFilter<"support_faq">
    helpful_count?: IntFilter<"support_faq"> | number
    not_helpful_count?: IntFilter<"support_faq"> | number
    display_order?: IntFilter<"support_faq"> | number
    is_active?: BoolFilter<"support_faq"> | boolean
    created_at?: DateTimeFilter<"support_faq"> | Date | string
    updated_at?: DateTimeFilter<"support_faq"> | Date | string
  }

  export type support_faqOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: support_faqWhereInput | support_faqWhereInput[]
    OR?: support_faqWhereInput[]
    NOT?: support_faqWhereInput | support_faqWhereInput[]
    question?: StringFilter<"support_faq"> | string
    answer?: StringFilter<"support_faq"> | string
    category?: StringFilter<"support_faq"> | string
    tags?: StringNullableListFilter<"support_faq">
    helpful_count?: IntFilter<"support_faq"> | number
    not_helpful_count?: IntFilter<"support_faq"> | number
    display_order?: IntFilter<"support_faq"> | number
    is_active?: BoolFilter<"support_faq"> | boolean
    created_at?: DateTimeFilter<"support_faq"> | Date | string
    updated_at?: DateTimeFilter<"support_faq"> | Date | string
  }, "id">

  export type support_faqOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: support_faqCountOrderByAggregateInput
    _avg?: support_faqAvgOrderByAggregateInput
    _max?: support_faqMaxOrderByAggregateInput
    _min?: support_faqMinOrderByAggregateInput
    _sum?: support_faqSumOrderByAggregateInput
  }

  export type support_faqScalarWhereWithAggregatesInput = {
    AND?: support_faqScalarWhereWithAggregatesInput | support_faqScalarWhereWithAggregatesInput[]
    OR?: support_faqScalarWhereWithAggregatesInput[]
    NOT?: support_faqScalarWhereWithAggregatesInput | support_faqScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_faq"> | number
    question?: StringWithAggregatesFilter<"support_faq"> | string
    answer?: StringWithAggregatesFilter<"support_faq"> | string
    category?: StringWithAggregatesFilter<"support_faq"> | string
    tags?: StringNullableListFilter<"support_faq">
    helpful_count?: IntWithAggregatesFilter<"support_faq"> | number
    not_helpful_count?: IntWithAggregatesFilter<"support_faq"> | number
    display_order?: IntWithAggregatesFilter<"support_faq"> | number
    is_active?: BoolWithAggregatesFilter<"support_faq"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"support_faq"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_faq"> | Date | string
  }

  export type support_categoriesWhereInput = {
    AND?: support_categoriesWhereInput | support_categoriesWhereInput[]
    OR?: support_categoriesWhereInput[]
    NOT?: support_categoriesWhereInput | support_categoriesWhereInput[]
    id?: IntFilter<"support_categories"> | number
    name?: StringFilter<"support_categories"> | string
    slug?: StringFilter<"support_categories"> | string
    description?: StringNullableFilter<"support_categories"> | string | null
    icon?: StringNullableFilter<"support_categories"> | string | null
    display_order?: IntFilter<"support_categories"> | number
    is_active?: BoolFilter<"support_categories"> | boolean
    created_at?: DateTimeFilter<"support_categories"> | Date | string
    updated_at?: DateTimeFilter<"support_categories"> | Date | string
  }

  export type support_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: support_categoriesWhereInput | support_categoriesWhereInput[]
    OR?: support_categoriesWhereInput[]
    NOT?: support_categoriesWhereInput | support_categoriesWhereInput[]
    description?: StringNullableFilter<"support_categories"> | string | null
    icon?: StringNullableFilter<"support_categories"> | string | null
    display_order?: IntFilter<"support_categories"> | number
    is_active?: BoolFilter<"support_categories"> | boolean
    created_at?: DateTimeFilter<"support_categories"> | Date | string
    updated_at?: DateTimeFilter<"support_categories"> | Date | string
  }, "id" | "name" | "slug">

  export type support_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: support_categoriesCountOrderByAggregateInput
    _avg?: support_categoriesAvgOrderByAggregateInput
    _max?: support_categoriesMaxOrderByAggregateInput
    _min?: support_categoriesMinOrderByAggregateInput
    _sum?: support_categoriesSumOrderByAggregateInput
  }

  export type support_categoriesScalarWhereWithAggregatesInput = {
    AND?: support_categoriesScalarWhereWithAggregatesInput | support_categoriesScalarWhereWithAggregatesInput[]
    OR?: support_categoriesScalarWhereWithAggregatesInput[]
    NOT?: support_categoriesScalarWhereWithAggregatesInput | support_categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_categories"> | number
    name?: StringWithAggregatesFilter<"support_categories"> | string
    slug?: StringWithAggregatesFilter<"support_categories"> | string
    description?: StringNullableWithAggregatesFilter<"support_categories"> | string | null
    icon?: StringNullableWithAggregatesFilter<"support_categories"> | string | null
    display_order?: IntWithAggregatesFilter<"support_categories"> | number
    is_active?: BoolWithAggregatesFilter<"support_categories"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"support_categories"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_categories"> | Date | string
  }

  export type support_repliesWhereInput = {
    AND?: support_repliesWhereInput | support_repliesWhereInput[]
    OR?: support_repliesWhereInput[]
    NOT?: support_repliesWhereInput | support_repliesWhereInput[]
    id?: IntFilter<"support_replies"> | number
    ticket_id?: IntFilter<"support_replies"> | number
    sender_id?: StringFilter<"support_replies"> | string
    sender_name?: StringFilter<"support_replies"> | string
    sender_type?: StringFilter<"support_replies"> | string
    content?: StringFilter<"support_replies"> | string
    is_internal?: BoolFilter<"support_replies"> | boolean
    created_at?: DateTimeFilter<"support_replies"> | Date | string
  }

  export type support_repliesOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: support_repliesWhereInput | support_repliesWhereInput[]
    OR?: support_repliesWhereInput[]
    NOT?: support_repliesWhereInput | support_repliesWhereInput[]
    ticket_id?: IntFilter<"support_replies"> | number
    sender_id?: StringFilter<"support_replies"> | string
    sender_name?: StringFilter<"support_replies"> | string
    sender_type?: StringFilter<"support_replies"> | string
    content?: StringFilter<"support_replies"> | string
    is_internal?: BoolFilter<"support_replies"> | boolean
    created_at?: DateTimeFilter<"support_replies"> | Date | string
  }, "id">

  export type support_repliesOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    _count?: support_repliesCountOrderByAggregateInput
    _avg?: support_repliesAvgOrderByAggregateInput
    _max?: support_repliesMaxOrderByAggregateInput
    _min?: support_repliesMinOrderByAggregateInput
    _sum?: support_repliesSumOrderByAggregateInput
  }

  export type support_repliesScalarWhereWithAggregatesInput = {
    AND?: support_repliesScalarWhereWithAggregatesInput | support_repliesScalarWhereWithAggregatesInput[]
    OR?: support_repliesScalarWhereWithAggregatesInput[]
    NOT?: support_repliesScalarWhereWithAggregatesInput | support_repliesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_replies"> | number
    ticket_id?: IntWithAggregatesFilter<"support_replies"> | number
    sender_id?: StringWithAggregatesFilter<"support_replies"> | string
    sender_name?: StringWithAggregatesFilter<"support_replies"> | string
    sender_type?: StringWithAggregatesFilter<"support_replies"> | string
    content?: StringWithAggregatesFilter<"support_replies"> | string
    is_internal?: BoolWithAggregatesFilter<"support_replies"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"support_replies"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type KYCCreateInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycInput
  }

  export type KYCUncheckedCreateInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type KYCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycNestedInput
  }

  export type KYCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type KYCCreateManyInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type KYCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MT5AccountCreateInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountCreateManyInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
  }

  export type MT5AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MT5AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MT5TransactionCreateInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
    mt5Account: MT5AccountCreateNestedOneWithoutMt5TransactionsInput
  }

  export type MT5TransactionUncheckedCreateInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    mt5AccountId: string
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Account?: MT5AccountUpdateOneRequiredWithoutMt5TransactionsNestedInput
  }

  export type MT5TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionCreateManyInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    mt5AccountId: string
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deposit?: DepositCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deposit?: DepositUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositCreateInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutDepositsInput
    user: UserCreateNestedOneWithoutDepositsInput
    transactions?: TransactionCreateNestedManyWithoutDepositInput
  }

  export type DepositUncheckedCreateInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutDepositInput
  }

  export type DepositUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutDepositsNestedInput
    user?: UserUpdateOneRequiredWithoutDepositsNestedInput
    transactions?: TransactionUpdateManyWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutDepositNestedInput
  }

  export type DepositCreateManyInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalCreateInput = {
    id?: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    transactions?: TransactionCreateNestedManyWithoutWithdrawalInput
    mt5Account: MT5AccountCreateNestedOneWithoutWithdrawalsInput
    user: UserCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutWithdrawalInput
  }

  export type WithdrawalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUpdateManyWithoutWithdrawalNestedInput
    mt5Account?: MT5AccountUpdateOneRequiredWithoutWithdrawalsNestedInput
    user?: UserUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutWithdrawalNestedInput
  }

  export type WithdrawalCreateManyInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
  }

  export type WithdrawalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WithdrawalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    adminId: string
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    userId?: string | null
    adminId: string
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    permissions: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    permissions: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    permissions: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    userId: string
    address: string
    currency?: string
    network?: string
    status?: string
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    userId: string
    address: string
    currency?: string
    network?: string
    status?: string
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    userId: string
    address: string
    currency?: string
    network?: string
    status?: string
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy: string
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy: string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy: string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultMT5AccountCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    MT5Account: MT5AccountCreateNestedOneWithoutDefaultMT5AccountInput
    User: UserCreateNestedOneWithoutDefaultMT5AccountInput
  }

  export type DefaultMT5AccountUncheckedCreateInput = {
    id: string
    userId: string
    mt5AccountId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DefaultMT5AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MT5Account?: MT5AccountUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
    User?: UserUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
  }

  export type DefaultMT5AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultMT5AccountCreateManyInput = {
    id: string
    userId: string
    mt5AccountId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DefaultMT5AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultMT5AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstrumentCreateInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    UserFavorite?: UserFavoriteCreateNestedManyWithoutInstrumentInput
  }

  export type InstrumentUncheckedCreateInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type InstrumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserFavorite?: UserFavoriteUpdateManyWithoutInstrumentNestedInput
  }

  export type InstrumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type InstrumentCreateManyInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type InstrumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstrumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
    User: UserCreateNestedOneWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    User?: UserUpdateOneRequiredWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RefreshTokenCreateManyInput = {
    id: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserFavoriteCreateInput = {
    id: string
    sortOrder?: number
    addedAt?: Date | string
    Instrument: InstrumentCreateNestedOneWithoutUserFavoriteInput
    User: UserCreateNestedOneWithoutUserFavoriteInput
  }

  export type UserFavoriteUncheckedCreateInput = {
    id: string
    userId: string
    instrumentId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instrument?: InstrumentUpdateOneRequiredWithoutUserFavoriteNestedInput
    User?: UserUpdateOneRequiredWithoutUserFavoriteNestedInput
  }

  export type UserFavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInput = {
    id: string
    userId: string
    instrumentId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminCreateInput = {
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logCreateNestedManyWithoutAdminInput
    balance_operation_history?: balance_operation_historyCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logUncheckedCreateNestedManyWithoutAdminInput
    balance_operation_history?: balance_operation_historyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUpdateManyWithoutAdminNestedInput
    balance_operation_history?: balance_operation_historyUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUncheckedUpdateManyWithoutAdminNestedInput
    balance_operation_history?: balance_operation_historyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateManyInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type adminUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type admin_login_logCreateInput = {
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
    admin: adminCreateNestedOneWithoutAdmin_login_logInput
  }

  export type admin_login_logUncheckedCreateInput = {
    id?: number
    admin_id: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUpdateInput = {
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutAdmin_login_logNestedInput
  }

  export type admin_login_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logCreateManyInput = {
    id?: number
    admin_id: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUpdateManyMutationInput = {
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyCreateInput = {
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    admin: adminCreateNestedOneWithoutBalance_operation_historyInput
  }

  export type balance_operation_historyUncheckedCreateInput = {
    id?: number
    admin_id: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyUpdateInput = {
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutBalance_operation_historyNestedInput
  }

  export type balance_operation_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyCreateManyInput = {
    id?: number
    admin_id: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyUpdateManyMutationInput = {
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_conversationsCreateInput = {
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesCreateNestedManyWithoutChat_conversationsInput
    chat_participants?: chat_participantsCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUncheckedCreateInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutChat_conversationsInput
    chat_participants?: chat_participantsUncheckedCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUpdateManyWithoutChat_conversationsNestedInput
    chat_participants?: chat_participantsUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutChat_conversationsNestedInput
    chat_participants?: chat_participantsUncheckedUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsCreateManyInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
  }

  export type chat_conversationsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chat_conversationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chat_messagesCreateInput = {
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    chat_conversations?: chat_conversationsCreateNestedOneWithoutChat_messagesInput
  }

  export type chat_messagesUncheckedCreateInput = {
    id?: number
    conversation_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesUpdateInput = {
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chat_conversations?: chat_conversationsUpdateOneWithoutChat_messagesNestedInput
  }

  export type chat_messagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesCreateManyInput = {
    id?: number
    conversation_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesUpdateManyMutationInput = {
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_participantsCreateInput = {
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
    chat_conversations?: chat_conversationsCreateNestedOneWithoutChat_participantsInput
  }

  export type chat_participantsUncheckedCreateInput = {
    id?: number
    conversation_id?: number | null
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_conversations?: chat_conversationsUpdateOneWithoutChat_participantsNestedInput
  }

  export type chat_participantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsCreateManyInput = {
    id?: number
    conversation_id?: number | null
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_commission_structuresCreateInput = {
    group_id: string
    structure_name: string
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type group_commission_structuresUncheckedCreateInput = {
    id?: number
    group_id: string
    structure_name: string
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type group_commission_structuresUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_commission_structuresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_commission_structuresCreateManyInput = {
    id?: number
    group_id: string
    structure_name: string
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type group_commission_structuresUpdateManyMutationInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_commission_structuresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_adminCreateInput = {
    email: string
    password_hash: string
    role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_adminUncheckedCreateInput = {
    id?: number
    email: string
    password_hash: string
    role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_adminUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_adminCreateManyInput = {
    id?: number
    email: string
    password_hash: string
    role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_adminUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_requestsCreateInput = {
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    ib_group_assignments?: ib_group_assignmentsCreateNestedManyWithoutIb_requestsInput
  }

  export type ib_requestsUncheckedCreateInput = {
    id?: number
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    ib_group_assignments?: ib_group_assignmentsUncheckedCreateNestedManyWithoutIb_requestsInput
  }

  export type ib_requestsUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ib_group_assignments?: ib_group_assignmentsUpdateManyWithoutIb_requestsNestedInput
  }

  export type ib_requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ib_group_assignments?: ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsNestedInput
  }

  export type ib_requestsCreateManyInput = {
    id?: number
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_requestsUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_gatewayCreateInput = {
    type: string
    name: string
    details: string
    icon_url?: string | null
    qr_code_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type manual_gatewayUncheckedCreateInput = {
    id?: number
    type: string
    name: string
    details: string
    icon_url?: string | null
    qr_code_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type manual_gatewayUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manual_gatewayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manual_gatewayCreateManyInput = {
    id?: number
    type: string
    name: string
    details: string
    icon_url?: string | null
    qr_code_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type manual_gatewayUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manual_gatewayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mt5_groupsCreateInput = {
    group_id: string
    name: string
    description?: string | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mt5_groupsUncheckedCreateInput = {
    id?: number
    group_id: string
    name: string
    description?: string | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mt5_groupsUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mt5_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mt5_groupsCreateManyInput = {
    id?: number
    group_id: string
    name: string
    description?: string | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mt5_groupsUpdateManyMutationInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mt5_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_gatewayCreateInput = {
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type payment_gatewayUncheckedCreateInput = {
    id?: number
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type payment_gatewayUpdateInput = {
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_gatewayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_gatewayCreateManyInput = {
    id?: number
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type payment_gatewayUpdateManyMutationInput = {
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_gatewayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type symbolsCreateInput = {
    symbol_name: string
    description?: string | null
    symbol_type?: string | null
    group_name?: string | null
    digits?: number | null
    spread?: number | null
    contract_size?: number | null
    profit_mode?: string | null
    enable?: boolean | null
    swap_mode?: string | null
    swap_long?: number | null
    swap_short?: number | null
    swap3_day?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbolsUncheckedCreateInput = {
    id?: number
    symbol_name: string
    description?: string | null
    symbol_type?: string | null
    group_name?: string | null
    digits?: number | null
    spread?: number | null
    contract_size?: number | null
    profit_mode?: string | null
    enable?: boolean | null
    swap_mode?: string | null
    swap_long?: number | null
    swap_short?: number | null
    swap3_day?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbolsUpdateInput = {
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbolsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbolsCreateManyInput = {
    id?: number
    symbol_name: string
    description?: string | null
    symbol_type?: string | null
    group_name?: string | null
    digits?: number | null
    spread?: number | null
    contract_size?: number | null
    profit_mode?: string | null
    enable?: boolean | null
    swap_mode?: string | null
    swap_long?: number | null
    swap_short?: number | null
    swap3_day?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbolsUpdateManyMutationInput = {
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbolsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsCreateInput = {
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    ib_requests?: ib_requestsCreateNestedOneWithoutIb_group_assignmentsInput
  }

  export type ib_group_assignmentsUncheckedCreateInput = {
    id?: number
    ib_request_id?: number | null
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ib_requests?: ib_requestsUpdateOneWithoutIb_group_assignmentsNestedInput
  }

  export type ib_group_assignmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsCreateManyInput = {
    id?: number
    ib_request_id?: number | null
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUpdateManyMutationInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_trade_historyCreateInput = {
    id: string
    order_id: string
    account_id: string
    user_id?: string | null
    ib_request_id?: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal | DecimalJsLike | number | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    close_price?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    ib_commission?: Decimal | DecimalJsLike | number | string | null
    take_profit?: Decimal | DecimalJsLike | number | string | null
    stop_loss?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    synced_at?: Date | string | null
    group_id?: string | null
  }

  export type ib_trade_historyUncheckedCreateInput = {
    id: string
    order_id: string
    account_id: string
    user_id?: string | null
    ib_request_id?: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal | DecimalJsLike | number | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    close_price?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    ib_commission?: Decimal | DecimalJsLike | number | string | null
    take_profit?: Decimal | DecimalJsLike | number | string | null
    stop_loss?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    synced_at?: Date | string | null
    group_id?: string | null
  }

  export type ib_trade_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_trade_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_trade_historyCreateManyInput = {
    id: string
    order_id: string
    account_id: string
    user_id?: string | null
    ib_request_id?: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal | DecimalJsLike | number | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    close_price?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    ib_commission?: Decimal | DecimalJsLike | number | string | null
    take_profit?: Decimal | DecimalJsLike | number | string | null
    stop_loss?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    synced_at?: Date | string | null
    group_id?: string | null
  }

  export type ib_trade_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_trade_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsCreateInput = {
    ticket_no: string
    parent_id: string
    title: string
    description?: string | null
    ticket_type?: string | null
    status?: string
    priority?: string
    assigned_to?: string | null
    account_number?: string | null
    tags?: support_ticketsCreatetagsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    last_reply_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
  }

  export type support_ticketsUncheckedCreateInput = {
    id?: number
    ticket_no: string
    parent_id: string
    title: string
    description?: string | null
    ticket_type?: string | null
    status?: string
    priority?: string
    assigned_to?: string | null
    account_number?: string | null
    tags?: support_ticketsCreatetagsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    last_reply_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
  }

  export type support_ticketsUpdateInput = {
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsCreateManyInput = {
    id?: number
    ticket_no: string
    parent_id: string
    title: string
    description?: string | null
    ticket_type?: string | null
    status?: string
    priority?: string
    assigned_to?: string | null
    account_number?: string | null
    tags?: support_ticketsCreatetagsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    last_reply_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
  }

  export type support_ticketsUpdateManyMutationInput = {
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticket_repliesCreateInput = {
    ticket_id: number
    reply_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    attachments?: support_ticket_repliesCreateattachmentsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
  }

  export type support_ticket_repliesUncheckedCreateInput = {
    id?: number
    ticket_id: number
    reply_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    attachments?: support_ticket_repliesCreateattachmentsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
  }

  export type support_ticket_repliesUpdateInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_ticket_repliesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_ticket_repliesCreateManyInput = {
    id?: number
    ticket_id: number
    reply_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    attachments?: support_ticket_repliesCreateattachmentsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
  }

  export type support_ticket_repliesUpdateManyMutationInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_ticket_repliesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_articlesCreateInput = {
    title: string
    slug: string
    content: string
    excerpt?: string | null
    category: string
    tags?: support_articlesCreatetagsInput | string[]
    views?: number
    helpful_count?: number
    not_helpful_count?: number
    is_published?: boolean
    author_id: string
    created_at?: Date | string
    updated_at?: Date | string
    published_at?: Date | string | null
  }

  export type support_articlesUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    content: string
    excerpt?: string | null
    category: string
    tags?: support_articlesCreatetagsInput | string[]
    views?: number
    helpful_count?: number
    not_helpful_count?: number
    is_published?: boolean
    author_id: string
    created_at?: Date | string
    updated_at?: Date | string
    published_at?: Date | string | null
  }

  export type support_articlesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_articlesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_articlesCreateManyInput = {
    id?: number
    title: string
    slug: string
    content: string
    excerpt?: string | null
    category: string
    tags?: support_articlesCreatetagsInput | string[]
    views?: number
    helpful_count?: number
    not_helpful_count?: number
    is_published?: boolean
    author_id: string
    created_at?: Date | string
    updated_at?: Date | string
    published_at?: Date | string | null
  }

  export type support_articlesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_articlesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_faqCreateInput = {
    question: string
    answer: string
    category: string
    tags?: support_faqCreatetagsInput | string[]
    helpful_count?: number
    not_helpful_count?: number
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_faqUncheckedCreateInput = {
    id?: number
    question: string
    answer: string
    category: string
    tags?: support_faqCreatetagsInput | string[]
    helpful_count?: number
    not_helpful_count?: number
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_faqUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_faqUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_faqCreateManyInput = {
    id?: number
    question: string
    answer: string
    category: string
    tags?: support_faqCreatetagsInput | string[]
    helpful_count?: number
    not_helpful_count?: number
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_faqUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_faqUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesCreateInput = {
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_categoriesUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_categoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesCreateManyInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_categoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesCreateInput = {
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    created_at?: Date | string
  }

  export type support_repliesUncheckedCreateInput = {
    id?: number
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    created_at?: Date | string
  }

  export type support_repliesUpdateInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesCreateManyInput = {
    id?: number
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    created_at?: Date | string
  }

  export type support_repliesUpdateManyMutationInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type DefaultMT5AccountNullableScalarRelationFilter = {
    is?: DefaultMT5AccountWhereInput | null
    isNot?: DefaultMT5AccountWhereInput | null
  }

  export type DepositListRelationFilter = {
    every?: DepositWhereInput
    some?: DepositWhereInput
    none?: DepositWhereInput
  }

  export type KYCNullableScalarRelationFilter = {
    is?: KYCWhereInput | null
    isNot?: KYCWhereInput | null
  }

  export type MT5AccountListRelationFilter = {
    every?: MT5AccountWhereInput
    some?: MT5AccountWhereInput
    none?: MT5AccountWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserFavoriteListRelationFilter = {
    every?: UserFavoriteWhereInput
    some?: UserFavoriteWhereInput
    none?: UserFavoriteWhereInput
  }

  export type WithdrawalListRelationFilter = {
    every?: WithdrawalWhereInput
    some?: WithdrawalWhereInput
    none?: WithdrawalWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepositOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MT5AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WithdrawalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type KYCCountOrderByAggregateInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrder
    addressReference?: SortOrder
    amlReference?: SortOrder
    documentSubmittedAt?: SortOrder
    addressSubmittedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type KYCMaxOrderByAggregateInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrder
    addressReference?: SortOrder
    amlReference?: SortOrder
    documentSubmittedAt?: SortOrder
    addressSubmittedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type KYCMinOrderByAggregateInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrder
    addressReference?: SortOrder
    amlReference?: SortOrder
    documentSubmittedAt?: SortOrder
    addressSubmittedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DefaultMT5AccountListRelationFilter = {
    every?: DefaultMT5AccountWhereInput
    some?: DefaultMT5AccountWhereInput
    none?: DefaultMT5AccountWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MT5TransactionListRelationFilter = {
    every?: MT5TransactionWhereInput
    some?: MT5TransactionWhereInput
    none?: MT5TransactionWhereInput
  }

  export type DefaultMT5AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MT5TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MT5AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    leverage?: SortOrder
  }

  export type MT5AccountAvgOrderByAggregateInput = {
    leverage?: SortOrder
  }

  export type MT5AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    leverage?: SortOrder
  }

  export type MT5AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    leverage?: SortOrder
  }

  export type MT5AccountSumOrderByAggregateInput = {
    leverage?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MT5AccountScalarRelationFilter = {
    is?: MT5AccountWhereInput
    isNot?: MT5AccountWhereInput
  }

  export type MT5TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    comment?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    userId?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type MT5TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    comment?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    userId?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    comment?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    userId?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type DepositNullableScalarRelationFilter = {
    is?: DepositWhereInput | null
    isNot?: DepositWhereInput | null
  }

  export type WithdrawalNullableScalarRelationFilter = {
    is?: WithdrawalWhereInput | null
    isNot?: WithdrawalWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DepositCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrder
    transactionHash?: SortOrder
    proofFileUrl?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    depositAddress?: SortOrder
    externalTransactionId?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DepositMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrder
    transactionHash?: SortOrder
    proofFileUrl?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    depositAddress?: SortOrder
    externalTransactionId?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrder
    transactionHash?: SortOrder
    proofFileUrl?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    depositAddress?: SortOrder
    externalTransactionId?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WithdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    walletAddress?: SortOrder
  }

  export type WithdrawalAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WithdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    walletAddress?: SortOrder
  }

  export type WithdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    walletAddress?: SortOrder
  }

  export type WithdrawalSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type DefaultMT5AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultMT5AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultMT5AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InstrumentCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    group?: SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstrumentAvgOrderByAggregateInput = {
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
  }

  export type InstrumentMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    group?: SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstrumentMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    group?: SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstrumentSumOrderByAggregateInput = {
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type InstrumentScalarRelationFilter = {
    is?: InstrumentWhereInput
    isNot?: InstrumentWhereInput
  }

  export type UserFavoriteUserIdInstrumentIdCompoundUniqueInput = {
    userId: string
    instrumentId: string
  }

  export type UserFavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserFavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type Admin_login_logListRelationFilter = {
    every?: admin_login_logWhereInput
    some?: admin_login_logWhereInput
    none?: admin_login_logWhereInput
  }

  export type Balance_operation_historyListRelationFilter = {
    every?: balance_operation_historyWhereInput
    some?: balance_operation_historyWhereInput
    none?: balance_operation_historyWhereInput
  }

  export type admin_login_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type balance_operation_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type AdminScalarRelationFilter = {
    is?: adminWhereInput
    isNot?: adminWhereInput
  }

  export type admin_login_logCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    location?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    created_at?: SortOrder
  }

  export type admin_login_logAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
  }

  export type admin_login_logMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    location?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    created_at?: SortOrder
  }

  export type admin_login_logMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    location?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    created_at?: SortOrder
  }

  export type admin_login_logSumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
  }

  export type balance_operation_historyCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
  }

  export type balance_operation_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    amount?: SortOrder
  }

  export type balance_operation_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
  }

  export type balance_operation_historyMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
  }

  export type balance_operation_historySumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    amount?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Chat_messagesListRelationFilter = {
    every?: chat_messagesWhereInput
    some?: chat_messagesWhereInput
    none?: chat_messagesWhereInput
  }

  export type Chat_participantsListRelationFilter = {
    every?: chat_participantsWhereInput
    some?: chat_participantsWhereInput
    none?: chat_participantsWhereInput
  }

  export type chat_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chat_participantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chat_conversationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
    tags?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsAvgOrderByAggregateInput = {
    id?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsSumOrderByAggregateInput = {
    id?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Chat_conversationsNullableScalarRelationFilter = {
    is?: chat_conversationsWhereInput | null
    isNot?: chat_conversationsWhereInput | null
  }

  export type chat_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chat_messagesAvgOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type chat_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chat_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chat_messagesSumOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type chat_participantsConversation_idUser_idCompoundUniqueInput = {
    conversation_id: number
    user_id: string
  }

  export type chat_participantsCountOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrder
    joined_at?: SortOrder
    left_at?: SortOrder
    is_active?: SortOrder
  }

  export type chat_participantsAvgOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type chat_participantsMaxOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrder
    joined_at?: SortOrder
    left_at?: SortOrder
    is_active?: SortOrder
  }

  export type chat_participantsMinOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrder
    joined_at?: SortOrder
    left_at?: SortOrder
    is_active?: SortOrder
  }

  export type chat_participantsSumOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type group_commission_structuresGroup_idStructure_nameCompoundUniqueInput = {
    group_id: string
    structure_name: string
  }

  export type group_commission_structuresCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type group_commission_structuresAvgOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
  }

  export type group_commission_structuresMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type group_commission_structuresMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type group_commission_structuresSumOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ib_adminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_adminAvgOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type ib_adminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_adminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_adminSumOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Ib_group_assignmentsListRelationFilter = {
    every?: ib_group_assignmentsWhereInput
    some?: ib_group_assignmentsWhereInput
    none?: ib_group_assignmentsWhereInput
  }

  export type ib_group_assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ib_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrder
    approved_at?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    admin_comments?: SortOrder
    group_id?: SortOrder
    structure_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    structure_id?: SortOrder
  }

  export type ib_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrder
    approved_at?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    admin_comments?: SortOrder
    group_id?: SortOrder
    structure_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrder
    approved_at?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    admin_comments?: SortOrder
    group_id?: SortOrder
    structure_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_requestsSumOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    structure_id?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type manual_gatewayCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrder
    qr_code_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_gatewayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type manual_gatewayMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrder
    qr_code_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_gatewayMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrder
    qr_code_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_gatewaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type mt5_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mt5_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type mt5_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mt5_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mt5_groupsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type payment_gatewayCountOrderByAggregateInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type payment_gatewayMaxOrderByAggregateInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewayMinOrderByAggregateInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type symbolsCountOrderByAggregateInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrder
    symbol_type?: SortOrder
    group_name?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    profit_mode?: SortOrder
    enable?: SortOrder
    swap_mode?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
    swap3_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbolsAvgOrderByAggregateInput = {
    id?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
  }

  export type symbolsMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrder
    symbol_type?: SortOrder
    group_name?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    profit_mode?: SortOrder
    enable?: SortOrder
    swap_mode?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
    swap3_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbolsMinOrderByAggregateInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrder
    symbol_type?: SortOrder
    group_name?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    profit_mode?: SortOrder
    enable?: SortOrder
    swap_mode?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
    swap3_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbolsSumOrderByAggregateInput = {
    id?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Ib_requestsNullableScalarRelationFilter = {
    is?: ib_requestsWhereInput | null
    isNot?: ib_requestsWhereInput | null
  }

  export type ib_group_assignmentsCountOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    group_id?: SortOrder
    group_name?: SortOrder
    structure_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_group_assignmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    structure_id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
  }

  export type ib_group_assignmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    group_id?: SortOrder
    group_name?: SortOrder
    structure_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_group_assignmentsMinOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    group_id?: SortOrder
    group_name?: SortOrder
    structure_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_group_assignmentsSumOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    structure_id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
  }

  export type ib_trade_historyCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    ib_request_id?: SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    synced_at?: SortOrder
    group_id?: SortOrder
  }

  export type ib_trade_historyAvgOrderByAggregateInput = {
    ib_request_id?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
  }

  export type ib_trade_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    ib_request_id?: SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    synced_at?: SortOrder
    group_id?: SortOrder
  }

  export type ib_trade_historyMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    ib_request_id?: SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    synced_at?: SortOrder
    group_id?: SortOrder
  }

  export type ib_trade_historySumOrderByAggregateInput = {
    ib_request_id?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
  }

  export type support_ticketsCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ticket_type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    account_number?: SortOrder
    tags?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
  }

  export type support_ticketsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type support_ticketsMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ticket_type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    account_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
  }

  export type support_ticketsMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ticket_type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    account_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
  }

  export type support_ticketsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type support_ticket_repliesCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
  }

  export type support_ticket_repliesMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesSumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
  }

  export type support_articlesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrder
  }

  export type support_articlesAvgOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
  }

  export type support_articlesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    category?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrder
  }

  export type support_articlesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    category?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrder
  }

  export type support_articlesSumOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
  }

  export type support_faqCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqAvgOrderByAggregateInput = {
    id?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
  }

  export type support_faqMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqSumOrderByAggregateInput = {
    id?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
  }

  export type support_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    display_order?: SortOrder
  }

  export type support_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    display_order?: SortOrder
  }

  export type support_repliesCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
  }

  export type support_repliesMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesSumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type DefaultMT5AccountCreateNestedOneWithoutUserInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    connect?: DefaultMT5AccountWhereUniqueInput
  }

  export type DepositCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type KYCCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    connect?: KYCWhereUniqueInput
  }

  export type MT5AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type WithdrawalCreateNestedManyWithoutUserInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    connect?: DefaultMT5AccountWhereUniqueInput
  }

  export type DepositUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type KYCUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    connect?: KYCWhereUniqueInput
  }

  export type MT5AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAdminInput | ActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAdminInput | ActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAdminInput | ActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type DefaultMT5AccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    upsert?: DefaultMT5AccountUpsertWithoutUserInput
    disconnect?: DefaultMT5AccountWhereInput | boolean
    delete?: DefaultMT5AccountWhereInput | boolean
    connect?: DefaultMT5AccountWhereUniqueInput
    update?: XOR<XOR<DefaultMT5AccountUpdateToOneWithWhereWithoutUserInput, DefaultMT5AccountUpdateWithoutUserInput>, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type DepositUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutUserInput | DepositUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutUserInput | DepositUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutUserInput | DepositUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type KYCUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    upsert?: KYCUpsertWithoutUserInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutUserInput, KYCUpdateWithoutUserInput>, KYCUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountUpsertWithWhereUniqueWithoutUserInput | MT5AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    set?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    disconnect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    delete?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    update?: MT5AccountUpdateWithWhereUniqueWithoutUserInput | MT5AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountUpdateManyWithWhereWithoutUserInput | MT5AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type WithdrawalUpdateManyWithoutUserNestedInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutUserInput | WithdrawalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutUserInput | WithdrawalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutUserInput | WithdrawalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAdminInput | ActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAdminInput | ActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAdminInput | ActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    upsert?: DefaultMT5AccountUpsertWithoutUserInput
    disconnect?: DefaultMT5AccountWhereInput | boolean
    delete?: DefaultMT5AccountWhereInput | boolean
    connect?: DefaultMT5AccountWhereUniqueInput
    update?: XOR<XOR<DefaultMT5AccountUpdateToOneWithWhereWithoutUserInput, DefaultMT5AccountUpdateWithoutUserInput>, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type DepositUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutUserInput | DepositUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutUserInput | DepositUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutUserInput | DepositUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type KYCUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    upsert?: KYCUpsertWithoutUserInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutUserInput, KYCUpdateWithoutUserInput>, KYCUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountUpsertWithWhereUniqueWithoutUserInput | MT5AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    set?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    disconnect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    delete?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    update?: MT5AccountUpdateWithWhereUniqueWithoutUserInput | MT5AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountUpdateManyWithWhereWithoutUserInput | MT5AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type WithdrawalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutUserInput | WithdrawalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutUserInput | WithdrawalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutUserInput | WithdrawalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutKycInput = {
    create?: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutKycNestedInput = {
    create?: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycInput
    upsert?: UserUpsertWithoutKycInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKycInput, UserUpdateWithoutKycInput>, UserUncheckedUpdateWithoutKycInput>
  }

  export type DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
  }

  export type DepositCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutMt5AccountsInput = {
    create?: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMt5AccountsInput
    connect?: UserWhereUniqueInput
  }

  export type MT5TransactionCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
  }

  export type WithdrawalCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<WithdrawalCreateWithoutMt5AccountInput, WithdrawalUncheckedCreateWithoutMt5AccountInput> | WithdrawalCreateWithoutMt5AccountInput[] | WithdrawalUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutMt5AccountInput | WithdrawalCreateOrConnectWithoutMt5AccountInput[]
    createMany?: WithdrawalCreateManyMt5AccountInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
  }

  export type DepositUncheckedCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<WithdrawalCreateWithoutMt5AccountInput, WithdrawalUncheckedCreateWithoutMt5AccountInput> | WithdrawalCreateWithoutMt5AccountInput[] | WithdrawalUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutMt5AccountInput | WithdrawalCreateOrConnectWithoutMt5AccountInput[]
    createMany?: WithdrawalCreateManyMt5AccountInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    upsert?: DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    set?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    disconnect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    delete?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    update?: DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput[]
    updateMany?: DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput | DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput[]
    deleteMany?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
  }

  export type DepositUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutMt5AccountInput | DepositUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutMt5AccountInput | DepositUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutMt5AccountInput | DepositUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type UserUpdateOneWithoutMt5AccountsNestedInput = {
    create?: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMt5AccountsInput
    upsert?: UserUpsertWithoutMt5AccountsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMt5AccountsInput, UserUpdateWithoutMt5AccountsInput>, UserUncheckedUpdateWithoutMt5AccountsInput>
  }

  export type MT5TransactionUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    upsert?: MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    set?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    disconnect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    delete?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    update?: MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput | MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
  }

  export type WithdrawalUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<WithdrawalCreateWithoutMt5AccountInput, WithdrawalUncheckedCreateWithoutMt5AccountInput> | WithdrawalCreateWithoutMt5AccountInput[] | WithdrawalUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutMt5AccountInput | WithdrawalCreateOrConnectWithoutMt5AccountInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutMt5AccountInput | WithdrawalUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: WithdrawalCreateManyMt5AccountInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutMt5AccountInput | WithdrawalUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutMt5AccountInput | WithdrawalUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    upsert?: DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    set?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    disconnect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    delete?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    update?: DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput[]
    updateMany?: DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput | DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput[]
    deleteMany?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
  }

  export type DepositUncheckedUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutMt5AccountInput | DepositUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutMt5AccountInput | DepositUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutMt5AccountInput | DepositUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    upsert?: MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    set?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    disconnect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    delete?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    update?: MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput | MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
  }

  export type WithdrawalUncheckedUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<WithdrawalCreateWithoutMt5AccountInput, WithdrawalUncheckedCreateWithoutMt5AccountInput> | WithdrawalCreateWithoutMt5AccountInput[] | WithdrawalUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutMt5AccountInput | WithdrawalCreateOrConnectWithoutMt5AccountInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutMt5AccountInput | WithdrawalUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: WithdrawalCreateManyMt5AccountInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutMt5AccountInput | WithdrawalUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutMt5AccountInput | WithdrawalUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type MT5AccountCreateNestedOneWithoutMt5TransactionsInput = {
    create?: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutMt5TransactionsInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MT5AccountUpdateOneRequiredWithoutMt5TransactionsNestedInput = {
    create?: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutMt5TransactionsInput
    upsert?: MT5AccountUpsertWithoutMt5TransactionsInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutMt5TransactionsInput, MT5AccountUpdateWithoutMt5TransactionsInput>, MT5AccountUncheckedUpdateWithoutMt5TransactionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type DepositCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<DepositCreateWithoutTransactionsInput, DepositUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: DepositCreateOrConnectWithoutTransactionsInput
    connect?: DepositWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type WithdrawalCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WithdrawalCreateWithoutTransactionsInput, WithdrawalUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WithdrawalCreateOrConnectWithoutTransactionsInput
    connect?: WithdrawalWhereUniqueInput
  }

  export type DepositUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<DepositCreateWithoutTransactionsInput, DepositUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: DepositCreateOrConnectWithoutTransactionsInput
    upsert?: DepositUpsertWithoutTransactionsInput
    disconnect?: DepositWhereInput | boolean
    delete?: DepositWhereInput | boolean
    connect?: DepositWhereUniqueInput
    update?: XOR<XOR<DepositUpdateToOneWithWhereWithoutTransactionsInput, DepositUpdateWithoutTransactionsInput>, DepositUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type WithdrawalUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<WithdrawalCreateWithoutTransactionsInput, WithdrawalUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WithdrawalCreateOrConnectWithoutTransactionsInput
    upsert?: WithdrawalUpsertWithoutTransactionsInput
    disconnect?: WithdrawalWhereInput | boolean
    delete?: WithdrawalWhereInput | boolean
    connect?: WithdrawalWhereUniqueInput
    update?: XOR<XOR<WithdrawalUpdateToOneWithWhereWithoutTransactionsInput, WithdrawalUpdateWithoutTransactionsInput>, WithdrawalUncheckedUpdateWithoutTransactionsInput>
  }

  export type MT5AccountCreateNestedOneWithoutDepositsInput = {
    create?: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDepositsInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDepositsInput = {
    create?: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutDepositInput = {
    create?: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput> | TransactionCreateWithoutDepositInput[] | TransactionUncheckedCreateWithoutDepositInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutDepositInput | TransactionCreateOrConnectWithoutDepositInput[]
    createMany?: TransactionCreateManyDepositInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutDepositInput = {
    create?: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput> | TransactionCreateWithoutDepositInput[] | TransactionUncheckedCreateWithoutDepositInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutDepositInput | TransactionCreateOrConnectWithoutDepositInput[]
    createMany?: TransactionCreateManyDepositInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MT5AccountUpdateOneRequiredWithoutDepositsNestedInput = {
    create?: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDepositsInput
    upsert?: MT5AccountUpsertWithoutDepositsInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutDepositsInput, MT5AccountUpdateWithoutDepositsInput>, MT5AccountUncheckedUpdateWithoutDepositsInput>
  }

  export type UserUpdateOneRequiredWithoutDepositsNestedInput = {
    create?: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositsInput
    upsert?: UserUpsertWithoutDepositsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepositsInput, UserUpdateWithoutDepositsInput>, UserUncheckedUpdateWithoutDepositsInput>
  }

  export type TransactionUpdateManyWithoutDepositNestedInput = {
    create?: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput> | TransactionCreateWithoutDepositInput[] | TransactionUncheckedCreateWithoutDepositInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutDepositInput | TransactionCreateOrConnectWithoutDepositInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutDepositInput | TransactionUpsertWithWhereUniqueWithoutDepositInput[]
    createMany?: TransactionCreateManyDepositInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutDepositInput | TransactionUpdateWithWhereUniqueWithoutDepositInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutDepositInput | TransactionUpdateManyWithWhereWithoutDepositInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutDepositNestedInput = {
    create?: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput> | TransactionCreateWithoutDepositInput[] | TransactionUncheckedCreateWithoutDepositInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutDepositInput | TransactionCreateOrConnectWithoutDepositInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutDepositInput | TransactionUpsertWithWhereUniqueWithoutDepositInput[]
    createMany?: TransactionCreateManyDepositInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutDepositInput | TransactionUpdateWithWhereUniqueWithoutDepositInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutDepositInput | TransactionUpdateManyWithWhereWithoutDepositInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionCreateNestedManyWithoutWithdrawalInput = {
    create?: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput> | TransactionCreateWithoutWithdrawalInput[] | TransactionUncheckedCreateWithoutWithdrawalInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWithdrawalInput | TransactionCreateOrConnectWithoutWithdrawalInput[]
    createMany?: TransactionCreateManyWithdrawalInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MT5AccountCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<MT5AccountCreateWithoutWithdrawalsInput, MT5AccountUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutWithdrawalsInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWithdrawalsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutWithdrawalInput = {
    create?: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput> | TransactionCreateWithoutWithdrawalInput[] | TransactionUncheckedCreateWithoutWithdrawalInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWithdrawalInput | TransactionCreateOrConnectWithoutWithdrawalInput[]
    createMany?: TransactionCreateManyWithdrawalInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutWithdrawalNestedInput = {
    create?: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput> | TransactionCreateWithoutWithdrawalInput[] | TransactionUncheckedCreateWithoutWithdrawalInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWithdrawalInput | TransactionCreateOrConnectWithoutWithdrawalInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWithdrawalInput | TransactionUpsertWithWhereUniqueWithoutWithdrawalInput[]
    createMany?: TransactionCreateManyWithdrawalInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWithdrawalInput | TransactionUpdateWithWhereUniqueWithoutWithdrawalInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWithdrawalInput | TransactionUpdateManyWithWhereWithoutWithdrawalInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type MT5AccountUpdateOneRequiredWithoutWithdrawalsNestedInput = {
    create?: XOR<MT5AccountCreateWithoutWithdrawalsInput, MT5AccountUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutWithdrawalsInput
    upsert?: MT5AccountUpsertWithoutWithdrawalsInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutWithdrawalsInput, MT5AccountUpdateWithoutWithdrawalsInput>, MT5AccountUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type UserUpdateOneRequiredWithoutWithdrawalsNestedInput = {
    create?: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWithdrawalsInput
    upsert?: UserUpsertWithoutWithdrawalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWithdrawalsInput, UserUpdateWithoutWithdrawalsInput>, UserUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type TransactionUncheckedUpdateManyWithoutWithdrawalNestedInput = {
    create?: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput> | TransactionCreateWithoutWithdrawalInput[] | TransactionUncheckedCreateWithoutWithdrawalInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWithdrawalInput | TransactionCreateOrConnectWithoutWithdrawalInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWithdrawalInput | TransactionUpsertWithWhereUniqueWithoutWithdrawalInput[]
    createMany?: TransactionCreateManyWithdrawalInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWithdrawalInput | TransactionUpdateWithWhereUniqueWithoutWithdrawalInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWithdrawalInput | TransactionUpdateManyWithWhereWithoutWithdrawalInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type MT5AccountCreateNestedOneWithoutDefaultMT5AccountInput = {
    create?: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDefaultMT5AccountInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDefaultMT5AccountInput = {
    create?: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutDefaultMT5AccountInput
    connect?: UserWhereUniqueInput
  }

  export type MT5AccountUpdateOneRequiredWithoutDefaultMT5AccountNestedInput = {
    create?: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDefaultMT5AccountInput
    upsert?: MT5AccountUpsertWithoutDefaultMT5AccountInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutDefaultMT5AccountInput, MT5AccountUpdateWithoutDefaultMT5AccountInput>, MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type UserUpdateOneRequiredWithoutDefaultMT5AccountNestedInput = {
    create?: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutDefaultMT5AccountInput
    upsert?: UserUpsertWithoutDefaultMT5AccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDefaultMT5AccountInput, UserUpdateWithoutDefaultMT5AccountInput>, UserUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type UserFavoriteCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserFavoriteUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutInstrumentInput | UserFavoriteUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutInstrumentInput | UserFavoriteUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokenInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutRefreshTokenNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    upsert?: UserUpsertWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokenInput, UserUpdateWithoutRefreshTokenInput>, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type InstrumentCreateNestedOneWithoutUserFavoriteInput = {
    create?: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: InstrumentCreateOrConnectWithoutUserFavoriteInput
    connect?: InstrumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserFavoriteInput = {
    create?: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavoriteInput
    connect?: UserWhereUniqueInput
  }

  export type InstrumentUpdateOneRequiredWithoutUserFavoriteNestedInput = {
    create?: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: InstrumentCreateOrConnectWithoutUserFavoriteInput
    upsert?: InstrumentUpsertWithoutUserFavoriteInput
    connect?: InstrumentWhereUniqueInput
    update?: XOR<XOR<InstrumentUpdateToOneWithWhereWithoutUserFavoriteInput, InstrumentUpdateWithoutUserFavoriteInput>, InstrumentUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type UserUpdateOneRequiredWithoutUserFavoriteNestedInput = {
    create?: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavoriteInput
    upsert?: UserUpsertWithoutUserFavoriteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserFavoriteInput, UserUpdateWithoutUserFavoriteInput>, UserUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type admin_login_logCreateNestedManyWithoutAdminInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
  }

  export type balance_operation_historyCreateNestedManyWithoutAdminInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
  }

  export type admin_login_logUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
  }

  export type balance_operation_historyUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
  }

  export type admin_login_logUpdateManyWithoutAdminNestedInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    upsert?: admin_login_logUpsertWithWhereUniqueWithoutAdminInput | admin_login_logUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    set?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    disconnect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    delete?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    update?: admin_login_logUpdateWithWhereUniqueWithoutAdminInput | admin_login_logUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: admin_login_logUpdateManyWithWhereWithoutAdminInput | admin_login_logUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
  }

  export type balance_operation_historyUpdateManyWithoutAdminNestedInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    upsert?: balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput | balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    set?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    disconnect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    delete?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    update?: balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput | balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: balance_operation_historyUpdateManyWithWhereWithoutAdminInput | balance_operation_historyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
  }

  export type admin_login_logUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    upsert?: admin_login_logUpsertWithWhereUniqueWithoutAdminInput | admin_login_logUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    set?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    disconnect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    delete?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    update?: admin_login_logUpdateWithWhereUniqueWithoutAdminInput | admin_login_logUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: admin_login_logUpdateManyWithWhereWithoutAdminInput | admin_login_logUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
  }

  export type balance_operation_historyUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    upsert?: balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput | balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    set?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    disconnect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    delete?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    update?: balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput | balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: balance_operation_historyUpdateManyWithWhereWithoutAdminInput | balance_operation_historyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
  }

  export type adminCreateNestedOneWithoutAdmin_login_logInput = {
    create?: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
    connectOrCreate?: adminCreateOrConnectWithoutAdmin_login_logInput
    connect?: adminWhereUniqueInput
  }

  export type adminUpdateOneRequiredWithoutAdmin_login_logNestedInput = {
    create?: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
    connectOrCreate?: adminCreateOrConnectWithoutAdmin_login_logInput
    upsert?: adminUpsertWithoutAdmin_login_logInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutAdmin_login_logInput, adminUpdateWithoutAdmin_login_logInput>, adminUncheckedUpdateWithoutAdmin_login_logInput>
  }

  export type adminCreateNestedOneWithoutBalance_operation_historyInput = {
    create?: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
    connectOrCreate?: adminCreateOrConnectWithoutBalance_operation_historyInput
    connect?: adminWhereUniqueInput
  }

  export type adminUpdateOneRequiredWithoutBalance_operation_historyNestedInput = {
    create?: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
    connectOrCreate?: adminCreateOrConnectWithoutBalance_operation_historyInput
    upsert?: adminUpsertWithoutBalance_operation_historyInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutBalance_operation_historyInput, adminUpdateWithoutBalance_operation_historyInput>, adminUncheckedUpdateWithoutBalance_operation_historyInput>
  }

  export type chat_conversationsCreatetagsInput = {
    set: string[]
  }

  export type chat_messagesCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type chat_participantsCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
  }

  export type chat_messagesUncheckedCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type chat_participantsUncheckedCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
  }

  export type chat_conversationsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type chat_messagesUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput | chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type chat_participantsUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    set?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    disconnect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    delete?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    update?: chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput | chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
  }

  export type chat_messagesUncheckedUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput | chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type chat_participantsUncheckedUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    set?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    disconnect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    delete?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    update?: chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput | chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
  }

  export type chat_conversationsCreateNestedOneWithoutChat_messagesInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_messagesInput
    connect?: chat_conversationsWhereUniqueInput
  }

  export type chat_conversationsUpdateOneWithoutChat_messagesNestedInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_messagesInput
    upsert?: chat_conversationsUpsertWithoutChat_messagesInput
    disconnect?: chat_conversationsWhereInput | boolean
    delete?: chat_conversationsWhereInput | boolean
    connect?: chat_conversationsWhereUniqueInput
    update?: XOR<XOR<chat_conversationsUpdateToOneWithWhereWithoutChat_messagesInput, chat_conversationsUpdateWithoutChat_messagesInput>, chat_conversationsUncheckedUpdateWithoutChat_messagesInput>
  }

  export type chat_conversationsCreateNestedOneWithoutChat_participantsInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_participantsInput
    connect?: chat_conversationsWhereUniqueInput
  }

  export type chat_conversationsUpdateOneWithoutChat_participantsNestedInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_participantsInput
    upsert?: chat_conversationsUpsertWithoutChat_participantsInput
    disconnect?: chat_conversationsWhereInput | boolean
    delete?: chat_conversationsWhereInput | boolean
    connect?: chat_conversationsWhereUniqueInput
    update?: XOR<XOR<chat_conversationsUpdateToOneWithWhereWithoutChat_participantsInput, chat_conversationsUpdateWithoutChat_participantsInput>, chat_conversationsUncheckedUpdateWithoutChat_participantsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ib_group_assignmentsCreateNestedManyWithoutIb_requestsInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
  }

  export type ib_group_assignmentsUncheckedCreateNestedManyWithoutIb_requestsInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ib_group_assignmentsUpdateManyWithoutIb_requestsNestedInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    upsert?: ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    set?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    disconnect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    delete?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    update?: ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput[]
    updateMany?: ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput | ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput[]
    deleteMany?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
  }

  export type ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsNestedInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    upsert?: ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    set?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    disconnect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    delete?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    update?: ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput[]
    updateMany?: ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput | ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput[]
    deleteMany?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ib_requestsCreateNestedOneWithoutIb_group_assignmentsInput = {
    create?: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
    connectOrCreate?: ib_requestsCreateOrConnectWithoutIb_group_assignmentsInput
    connect?: ib_requestsWhereUniqueInput
  }

  export type ib_requestsUpdateOneWithoutIb_group_assignmentsNestedInput = {
    create?: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
    connectOrCreate?: ib_requestsCreateOrConnectWithoutIb_group_assignmentsInput
    upsert?: ib_requestsUpsertWithoutIb_group_assignmentsInput
    disconnect?: ib_requestsWhereInput | boolean
    delete?: ib_requestsWhereInput | boolean
    connect?: ib_requestsWhereUniqueInput
    update?: XOR<XOR<ib_requestsUpdateToOneWithWhereWithoutIb_group_assignmentsInput, ib_requestsUpdateWithoutIb_group_assignmentsInput>, ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput>
  }

  export type support_ticketsCreatetagsInput = {
    set: string[]
  }

  export type support_ticketsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type support_ticket_repliesCreateattachmentsInput = {
    set: string[]
  }

  export type support_ticket_repliesUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type support_articlesCreatetagsInput = {
    set: string[]
  }

  export type support_articlesUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type support_faqCreatetagsInput = {
    set: string[]
  }

  export type support_faqUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutAdminInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutAdminInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type ActivityLogCreateManyAdminInputEnvelope = {
    data: ActivityLogCreateManyAdminInput | ActivityLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type DefaultMT5AccountCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    MT5Account: MT5AccountCreateNestedOneWithoutDefaultMT5AccountInput
  }

  export type DefaultMT5AccountUncheckedCreateWithoutUserInput = {
    id: string
    mt5AccountId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DefaultMT5AccountCreateOrConnectWithoutUserInput = {
    where: DefaultMT5AccountWhereUniqueInput
    create: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
  }

  export type DepositCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutDepositsInput
    transactions?: TransactionCreateNestedManyWithoutDepositInput
  }

  export type DepositUncheckedCreateWithoutUserInput = {
    id?: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutDepositInput
  }

  export type DepositCreateOrConnectWithoutUserInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput>
  }

  export type DepositCreateManyUserInputEnvelope = {
    data: DepositCreateManyUserInput | DepositCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KYCCreateWithoutUserInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCUncheckedCreateWithoutUserInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCCreateOrConnectWithoutUserInput = {
    where: KYCWhereUniqueInput
    create: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountCreateManyUserInputEnvelope = {
    data: MT5AccountCreateManyUserInput | MT5AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deposit?: DepositCreateNestedOneWithoutTransactionsInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutUserInput = {
    id: string
    sortOrder?: number
    addedAt?: Date | string
    Instrument: InstrumentCreateNestedOneWithoutUserFavoriteInput
  }

  export type UserFavoriteUncheckedCreateWithoutUserInput = {
    id: string
    instrumentId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteCreateManyUserInputEnvelope = {
    data: UserFavoriteCreateManyUserInput | UserFavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawalCreateWithoutUserInput = {
    id?: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    transactions?: TransactionCreateNestedManyWithoutWithdrawalInput
    mt5Account: MT5AccountCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateWithoutUserInput = {
    id?: string
    mt5AccountId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutWithdrawalInput
  }

  export type WithdrawalCreateOrConnectWithoutUserInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput>
  }

  export type WithdrawalCreateManyUserInputEnvelope = {
    data: WithdrawalCreateManyUserInput | WithdrawalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountType?: StringFilter<"Account"> | string
    balance?: FloatFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutAdminInput, ActivityLogUncheckedUpdateWithoutAdminInput>
    create: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutAdminInput, ActivityLogUncheckedUpdateWithoutAdminInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutAdminInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableFilter<"ActivityLog"> | string | null
    newValues?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type DefaultMT5AccountUpsertWithoutUserInput = {
    update: XOR<DefaultMT5AccountUpdateWithoutUserInput, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
    create: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    where?: DefaultMT5AccountWhereInput
  }

  export type DefaultMT5AccountUpdateToOneWithWhereWithoutUserInput = {
    where?: DefaultMT5AccountWhereInput
    data: XOR<DefaultMT5AccountUpdateWithoutUserInput, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type DefaultMT5AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MT5Account?: MT5AccountUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
  }

  export type DefaultMT5AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUpsertWithWhereUniqueWithoutUserInput = {
    where: DepositWhereUniqueInput
    update: XOR<DepositUpdateWithoutUserInput, DepositUncheckedUpdateWithoutUserInput>
    create: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput>
  }

  export type DepositUpdateWithWhereUniqueWithoutUserInput = {
    where: DepositWhereUniqueInput
    data: XOR<DepositUpdateWithoutUserInput, DepositUncheckedUpdateWithoutUserInput>
  }

  export type DepositUpdateManyWithWhereWithoutUserInput = {
    where: DepositScalarWhereInput
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyWithoutUserInput>
  }

  export type DepositScalarWhereInput = {
    AND?: DepositScalarWhereInput | DepositScalarWhereInput[]
    OR?: DepositScalarWhereInput[]
    NOT?: DepositScalarWhereInput | DepositScalarWhereInput[]
    id?: StringFilter<"Deposit"> | string
    userId?: StringFilter<"Deposit"> | string
    mt5AccountId?: StringFilter<"Deposit"> | string
    amount?: FloatFilter<"Deposit"> | number
    currency?: StringFilter<"Deposit"> | string
    method?: StringFilter<"Deposit"> | string
    paymentMethod?: StringNullableFilter<"Deposit"> | string | null
    transactionHash?: StringNullableFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableFilter<"Deposit"> | string | null
    bankDetails?: StringNullableFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableFilter<"Deposit"> | string | null
    depositAddress?: StringNullableFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    rejectionReason?: StringNullableFilter<"Deposit"> | string | null
    approvedBy?: StringNullableFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
  }

  export type KYCUpsertWithoutUserInput = {
    update: XOR<KYCUpdateWithoutUserInput, KYCUncheckedUpdateWithoutUserInput>
    create: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    where?: KYCWhereInput
  }

  export type KYCUpdateToOneWithWhereWithoutUserInput = {
    where?: KYCWhereInput
    data: XOR<KYCUpdateWithoutUserInput, KYCUncheckedUpdateWithoutUserInput>
  }

  export type KYCUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    update: XOR<MT5AccountUpdateWithoutUserInput, MT5AccountUncheckedUpdateWithoutUserInput>
    create: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    data: XOR<MT5AccountUpdateWithoutUserInput, MT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountUpdateManyWithWhereWithoutUserInput = {
    where: MT5AccountScalarWhereInput
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type MT5AccountScalarWhereInput = {
    AND?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
    OR?: MT5AccountScalarWhereInput[]
    NOT?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
    id?: StringFilter<"MT5Account"> | string
    accountId?: StringFilter<"MT5Account"> | string
    userId?: StringNullableFilter<"MT5Account"> | string | null
    accountType?: StringFilter<"MT5Account"> | string
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    leverage?: IntNullableFilter<"MT5Account"> | number | null
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableFilter<"RefreshToken"> | boolean | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    currency?: StringFilter<"Transaction"> | string
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    depositId?: StringNullableFilter<"Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"Transaction"> | string | null
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutUserInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFavoriteScalarWhereInput = {
    AND?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    OR?: UserFavoriteScalarWhereInput[]
    NOT?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    id?: StringFilter<"UserFavorite"> | string
    userId?: StringFilter<"UserFavorite"> | string
    instrumentId?: StringFilter<"UserFavorite"> | string
    sortOrder?: IntFilter<"UserFavorite"> | number
    addedAt?: DateTimeFilter<"UserFavorite"> | Date | string
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutUserInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutUserInput, WithdrawalUncheckedUpdateWithoutUserInput>
    create: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutUserInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutUserInput, WithdrawalUncheckedUpdateWithoutUserInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutUserInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutUserInput>
  }

  export type WithdrawalScalarWhereInput = {
    AND?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
    OR?: WithdrawalScalarWhereInput[]
    NOT?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
    id?: StringFilter<"Withdrawal"> | string
    userId?: StringFilter<"Withdrawal"> | string
    mt5AccountId?: StringFilter<"Withdrawal"> | string
    amount?: FloatFilter<"Withdrawal"> | number
    method?: StringFilter<"Withdrawal"> | string
    bankDetails?: StringNullableFilter<"Withdrawal"> | string | null
    cryptoAddress?: StringNullableFilter<"Withdrawal"> | string | null
    status?: StringFilter<"Withdrawal"> | string
    rejectionReason?: StringNullableFilter<"Withdrawal"> | string | null
    approvedBy?: StringNullableFilter<"Withdrawal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    currency?: StringFilter<"Withdrawal"> | string
    externalTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    paymentMethod?: StringNullableFilter<"Withdrawal"> | string | null
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    walletAddress?: StringNullableFilter<"Withdrawal"> | string | null
  }

  export type UserCreateWithoutKycInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKycInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKycInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
  }

  export type UserUpsertWithoutKycInput = {
    update: XOR<UserUpdateWithoutKycInput, UserUncheckedUpdateWithoutKycInput>
    create: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKycInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKycInput, UserUncheckedUpdateWithoutKycInput>
  }

  export type UserUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DefaultMT5AccountCreateWithoutMT5AccountInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    User: UserCreateNestedOneWithoutDefaultMT5AccountInput
  }

  export type DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput = {
    where: DefaultMT5AccountWhereUniqueInput
    create: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountCreateManyMT5AccountInputEnvelope = {
    data: DefaultMT5AccountCreateManyMT5AccountInput | DefaultMT5AccountCreateManyMT5AccountInput[]
    skipDuplicates?: boolean
  }

  export type DepositCreateWithoutMt5AccountInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepositsInput
    transactions?: TransactionCreateNestedManyWithoutDepositInput
  }

  export type DepositUncheckedCreateWithoutMt5AccountInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutDepositInput
  }

  export type DepositCreateOrConnectWithoutMt5AccountInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput>
  }

  export type DepositCreateManyMt5AccountInputEnvelope = {
    data: DepositCreateManyMt5AccountInput | DepositCreateManyMt5AccountInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMt5AccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMt5AccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMt5AccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
  }

  export type MT5TransactionCreateWithoutMt5AccountInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionUncheckedCreateWithoutMt5AccountInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionCreateOrConnectWithoutMt5AccountInput = {
    where: MT5TransactionWhereUniqueInput
    create: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput>
  }

  export type MT5TransactionCreateManyMt5AccountInputEnvelope = {
    data: MT5TransactionCreateManyMt5AccountInput | MT5TransactionCreateManyMt5AccountInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawalCreateWithoutMt5AccountInput = {
    id?: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    transactions?: TransactionCreateNestedManyWithoutWithdrawalInput
    user: UserCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateWithoutMt5AccountInput = {
    id?: string
    userId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutWithdrawalInput
  }

  export type WithdrawalCreateOrConnectWithoutMt5AccountInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutMt5AccountInput, WithdrawalUncheckedCreateWithoutMt5AccountInput>
  }

  export type WithdrawalCreateManyMt5AccountInputEnvelope = {
    data: WithdrawalCreateManyMt5AccountInput | WithdrawalCreateManyMt5AccountInput[]
    skipDuplicates?: boolean
  }

  export type DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput = {
    where: DefaultMT5AccountWhereUniqueInput
    update: XOR<DefaultMT5AccountUpdateWithoutMT5AccountInput, DefaultMT5AccountUncheckedUpdateWithoutMT5AccountInput>
    create: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput = {
    where: DefaultMT5AccountWhereUniqueInput
    data: XOR<DefaultMT5AccountUpdateWithoutMT5AccountInput, DefaultMT5AccountUncheckedUpdateWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput = {
    where: DefaultMT5AccountScalarWhereInput
    data: XOR<DefaultMT5AccountUpdateManyMutationInput, DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountScalarWhereInput = {
    AND?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
    OR?: DefaultMT5AccountScalarWhereInput[]
    NOT?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
    id?: StringFilter<"DefaultMT5Account"> | string
    userId?: StringFilter<"DefaultMT5Account"> | string
    mt5AccountId?: StringFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
  }

  export type DepositUpsertWithWhereUniqueWithoutMt5AccountInput = {
    where: DepositWhereUniqueInput
    update: XOR<DepositUpdateWithoutMt5AccountInput, DepositUncheckedUpdateWithoutMt5AccountInput>
    create: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput>
  }

  export type DepositUpdateWithWhereUniqueWithoutMt5AccountInput = {
    where: DepositWhereUniqueInput
    data: XOR<DepositUpdateWithoutMt5AccountInput, DepositUncheckedUpdateWithoutMt5AccountInput>
  }

  export type DepositUpdateManyWithWhereWithoutMt5AccountInput = {
    where: DepositScalarWhereInput
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyWithoutMt5AccountInput>
  }

  export type UserUpsertWithoutMt5AccountsInput = {
    update: XOR<UserUpdateWithoutMt5AccountsInput, UserUncheckedUpdateWithoutMt5AccountsInput>
    create: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMt5AccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMt5AccountsInput, UserUncheckedUpdateWithoutMt5AccountsInput>
  }

  export type UserUpdateWithoutMt5AccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMt5AccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput = {
    where: MT5TransactionWhereUniqueInput
    update: XOR<MT5TransactionUpdateWithoutMt5AccountInput, MT5TransactionUncheckedUpdateWithoutMt5AccountInput>
    create: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput>
  }

  export type MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput = {
    where: MT5TransactionWhereUniqueInput
    data: XOR<MT5TransactionUpdateWithoutMt5AccountInput, MT5TransactionUncheckedUpdateWithoutMt5AccountInput>
  }

  export type MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput = {
    where: MT5TransactionScalarWhereInput
    data: XOR<MT5TransactionUpdateManyMutationInput, MT5TransactionUncheckedUpdateManyWithoutMt5AccountInput>
  }

  export type MT5TransactionScalarWhereInput = {
    AND?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
    OR?: MT5TransactionScalarWhereInput[]
    NOT?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
    id?: StringFilter<"MT5Transaction"> | string
    type?: StringFilter<"MT5Transaction"> | string
    amount?: FloatFilter<"MT5Transaction"> | number
    status?: StringNullableFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableFilter<"MT5Transaction"> | string | null
    comment?: StringNullableFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"MT5Transaction"> | string | null
    userId?: StringNullableFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutMt5AccountInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutMt5AccountInput, WithdrawalUncheckedUpdateWithoutMt5AccountInput>
    create: XOR<WithdrawalCreateWithoutMt5AccountInput, WithdrawalUncheckedCreateWithoutMt5AccountInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutMt5AccountInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutMt5AccountInput, WithdrawalUncheckedUpdateWithoutMt5AccountInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutMt5AccountInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutMt5AccountInput>
  }

  export type MT5AccountCreateWithoutMt5TransactionsInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    withdrawals?: WithdrawalCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutMt5TransactionsInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutMt5TransactionsInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
  }

  export type MT5AccountUpsertWithoutMt5TransactionsInput = {
    update: XOR<MT5AccountUpdateWithoutMt5TransactionsInput, MT5AccountUncheckedUpdateWithoutMt5TransactionsInput>
    create: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutMt5TransactionsInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutMt5TransactionsInput, MT5AccountUncheckedUpdateWithoutMt5TransactionsInput>
  }

  export type MT5AccountUpdateWithoutMt5TransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutMt5TransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DepositCreateWithoutTransactionsInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutDepositsInput
    user: UserCreateNestedOneWithoutDepositsInput
  }

  export type DepositUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositCreateOrConnectWithoutTransactionsInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutTransactionsInput, DepositUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type WithdrawalCreateWithoutTransactionsInput = {
    id?: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    mt5Account: MT5AccountCreateNestedOneWithoutWithdrawalsInput
    user: UserCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
  }

  export type WithdrawalCreateOrConnectWithoutTransactionsInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutTransactionsInput, WithdrawalUncheckedCreateWithoutTransactionsInput>
  }

  export type DepositUpsertWithoutTransactionsInput = {
    update: XOR<DepositUpdateWithoutTransactionsInput, DepositUncheckedUpdateWithoutTransactionsInput>
    create: XOR<DepositCreateWithoutTransactionsInput, DepositUncheckedCreateWithoutTransactionsInput>
    where?: DepositWhereInput
  }

  export type DepositUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: DepositWhereInput
    data: XOR<DepositUpdateWithoutTransactionsInput, DepositUncheckedUpdateWithoutTransactionsInput>
  }

  export type DepositUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutDepositsNestedInput
    user?: UserUpdateOneRequiredWithoutDepositsNestedInput
  }

  export type DepositUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WithdrawalUpsertWithoutTransactionsInput = {
    update: XOR<WithdrawalUpdateWithoutTransactionsInput, WithdrawalUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WithdrawalCreateWithoutTransactionsInput, WithdrawalUncheckedCreateWithoutTransactionsInput>
    where?: WithdrawalWhereInput
  }

  export type WithdrawalUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WithdrawalWhereInput
    data: XOR<WithdrawalUpdateWithoutTransactionsInput, WithdrawalUncheckedUpdateWithoutTransactionsInput>
  }

  export type WithdrawalUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Account?: MT5AccountUpdateOneRequiredWithoutWithdrawalsNestedInput
    user?: UserUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MT5AccountCreateWithoutDepositsInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutDepositsInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutDepositsInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
  }

  export type UserCreateWithoutDepositsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepositsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepositsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
  }

  export type TransactionCreateWithoutDepositInput = {
    id?: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    withdrawal?: WithdrawalCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutDepositInput = {
    id?: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    withdrawalId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutDepositInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput>
  }

  export type TransactionCreateManyDepositInputEnvelope = {
    data: TransactionCreateManyDepositInput | TransactionCreateManyDepositInput[]
    skipDuplicates?: boolean
  }

  export type MT5AccountUpsertWithoutDepositsInput = {
    update: XOR<MT5AccountUpdateWithoutDepositsInput, MT5AccountUncheckedUpdateWithoutDepositsInput>
    create: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutDepositsInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutDepositsInput, MT5AccountUncheckedUpdateWithoutDepositsInput>
  }

  export type MT5AccountUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type UserUpsertWithoutDepositsInput = {
    update: XOR<UserUpdateWithoutDepositsInput, UserUncheckedUpdateWithoutDepositsInput>
    create: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepositsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepositsInput, UserUncheckedUpdateWithoutDepositsInput>
  }

  export type UserUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutDepositInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutDepositInput, TransactionUncheckedUpdateWithoutDepositInput>
    create: XOR<TransactionCreateWithoutDepositInput, TransactionUncheckedCreateWithoutDepositInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutDepositInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutDepositInput, TransactionUncheckedUpdateWithoutDepositInput>
  }

  export type TransactionUpdateManyWithWhereWithoutDepositInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutDepositInput>
  }

  export type TransactionCreateWithoutWithdrawalInput = {
    id?: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deposit?: DepositCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutWithdrawalInput = {
    id?: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutWithdrawalInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput>
  }

  export type TransactionCreateManyWithdrawalInputEnvelope = {
    data: TransactionCreateManyWithdrawalInput | TransactionCreateManyWithdrawalInput[]
    skipDuplicates?: boolean
  }

  export type MT5AccountCreateWithoutWithdrawalsInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutWithdrawalsInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutWithdrawalsInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutWithdrawalsInput, MT5AccountUncheckedCreateWithoutWithdrawalsInput>
  }

  export type UserCreateWithoutWithdrawalsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWithdrawalsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWithdrawalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutWithdrawalInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutWithdrawalInput, TransactionUncheckedUpdateWithoutWithdrawalInput>
    create: XOR<TransactionCreateWithoutWithdrawalInput, TransactionUncheckedCreateWithoutWithdrawalInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutWithdrawalInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutWithdrawalInput, TransactionUncheckedUpdateWithoutWithdrawalInput>
  }

  export type TransactionUpdateManyWithWhereWithoutWithdrawalInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutWithdrawalInput>
  }

  export type MT5AccountUpsertWithoutWithdrawalsInput = {
    update: XOR<MT5AccountUpdateWithoutWithdrawalsInput, MT5AccountUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<MT5AccountCreateWithoutWithdrawalsInput, MT5AccountUncheckedCreateWithoutWithdrawalsInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutWithdrawalsInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutWithdrawalsInput, MT5AccountUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type MT5AccountUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type UserUpsertWithoutWithdrawalsInput = {
    update: XOR<UserUpdateWithoutWithdrawalsInput, UserUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWithdrawalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWithdrawalsInput, UserUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type UserUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5AccountCreateWithoutDefaultMT5AccountInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutDefaultMT5AccountInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
  }

  export type UserCreateWithoutDefaultMT5AccountInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDefaultMT5AccountInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDefaultMT5AccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
  }

  export type MT5AccountUpsertWithoutDefaultMT5AccountInput = {
    update: XOR<MT5AccountUpdateWithoutDefaultMT5AccountInput, MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput>
    create: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutDefaultMT5AccountInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutDefaultMT5AccountInput, MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type MT5AccountUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type UserUpsertWithoutDefaultMT5AccountInput = {
    update: XOR<UserUpdateWithoutDefaultMT5AccountInput, UserUncheckedUpdateWithoutDefaultMT5AccountInput>
    create: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDefaultMT5AccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDefaultMT5AccountInput, UserUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type UserUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserFavoriteCreateWithoutInstrumentInput = {
    id: string
    sortOrder?: number
    addedAt?: Date | string
    User: UserCreateNestedOneWithoutUserFavoriteInput
  }

  export type UserFavoriteUncheckedCreateWithoutInstrumentInput = {
    id: string
    userId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutInstrumentInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput>
  }

  export type UserFavoriteCreateManyInstrumentInputEnvelope = {
    data: UserFavoriteCreateManyInstrumentInput | UserFavoriteCreateManyInstrumentInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutInstrumentInput, UserFavoriteUncheckedUpdateWithoutInstrumentInput>
    create: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutInstrumentInput, UserFavoriteUncheckedUpdateWithoutInstrumentInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutInstrumentInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutInstrumentInput>
  }

  export type UserCreateWithoutRefreshTokenInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokenInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
  }

  export type UserUpsertWithoutRefreshTokenInput = {
    update: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type UserUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstrumentCreateWithoutUserFavoriteInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type InstrumentUncheckedCreateWithoutUserFavoriteInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type InstrumentCreateOrConnectWithoutUserFavoriteInput = {
    where: InstrumentWhereUniqueInput
    create: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
  }

  export type UserCreateWithoutUserFavoriteInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserFavoriteInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserFavoriteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
  }

  export type InstrumentUpsertWithoutUserFavoriteInput = {
    update: XOR<InstrumentUpdateWithoutUserFavoriteInput, InstrumentUncheckedUpdateWithoutUserFavoriteInput>
    create: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
    where?: InstrumentWhereInput
  }

  export type InstrumentUpdateToOneWithWhereWithoutUserFavoriteInput = {
    where?: InstrumentWhereInput
    data: XOR<InstrumentUpdateWithoutUserFavoriteInput, InstrumentUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type InstrumentUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstrumentUncheckedUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUserFavoriteInput = {
    update: XOR<UserUpdateWithoutUserFavoriteInput, UserUncheckedUpdateWithoutUserFavoriteInput>
    create: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserFavoriteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserFavoriteInput, UserUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type UserUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
  }

  export type admin_login_logCreateWithoutAdminInput = {
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUncheckedCreateWithoutAdminInput = {
    id?: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logCreateOrConnectWithoutAdminInput = {
    where: admin_login_logWhereUniqueInput
    create: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput>
  }

  export type admin_login_logCreateManyAdminInputEnvelope = {
    data: admin_login_logCreateManyAdminInput | admin_login_logCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type balance_operation_historyCreateWithoutAdminInput = {
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyUncheckedCreateWithoutAdminInput = {
    id?: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyCreateOrConnectWithoutAdminInput = {
    where: balance_operation_historyWhereUniqueInput
    create: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput>
  }

  export type balance_operation_historyCreateManyAdminInputEnvelope = {
    data: balance_operation_historyCreateManyAdminInput | balance_operation_historyCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type admin_login_logUpsertWithWhereUniqueWithoutAdminInput = {
    where: admin_login_logWhereUniqueInput
    update: XOR<admin_login_logUpdateWithoutAdminInput, admin_login_logUncheckedUpdateWithoutAdminInput>
    create: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput>
  }

  export type admin_login_logUpdateWithWhereUniqueWithoutAdminInput = {
    where: admin_login_logWhereUniqueInput
    data: XOR<admin_login_logUpdateWithoutAdminInput, admin_login_logUncheckedUpdateWithoutAdminInput>
  }

  export type admin_login_logUpdateManyWithWhereWithoutAdminInput = {
    where: admin_login_logScalarWhereInput
    data: XOR<admin_login_logUpdateManyMutationInput, admin_login_logUncheckedUpdateManyWithoutAdminInput>
  }

  export type admin_login_logScalarWhereInput = {
    AND?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
    OR?: admin_login_logScalarWhereInput[]
    NOT?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
    id?: IntFilter<"admin_login_log"> | number
    admin_id?: IntFilter<"admin_login_log"> | number
    ip_address?: StringFilter<"admin_login_log"> | string
    user_agent?: StringNullableFilter<"admin_login_log"> | string | null
    location?: StringNullableFilter<"admin_login_log"> | string | null
    device?: StringNullableFilter<"admin_login_log"> | string | null
    browser?: StringNullableFilter<"admin_login_log"> | string | null
    os?: StringNullableFilter<"admin_login_log"> | string | null
    success?: BoolFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableFilter<"admin_login_log"> | string | null
    created_at?: DateTimeFilter<"admin_login_log"> | Date | string
  }

  export type balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput = {
    where: balance_operation_historyWhereUniqueInput
    update: XOR<balance_operation_historyUpdateWithoutAdminInput, balance_operation_historyUncheckedUpdateWithoutAdminInput>
    create: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput>
  }

  export type balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput = {
    where: balance_operation_historyWhereUniqueInput
    data: XOR<balance_operation_historyUpdateWithoutAdminInput, balance_operation_historyUncheckedUpdateWithoutAdminInput>
  }

  export type balance_operation_historyUpdateManyWithWhereWithoutAdminInput = {
    where: balance_operation_historyScalarWhereInput
    data: XOR<balance_operation_historyUpdateManyMutationInput, balance_operation_historyUncheckedUpdateManyWithoutAdminInput>
  }

  export type balance_operation_historyScalarWhereInput = {
    AND?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
    OR?: balance_operation_historyScalarWhereInput[]
    NOT?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
    id?: IntFilter<"balance_operation_history"> | number
    admin_id?: IntFilter<"balance_operation_history"> | number
    mt5_login?: StringFilter<"balance_operation_history"> | string
    operation_type?: StringFilter<"balance_operation_history"> | string
    amount?: FloatFilter<"balance_operation_history"> | number
    currency?: StringFilter<"balance_operation_history"> | string
    description?: StringNullableFilter<"balance_operation_history"> | string | null
    status?: StringFilter<"balance_operation_history"> | string
    error_message?: StringNullableFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeFilter<"balance_operation_history"> | Date | string
  }

  export type adminCreateWithoutAdmin_login_logInput = {
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    balance_operation_history?: balance_operation_historyCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutAdmin_login_logInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    balance_operation_history?: balance_operation_historyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutAdmin_login_logInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
  }

  export type adminUpsertWithoutAdmin_login_logInput = {
    update: XOR<adminUpdateWithoutAdmin_login_logInput, adminUncheckedUpdateWithoutAdmin_login_logInput>
    create: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutAdmin_login_logInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutAdmin_login_logInput, adminUncheckedUpdateWithoutAdmin_login_logInput>
  }

  export type adminUpdateWithoutAdmin_login_logInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance_operation_history?: balance_operation_historyUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutAdmin_login_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance_operation_history?: balance_operation_historyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateWithoutBalance_operation_historyInput = {
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutBalance_operation_historyInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutBalance_operation_historyInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
  }

  export type adminUpsertWithoutBalance_operation_historyInput = {
    update: XOR<adminUpdateWithoutBalance_operation_historyInput, adminUncheckedUpdateWithoutBalance_operation_historyInput>
    create: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutBalance_operation_historyInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutBalance_operation_historyInput, adminUncheckedUpdateWithoutBalance_operation_historyInput>
  }

  export type adminUpdateWithoutBalance_operation_historyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutBalance_operation_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type chat_messagesCreateWithoutChat_conversationsInput = {
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesUncheckedCreateWithoutChat_conversationsInput = {
    id?: number
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesCreateOrConnectWithoutChat_conversationsInput = {
    where: chat_messagesWhereUniqueInput
    create: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_messagesCreateManyChat_conversationsInputEnvelope = {
    data: chat_messagesCreateManyChat_conversationsInput | chat_messagesCreateManyChat_conversationsInput[]
    skipDuplicates?: boolean
  }

  export type chat_participantsCreateWithoutChat_conversationsInput = {
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsUncheckedCreateWithoutChat_conversationsInput = {
    id?: number
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsCreateOrConnectWithoutChat_conversationsInput = {
    where: chat_participantsWhereUniqueInput
    create: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_participantsCreateManyChat_conversationsInputEnvelope = {
    data: chat_participantsCreateManyChat_conversationsInput | chat_participantsCreateManyChat_conversationsInput[]
    skipDuplicates?: boolean
  }

  export type chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_messagesWhereUniqueInput
    update: XOR<chat_messagesUpdateWithoutChat_conversationsInput, chat_messagesUncheckedUpdateWithoutChat_conversationsInput>
    create: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_messagesWhereUniqueInput
    data: XOR<chat_messagesUpdateWithoutChat_conversationsInput, chat_messagesUncheckedUpdateWithoutChat_conversationsInput>
  }

  export type chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput = {
    where: chat_messagesScalarWhereInput
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyWithoutChat_conversationsInput>
  }

  export type chat_messagesScalarWhereInput = {
    AND?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    OR?: chat_messagesScalarWhereInput[]
    NOT?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    id?: IntFilter<"chat_messages"> | number
    conversation_id?: IntNullableFilter<"chat_messages"> | number | null
    sender_id?: StringFilter<"chat_messages"> | string
    sender_name?: StringFilter<"chat_messages"> | string
    sender_type?: StringFilter<"chat_messages"> | string
    message_type?: StringNullableFilter<"chat_messages"> | string | null
    content?: StringFilter<"chat_messages"> | string
    metadata?: JsonNullableFilter<"chat_messages">
    is_read?: BoolNullableFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
  }

  export type chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_participantsWhereUniqueInput
    update: XOR<chat_participantsUpdateWithoutChat_conversationsInput, chat_participantsUncheckedUpdateWithoutChat_conversationsInput>
    create: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_participantsWhereUniqueInput
    data: XOR<chat_participantsUpdateWithoutChat_conversationsInput, chat_participantsUncheckedUpdateWithoutChat_conversationsInput>
  }

  export type chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput = {
    where: chat_participantsScalarWhereInput
    data: XOR<chat_participantsUpdateManyMutationInput, chat_participantsUncheckedUpdateManyWithoutChat_conversationsInput>
  }

  export type chat_participantsScalarWhereInput = {
    AND?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
    OR?: chat_participantsScalarWhereInput[]
    NOT?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
    id?: IntFilter<"chat_participants"> | number
    conversation_id?: IntNullableFilter<"chat_participants"> | number | null
    user_id?: StringFilter<"chat_participants"> | string
    user_name?: StringFilter<"chat_participants"> | string
    user_type?: StringFilter<"chat_participants"> | string
    role?: StringNullableFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableFilter<"chat_participants"> | boolean | null
  }

  export type chat_conversationsCreateWithoutChat_messagesInput = {
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_participants?: chat_participantsCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUncheckedCreateWithoutChat_messagesInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_participants?: chat_participantsUncheckedCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsCreateOrConnectWithoutChat_messagesInput = {
    where: chat_conversationsWhereUniqueInput
    create: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
  }

  export type chat_conversationsUpsertWithoutChat_messagesInput = {
    update: XOR<chat_conversationsUpdateWithoutChat_messagesInput, chat_conversationsUncheckedUpdateWithoutChat_messagesInput>
    create: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
    where?: chat_conversationsWhereInput
  }

  export type chat_conversationsUpdateToOneWithWhereWithoutChat_messagesInput = {
    where?: chat_conversationsWhereInput
    data: XOR<chat_conversationsUpdateWithoutChat_messagesInput, chat_conversationsUncheckedUpdateWithoutChat_messagesInput>
  }

  export type chat_conversationsUpdateWithoutChat_messagesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_participants?: chat_participantsUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsUncheckedUpdateWithoutChat_messagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_participants?: chat_participantsUncheckedUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsCreateWithoutChat_participantsInput = {
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUncheckedCreateWithoutChat_participantsInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsCreateOrConnectWithoutChat_participantsInput = {
    where: chat_conversationsWhereUniqueInput
    create: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
  }

  export type chat_conversationsUpsertWithoutChat_participantsInput = {
    update: XOR<chat_conversationsUpdateWithoutChat_participantsInput, chat_conversationsUncheckedUpdateWithoutChat_participantsInput>
    create: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
    where?: chat_conversationsWhereInput
  }

  export type chat_conversationsUpdateToOneWithWhereWithoutChat_participantsInput = {
    where?: chat_conversationsWhereInput
    data: XOR<chat_conversationsUpdateWithoutChat_participantsInput, chat_conversationsUncheckedUpdateWithoutChat_participantsInput>
  }

  export type chat_conversationsUpdateWithoutChat_participantsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsUncheckedUpdateWithoutChat_participantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutChat_conversationsNestedInput
  }

  export type ib_group_assignmentsCreateWithoutIb_requestsInput = {
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput = {
    id?: number
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput = {
    where: ib_group_assignmentsWhereUniqueInput
    create: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsCreateManyIb_requestsInputEnvelope = {
    data: ib_group_assignmentsCreateManyIb_requestsInput | ib_group_assignmentsCreateManyIb_requestsInput[]
    skipDuplicates?: boolean
  }

  export type ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput = {
    where: ib_group_assignmentsWhereUniqueInput
    update: XOR<ib_group_assignmentsUpdateWithoutIb_requestsInput, ib_group_assignmentsUncheckedUpdateWithoutIb_requestsInput>
    create: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput = {
    where: ib_group_assignmentsWhereUniqueInput
    data: XOR<ib_group_assignmentsUpdateWithoutIb_requestsInput, ib_group_assignmentsUncheckedUpdateWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput = {
    where: ib_group_assignmentsScalarWhereInput
    data: XOR<ib_group_assignmentsUpdateManyMutationInput, ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsScalarWhereInput = {
    AND?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
    OR?: ib_group_assignmentsScalarWhereInput[]
    NOT?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
    id?: IntFilter<"ib_group_assignments"> | number
    ib_request_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    group_id?: StringFilter<"ib_group_assignments"> | string
    group_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
  }

  export type ib_requestsCreateWithoutIb_group_assignmentsInput = {
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput = {
    id?: number
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_requestsCreateOrConnectWithoutIb_group_assignmentsInput = {
    where: ib_requestsWhereUniqueInput
    create: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
  }

  export type ib_requestsUpsertWithoutIb_group_assignmentsInput = {
    update: XOR<ib_requestsUpdateWithoutIb_group_assignmentsInput, ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput>
    create: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
    where?: ib_requestsWhereInput
  }

  export type ib_requestsUpdateToOneWithWhereWithoutIb_group_assignmentsInput = {
    where?: ib_requestsWhereInput
    data: XOR<ib_requestsUpdateWithoutIb_group_assignmentsInput, ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput>
  }

  export type ib_requestsUpdateWithoutIb_group_assignmentsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityLogCreateManyAdminInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type DepositCreateManyUserInput = {
    id?: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountCreateManyUserInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateManyUserInput = {
    id: string
    instrumentId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type WithdrawalCreateManyUserInput = {
    id?: string
    mt5AccountId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutDepositsNestedInput
    transactions?: TransactionUpdateManyWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deposit?: DepositUpdateOneWithoutTransactionsNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instrument?: InstrumentUpdateOneRequiredWithoutUserFavoriteNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUpdateManyWithoutWithdrawalNestedInput
    mt5Account?: MT5AccountUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutWithdrawalNestedInput
  }

  export type WithdrawalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DefaultMT5AccountCreateManyMT5AccountInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DepositCreateManyMt5AccountInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5TransactionCreateManyMt5AccountInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateManyMt5AccountInput = {
    id?: string
    userId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
  }

  export type DefaultMT5AccountUpdateWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
  }

  export type DefaultMT5AccountUncheckedUpdateWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepositsNestedInput
    transactions?: TransactionUpdateManyWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateManyWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5TransactionUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionUncheckedUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionUncheckedUpdateManyWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUpdateManyWithoutWithdrawalNestedInput
    user?: UserUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalUncheckedUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutWithdrawalNestedInput
  }

  export type WithdrawalUncheckedUpdateManyWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateManyDepositInput = {
    id?: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    withdrawalId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    withdrawal?: WithdrawalUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyWithdrawalInput = {
    id?: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deposit?: DepositUpdateOneWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInstrumentInput = {
    id: string
    userId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUserFavoriteNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logCreateManyAdminInput = {
    id?: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyCreateManyAdminInput = {
    id?: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUpdateWithoutAdminInput = {
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUpdateWithoutAdminInput = {
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateManyChat_conversationsInput = {
    id?: number
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_participantsCreateManyChat_conversationsInput = {
    id?: number
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_messagesUpdateWithoutChat_conversationsInput = {
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesUncheckedUpdateWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesUncheckedUpdateManyWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_participantsUpdateWithoutChat_conversationsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsUncheckedUpdateWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsUncheckedUpdateManyWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ib_group_assignmentsCreateManyIb_requestsInput = {
    id?: number
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUpdateWithoutIb_requestsInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsUncheckedUpdateWithoutIb_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}